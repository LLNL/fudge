<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" xmlns:xlink="http://www.w3.org/1999/xlink">
  <xs:import namespace="http://www.w3.org/1999/xlink" schemaLocation="xlink.xsd"/>

  <!-- xml schema defining structure of a GND file
       author: cmattoon
       IM #: LLNL-MI-491437
       versions: 
       - version 0.2, July 2011
       - version 0.1, November 2010

       this schema can be used to validate that a gnd file has the correct structure:
       >xmllint -schema gnd.xsd filename.gnd  # may wish to use the '-noout' option

       Find definitions of some common data containers at the end of the schema. 
       For example, a crossSection element often contains pointwise or piecewise data,
       which inherit from the 'xData_XYs1d' and 'xData_regions_1d' data containers. -->


  <!-- We start by defining <reactionSuite>, the root element of a GND file.
       A reactionSuite contains
       - one each of:
         'styles' (may be 'evaluated', 'processed', etc)
         'documentations'
         'particles' (list of all particles going in and out of each reaction in the file)
         'resonances' (optional)
       - followed by one or more of:
         'reaction' (defines a single reaction, includes cross section and product information)
       - and 0 or more of:
         'summedReaction' (for total, nonelastic, etc)
         'fissionComponent' (for 1st-, 2nd-, etc fissions, to avoid double-counting if total is present)
         'production' (for storing production cross section for radioactive products)
  -->

  <xs:element name="reactionSuite">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="styles" type="styles"/>
        <xs:element name="documentations" type="documentations"/>
        <xs:element ref="PoPs"/>
        <xs:element ref="resonances" minOccurs="0"/>
        <xs:element name="reactions" type="reactions"/>
        <xs:element name="orphanProducts" type="orphanProducts" minOccurs="0" maxOccurs="1"/>
        <xs:element name="sums" type="sums" minOccurs="0" maxOccurs="1"/>
        <xs:element name="fissionComponents" type="fissionComponents" minOccurs="0" maxOccurs="1"/>
        <xs:element name="productions" type="productions" minOccurs="0" maxOccurs="1"/>
        <xs:element name="applicationData" minOccurs="0"/>  <!-- content of 'applicationData' is unspecified -->
      </xs:sequence>
      <xs:attribute name="projectile" type="xs:NCName" use="required"/>
      <xs:attribute name="target" type="xs:NCName" use="required"/>
      <xs:attribute name="evaluation" type="xs:string" use="required"/>
      <xs:attribute name="projectileFrame" type="frame" use="required"/>
      <xs:attribute name="version" type="xs:string" use="required"/>
    </xs:complexType>
  </xs:element>

    <xs:complexType name="styles">
      <xs:choice maxOccurs="unbounded">
        <xs:element name="evaluated">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="temperature" type="PhysicalQuantity"/>
            </xs:sequence>
            <xs:attribute name="label" type="xs:NCName" use="required"/>
            <xs:attribute name="library" type="xs:string" use="required"/>
            <xs:attribute name="version" use="required"/>
            <xs:attribute name="date" type="xs:date" use="required"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="crossSectionReconstructed">
          <xs:complexType>
            <xs:attribute name="label" type="xs:NCName" use="required"/>
            <xs:attribute name="date" type="xs:date" use="required"/>
            <xs:attribute name="derivedFrom" type="xs:string" use="required"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="heated">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="temperature" type="PhysicalQuantity"/>
            </xs:sequence>
            <xs:attribute name="label" type="xs:NCName" use="required"/>
            <xs:attribute name="date" type="xs:date" use="required"/>
            <xs:attribute name="derivedFrom" type="xs:string" use="required"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="averageProductData">
          <xs:complexType>
            <xs:attribute name="label" type="xs:NCName" use="required"/>
            <xs:attribute name="date" type="xs:date" use="required"/>
            <xs:attribute name="derivedFrom" type="xs:string" use="required"/>
          </xs:complexType>
        </xs:element>
      </xs:choice>
    </xs:complexType>

    <xs:complexType name="documentations">
      <xs:sequence>
        <xs:element name="documentation" maxOccurs="unbounded"/>
      </xs:sequence>
    </xs:complexType>

    <xs:complexType name="documentation" mixed="true">
      <xs:attribute name="name" type="xs:NCName" use="required"/>
    </xs:complexType>


  <!-- properties of particles, or PoPs -->
  <xs:element name="PoPs">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="documentations" type="documentations" minOccurs="0"/>
        <xs:element name="aliases" type="aliases" minOccurs="0"/>
        <xs:element name="gaugeBosons" type="gaugeBosons" minOccurs="0"/>
        <xs:element name="leptons" type="leptons" minOccurs="0"/>
        <xs:element name="baryons" type="baryons" minOccurs="0"/>
        <xs:element name="chemicalElements" type="chemicalElements" minOccurs="0"/>
      </xs:sequence>
      <xs:attribute name="name" type="xs:string" use="required"/>
      <xs:attribute name="version" type="xs:string" use="required"/>
      <xs:attribute name="format" type="xs:string" use="required"/>
    </xs:complexType>
  </xs:element>

    <xs:complexType name="aliases">
      <xs:choice maxOccurs="unbounded">
        <xs:element name="alias">
          <xs:complexType>
            <xs:attribute name="id" type="xs:string" use="required"/>
            <xs:attribute name="pid" type="xs:string" use="required"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="metaStable">
          <xs:complexType>
            <xs:attribute name="id" type="xs:string" use="required"/>
            <xs:attribute name="pid" type="xs:string" use="required"/>
            <xs:attribute name="metaStableIndex" type="xs:integer" use="required"/>
          </xs:complexType>
        </xs:element>
      </xs:choice>
    </xs:complexType>
    <xs:complexType name="gaugeBosons">
      <xs:sequence>
        <xs:element name="gaugeBoson" type="PoPs_basicParticle" maxOccurs="unbounded"/>
      </xs:sequence>
    </xs:complexType>

    <xs:complexType name="leptons">
      <xs:sequence>
        <xs:element name="lepton" type="lepton" maxOccurs="unbounded"/>
      </xs:sequence>
    </xs:complexType>

      <xs:complexType name="lepton">
        <xs:complexContent>
          <xs:extension base="PoPs_basicParticle">
            <xs:attribute name="generation" type="xs:string" use="required"/>
          </xs:extension>
        </xs:complexContent>
      </xs:complexType>

    <xs:complexType name="baryons">
      <xs:sequence>
        <xs:element name="baryon" type="PoPs_basicParticle" maxOccurs="unbounded"/>
      </xs:sequence>
    </xs:complexType>

      <xs:complexType name="PoPs_basicParticle">
        <xs:sequence>
          <xs:element name="mass" type="PoPs_quantity"/>
          <xs:element name="spin" type="PoPs_quantity"/>
          <xs:element name="parity" type="PoPs_quantity"/>
          <xs:element name="charge" type="PoPs_quantity"/>
          <xs:element name="halflife" type="PoPs_quantity"/>
        </xs:sequence>
        <xs:attribute name="id" type="xs:string"/>
      </xs:complexType>

      <xs:complexType name="PoPs_quantity">
        <xs:choice>
          <xs:element name="double" type="PQU_double"/>
          <xs:element name="integer" type="PQU_integer"/>
          <xs:element name="fraction" type="PQU_fraction"/>
          <xs:element name="string" type="PQU_string"/>
        </xs:choice>
      </xs:complexType>

    <xs:complexType name="chemicalElements">
      <xs:sequence>
        <xs:element maxOccurs="unbounded" name="chemicalElement" type="chemicalElement"/>
      </xs:sequence>
    </xs:complexType>

      <xs:complexType name="chemicalElement">
        <xs:sequence>
          <xs:element minOccurs="0" maxOccurs="unbounded" name="isotope" type="PoPs_isotope"/>
        </xs:sequence>
        <xs:attribute name="id" type="xs:NMTOKEN" use="required"/>
        <xs:attribute name="Z" type="xs:integer" use="required"/>
        <xs:attribute name="name" type="xs:string" use="required"/>
      </xs:complexType>

      <xs:complexType name="PoPs_isotope">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" name="nuclearLevel" type="PoPs_nuclearLevel"/>
        </xs:sequence>
        <xs:attribute name="id" type="xs:NMTOKEN" use="required"/>
        <xs:attribute name="A" type="xs:integer" use="required"/>
      </xs:complexType>

      <xs:complexType name="PoPs_nuclearLevel">
        <xs:sequence>
          <xs:element name="mass" type="PoPs_quantity" minOccurs="0"/>
          <xs:element name="spin" type="PoPs_quantity" minOccurs="0"/>
          <xs:element name="charge" type="PoPs_quantity"/>
          <xs:element name="nucleus" type="PoPs_nucleus"/>
        </xs:sequence>
        <xs:attribute name="id" type="xs:NMTOKEN" use="required"/>
      </xs:complexType>

      <xs:complexType name="PoPs_nucleus">
        <xs:sequence>
          <xs:element name="mass" type="PoPs_quantity" minOccurs="0"/>
          <xs:element name="spin" type="PoPs_quantity" minOccurs="0"/>
          <xs:element name="parity" type="PoPs_quantity" minOccurs="0"/>
          <xs:element name="charge" type="PoPs_quantity"/>
          <xs:element name="halflife" type="PoPs_quantity" minOccurs="0"/>
          <xs:element name="decays" type="PoPs_decays" minOccurs="0"/>
          <xs:element name="decayData" type="PoPs_decayData" minOccurs="0"/>
          <xs:element name="energy" type="PoPs_quantity" minOccurs="0"/>
        </xs:sequence>
        <xs:attribute name="id" type="xs:NMTOKEN"/>
        <xs:attribute name="index" type="xs:string"/> <!-- could be integer or 's', 'c' -->
      </xs:complexType>

    <xs:complexType name="PoPs_decays">
      <xs:sequence>
        <xs:element name="decay" maxOccurs="unbounded">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="probability" type="PoPs_quantity"/>
              <xs:element name="products" type="PoPs_decayProducts"/>
            </xs:sequence>
            <xs:attribute name="label" type="xs:string" use="required"/>  <!-- enumerate allowed decay types? -->
          </xs:complexType>
        </xs:element>
      </xs:sequence>
    </xs:complexType>

    <xs:complexType name="PoPs_decayProducts">
      <xs:sequence>
        <xs:element name="product" maxOccurs="unbounded">
          <xs:complexType>
            <xs:attribute name="label" type="xs:NMTOKEN" use="required"/>
            <xs:attribute name="pid" type="xs:NMTOKEN" use="required"/>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
    </xs:complexType>

    <xs:complexType name="PoPs_decayData">
      <xs:sequence>
        <xs:element name="decayModes" minOccurs="0">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="decayMode" type="PoPs_decayMode" maxOccurs="unbounded"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="averageEnergies" type="PoPs_averageEnergies" minOccurs="0"/>
      </xs:sequence>
    </xs:complexType>

    <xs:complexType name="PoPs_decayMode">
      <xs:sequence>
        <xs:element name="probability" type="PoPs_quantity"/>
        <xs:element name="Q" type="PoPs_quantity" minOccurs="0"/>
        <xs:element name="decayPath">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="decay" type="PoPs_decay" maxOccurs="unbounded"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="spectra" minOccurs="0">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="spectrum" type="PoPs_spectrum" maxOccurs="unbounded"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
      <xs:attribute name="label" type="xs:string" use="required"/>
      <xs:attribute name="mode" type="xs:string" use="required"/>
    </xs:complexType>

    <xs:complexType name="PoPs_decay">
      <xs:sequence>
        <xs:element name="products" minOccurs="0"> <!-- FIXME should be required? -->
          <xs:complexType>
            <xs:sequence>
              <xs:element name="product" type="PoPs_product" maxOccurs="unbounded"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
      <xs:attribute name="index" type="xs:integer" use="required"/>
      <xs:attribute name="type" type="xs:string"/>
      <xs:attribute name="complete" type="xs:boolean"/>
    </xs:complexType>

    <xs:complexType name="PoPs_product">
      <xs:attribute name="label" type="xs:string" use="required"/>
      <xs:attribute name="pid" type="xs:string" use="required"/>
    </xs:complexType>

    <xs:complexType name="PoPs_averageEnergies">
      <xs:sequence>
        <xs:element name="averageEnergy" maxOccurs="unbounded">
          <xs:complexType>
            <xs:attribute name="label" type="xs:string"/>
            <xs:attribute name="value" type="xs:double"/>
            <xs:attribute name="unit" type="xs:string"/>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
    </xs:complexType>

    <xs:complexType name="PoPs_spectrum">
      <xs:choice maxOccurs="unbounded">
        <xs:element name="discrete" type="PoPs_discrete"/>
        <xs:element name="continuum" type="PoPs_continuum"/>
      </xs:choice>
      <xs:attribute name="label" type="xs:string" use="required"/>
      <xs:attribute name="pid" type="xs:string" use="required"/>
    </xs:complexType>

    <xs:complexType name="PoPs_discrete">
      <xs:sequence>
        <xs:element name="intensity">   <!-- FIXME should look like other PoPs quantities -->
          <xs:complexType>
            <xs:attribute name="value" type="xs:double"/>
            <xs:attribute name="unit" type="xs:string"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="energy">
          <xs:complexType>
            <xs:attribute name="value" type="xs:double"/>
            <xs:attribute name="unit" type="xs:string"/>
          </xs:complexType>
        </xs:element>
        <xs:element name="internalConversionCoefficients" type="PoPs_internalConversionCoefficients" minOccurs="0"/>
        <xs:element name="internalPairFormationCoefficient" minOccurs="0">
          <xs:complexType>
            <xs:attribute name="value" type="xs:double"/>
            <xs:attribute name="unit" type="xs:string"/>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
      <xs:attribute name="type" type="xs:string"/>
    </xs:complexType>

    <xs:complexType name="PoPs_continuum">
      <xs:sequence>
        <xs:element name="XYs1d" type="xData_XYs1d_primary"/>
      </xs:sequence>
    </xs:complexType>

    <xs:complexType name="PoPs_internalConversionCoefficients">
      <xs:sequence>
        <xs:element name="shell" maxOccurs="unbounded">
          <xs:complexType>
            <xs:attribute name="label" type="xs:string"/>
            <xs:attribute name="value" type="xs:double"/>
            <xs:attribute name="unit" type="xs:string"/>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
    </xs:complexType>

  <!-- resonances may contain just a scattering radius, or may contain resolved/unresolved sections -->
  <xs:element name="resonances">
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" name="documentations" type="documentations"/>
        <xs:choice>
          <xs:element name="scatteringRadius" type="scatteringRadius"/>
          <xs:sequence>
            <xs:element minOccurs="0" maxOccurs="1" name="resolved" type="resolved"/>
            <xs:element minOccurs="0" maxOccurs="1" name="unresolved" type="unresolved"/>
          </xs:sequence>
        </xs:choice>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

    <xs:complexType name="scatteringRadius">
      <xs:choice>
        <xs:element name="constant1d" type="xData_constant1d"/>
        <xs:element name="constant" type="constantScatteringRadius"/>
        <xs:element name="XYs1d" type="xData_XYs1d_primary"/>
      </xs:choice>
      <xs:attribute name="lowerBound" type="PhysicalQuantityAttribute"/>
      <xs:attribute name="upperBound" type="PhysicalQuantityAttribute"/>
    </xs:complexType>

      <!-- types of scattering radius -->

        <xs:complexType name="constantScatteringRadius">
          <xs:attribute name="label" type="xs:string"/>
          <xs:attribute name="value" type="xs:double" use="required"/>
          <xs:attribute name="unit" type="xs:string" use="required"/>
          <xs:attribute name="domainMin" type="xs:double"/>
          <xs:attribute name="domainMax" type="xs:double"/>
          <xs:attribute name="domainUnit" type="xs:string"/>
        </xs:complexType>

    <xs:complexType name="resonanceRegionQ">
      <xs:sequence>
        <xs:element name="constant" type="constantQ"/>
      </xs:sequence>
    </xs:complexType>

      <xs:complexType name="constantQ">
        <xs:attribute name="value" type="xs:double" use="required"/>
        <xs:attribute name="unit" type="xs:string" use="required"/>
      </xs:complexType>

    <xs:complexType name="resolved">
      <xs:choice>
        <xs:element name="SingleLevel_BreitWigner" type="SingleLevel_BreitWigner"/>
        <xs:element name="MultiLevel_BreitWigner" type="MultiLevel_BreitWigner"/>
        <xs:element name="RMatrix" type="RMatrix"/>

        <!-- multiple resolved regions are currently allowed but deprecated (only in ENDF-VII Pu239 right now) --> 
        <xs:element maxOccurs="unbounded" name="region">
          <xs:complexType>
            <xs:choice>
              <xs:element name="SingleLevel_BreitWigner" type="SingleLevel_BreitWigner"/>
              <xs:element name="MultiLevel_BreitWigner" type="MultiLevel_BreitWigner"/>
              <xs:element name="RMatrix" type="RMatrix"/>
            </xs:choice>
            <xs:attribute name="index" type="xs:integer" use="required"/>
            <xs:attribute name="domainMin" type="xs:double" use="required"/>
            <xs:attribute name="domainMax" type="xs:double" use="required"/>
            <xs:attribute name="domainUnit" type="xs:string" use="required"/>
            <xs:attribute name="formalism" type="xs:NCName" use="required"/>
          </xs:complexType>
        </xs:element>

      </xs:choice>
      <xs:attribute name="multipleRegions" type="xs:NCName"/>
      <xs:attribute name="domainMin" type="xs:double" use="required"/>
      <xs:attribute name="domainMax" type="xs:double" use="required"/>
      <xs:attribute name="domainUnit" type="xs:string" use="required"/>
      <xs:attribute name="reconstructCrossSection" type="xs:boolean"/>
      <xs:attribute name="formalism" type="xs:NCName"/>
    </xs:complexType>

      <!-- types of resolved resonance data -->
      <xs:complexType name="SingleLevel_BreitWigner">
        <xs:sequence>
          <xs:element name="scatteringRadius" type="scatteringRadius"/>
          <xs:element name="resonanceParameters" type="resonanceParameters"/>
        </xs:sequence>
        <xs:attribute name="calculateChannelRadius" type="xs:boolean" use="required"/>
      </xs:complexType>

      <xs:complexType name="MultiLevel_BreitWigner">
        <xs:sequence>
          <xs:element name="scatteringRadius" type="scatteringRadius"/>
          <xs:element name="resonanceParameters" type="resonanceParameters"/>
        </xs:sequence>
        <xs:attribute name="calculateChannelRadius" type="xs:boolean"/>
      </xs:complexType>

      <xs:complexType name="Reich_Moore">
        <xs:sequence>
          <xs:element name="scatteringRadius" type="scatteringRadius"/>
          <xs:element name="resonanceParameters" type="resonanceParameters"/>
        </xs:sequence>
        <xs:attribute name="LvaluesNeededForConvergence" type="xs:integer" use="required"/>
        <xs:attribute name="calculateChannelRadius" type="xs:boolean"/>
        <xs:attribute name="computeAngularDistribution" type="xs:boolean"/>
      </xs:complexType>

      <xs:complexType name="RMatrix">
        <xs:sequence>
          <xs:element name="resonanceReactions">
            <xs:complexType>
              <xs:sequence>
                <xs:element maxOccurs="unbounded" name="resonanceReaction" type="resonanceReaction"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element maxOccurs="unbounded" name="spinGroup" type="RML_spinGroup"/>
        </xs:sequence>
        <xs:attribute name="approximation" type="xs:NCName" use="required"/>
        <xs:attribute name="boundaryCondition" type="xs:string" use="required"/>
        <xs:attribute name="reconstructAngular" type="xs:boolean"/>
        <xs:attribute name="calculatePenetrability" type="xs:boolean"/>
        <xs:attribute name="calculateChannelRadius" type="xs:boolean"/>
        <xs:attribute name="ENDFconversionFlag" type="xs:string"/>
      </xs:complexType>

        <!-- for R-Matrix format, specify each resononance reaction followed by list of resonances grouped by 'spinGroup' -->
        <xs:complexType name="resonanceReaction">
          <xs:sequence>
            <xs:element name="link" type="xlink"/>
            <xs:element name="Q" type="resonanceRegionQ" minOccurs="0"/>
            <xs:element name="scatteringRadius" type="scatteringRadius" minOccurs="0"/>
            <xs:element name="hardSphereRadius" type="scatteringRadius" minOccurs="0"/>
          </xs:sequence>
          <xs:attribute name="label" type="xs:string" use="required"/>
          <xs:attribute name="ejectile" type="xs:string" use="required"/>
          <xs:attribute name="computeShiftFactor" type="xs:boolean"/>
          <xs:attribute name="eliminated" type="xs:boolean"/>
        </xs:complexType>
        <xs:complexType name="RML_spinGroup">
          <xs:sequence>
            <xs:element name="channels" type="RML_channels"/>
            <xs:element minOccurs="0" maxOccurs="1" name="resonanceParameters" type="resonanceParameters"/>
          </xs:sequence>
          <xs:attribute name="index" type="xs:integer" use="required"/>
          <xs:attribute name="spin" type="fractionAttribute" use="required"/>
          <xs:attribute name="parity" type="xs:integer" use="required"/>
        </xs:complexType>
        <xs:complexType name="RML_channels">
          <xs:sequence>
            <xs:element name="channel" type="RML_channel" maxOccurs="unbounded"/>
          </xs:sequence>
        </xs:complexType>
        <xs:complexType name="RML_channel">
          <xs:sequence>
            <xs:element name="scatteringRadius" type="scatteringRadius" minOccurs="0"/>
            <xs:element name="hardSphereRadius" type="scatteringRadius" minOccurs="0"/>
          </xs:sequence>
          <xs:attribute name="label" type="xs:string" use="required"/>
          <xs:attribute name="resonanceReaction" type="xs:string" use="required"/>
          <xs:attribute name="L" type="xs:integer" use="required"/>
          <xs:attribute name="channelSpin" type="fractionAttribute" use="required"/>
          <xs:attribute name="boundaryConditionOverride" type="xs:double"/>
          <xs:attribute name="columnIndex" type="xs:integer" use="required"/>
        </xs:complexType>

    <xs:complexType name="resonanceParameters">
      <xs:sequence>
        <xs:element name="table" type="table"/>
      </xs:sequence>
    </xs:complexType>

    <!-- unresolved resonance region -->
    <xs:complexType name="unresolved">
      <xs:choice>
        <xs:element name="tabulatedWidths" type="tabulatedWidths"/>
      </xs:choice>
      <xs:attribute name="domainMin" type="xs:double" use="required"/>
      <xs:attribute name="domainMax" type="xs:double" use="required"/>
      <xs:attribute name="domainUnit" type="xs:string" use="required"/>
      <xs:attribute name="formalism" type="xs:NCName" use="required"/>
      <xs:attribute name="reconstructCrossSection" type="xs:boolean"/>
    </xs:complexType>

      <!-- currently only support one format for unresolved: -->
      <xs:complexType name="tabulatedWidths">
        <xs:sequence>
          <xs:element name="scatteringRadius" type="scatteringRadius"/>
          <xs:element maxOccurs="unbounded" name="L_section" type="URR_L_section"/>
        </xs:sequence>
        <xs:attribute name="interpolation" type="interpolation" use="required"/>
        <xs:attribute name="ENDFconversionFlag" use="required"/>
      </xs:complexType>

      <xs:complexType name="URR_L_section">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" name="J_section" type="URR_J_section"/>
        </xs:sequence>
        <xs:attribute name="L" use="required" type="xs:integer"/>
      </xs:complexType>

      <xs:complexType name="URR_J_section">
        <xs:sequence>
          <xs:element minOccurs="0" name="constantWidths" type="URR_constantWidths"/>
          <xs:element minOccurs="0" name="energyDependentWidths" type="energyDependentWidths"/>
        </xs:sequence>
        <xs:attribute name="J" use="required"/>
        <xs:attribute name="neutronDOF" type="xs:integer" use="required"/>
        <xs:attribute name="fissionDOF" type="xs:integer"/>
        <xs:attribute name="competitiveDOF" type="xs:decimal"/>
      </xs:complexType>

      <xs:complexType name="URR_constantWidths">
        <xs:attribute name="neutronWidth" type="PhysicalQuantityAttribute"/>
        <xs:attribute name="captureWidth" type="PhysicalQuantityAttribute"/>
        <xs:attribute name="fissionWidthA" type="PhysicalQuantityAttribute"/>
        <xs:attribute name="levelSpacing" type="PhysicalQuantityAttribute"/>
      </xs:complexType>

      <xs:complexType name="energyDependentWidths">
        <xs:sequence>
          <xs:element name="table" type="table"/>
        </xs:sequence>
      </xs:complexType>



  <!-- after the documentation, particles and resonances the GND file continues
       with '<reactions>', '<orphanProducts>', '<sums>', '<productions>' and '<fissionComponents>' elements. -->
  <xs:complexType name="reactions">
    <xs:sequence>
      <xs:element ref="reaction" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="orphanProducts">
    <xs:sequence>
      <xs:element ref="reaction" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="sums">
    <xs:sequence>
      <xs:element name="crossSections">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="crossSectionSum" type="crossSectionSum" maxOccurs="unbounded"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="multiplicities" minOccurs="0">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="multiplicitySum" type="multiplicitySum" maxOccurs="unbounded"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="fissionComponents">
    <xs:sequence>
      <xs:element ref="fissionComponent" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="productions">
    <xs:sequence>
      <xs:element ref="production" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>


  <!-- reaction class, describes a single reaction including cross section and outputChannel
       with list of products -->
  <xs:element name="reaction">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="documentation" type="documentation" minOccurs="0"/>
        <xs:element ref="dCrossSection_dOmega" minOccurs="0"/>
        <xs:element ref="crossSection"/>
        <xs:element name="outputChannel" type="outputChannel"/>
      </xs:sequence>
      <xs:attribute name="label" type="xs:string" use="required"/>
      <xs:attribute name="fissionGenre" type="xs:NCName"/>
      <xs:attribute name="partialReaction" type="xs:integer"/>
      <xs:attribute name="ENDF_MT" type="xs:integer" use="required"/>
      <xs:attribute name="process" type="xs:string"/>
    </xs:complexType>
  </xs:element>

  <xs:element name="fissionComponent">  <!-- for 1st-chance, 2nd-chance etc -->
    <xs:complexType>
      <xs:sequence>
        <xs:element name="documentation" type="documentation" minOccurs="0"/>
        <xs:element ref="crossSection"/>
        <xs:element name="outputChannel" type="fissionComponentOutputChannel"/>
      </xs:sequence>
      <xs:attribute name="label" type="xs:string" use="required"/>
      <xs:attribute name="fissionGenre" type="xs:NCName" use="required"/>
      <xs:attribute name="ENDF_MT" type="xs:integer" use="required"/>
    </xs:complexType>
  </xs:element>

  <xs:element name="production">  <!-- for storing production cross sections -->
    <xs:complexType>
      <xs:sequence>
        <xs:element name="documentation" type="documentation" minOccurs="0"/>
        <xs:element ref="crossSection"/>
        <xs:element name="outputChannel" type="outputChannel"/>
      </xs:sequence>
      <xs:attribute name="label" type="xs:string" use="required"/>
      <xs:attribute name="ENDF_MT" type="xs:integer" use="required"/>
    </xs:complexType>
  </xs:element>

  <!-- May want to expressly store the sum over other quantities (e.g. total cross section or total gamma multiplicity) -->
  <xs:complexType name="crossSectionSum">
    <xs:sequence>
      <xs:element name="documentation" type="documentation" minOccurs="0"/>
      <xs:element name="summands" type="summands"/>
      <xs:element name="Q" type="Q"/>
      <xs:element ref="crossSection"/>
    </xs:sequence>
    <xs:attribute name="label" type="xs:string" use="required"/>
    <xs:attribute name="ENDF_MT" type="xs:integer" use="required"/>
  </xs:complexType>

  <xs:complexType name="multiplicitySum">
    <xs:sequence>
      <xs:element name="documentation" type="documentation" minOccurs="0"/>
      <xs:element name="summands" type="summands"/>
      <xs:element name="multiplicity" type="multiplicity"/>
    </xs:sequence>
    <xs:attribute name="label" type="xs:string" use="required"/>
    <xs:attribute name="ENDF_MT" type="xs:integer" use="required"/>
  </xs:complexType>

  <xs:complexType name="summands">
    <xs:choice maxOccurs="unbounded">
      <xs:element name="add" type="xlink"/>
      <xs:element name="subtract" type="xlink"/>
    </xs:choice>
  </xs:complexType>

  <!-- contents of reaction elements: -->

  <xs:element name="crossSection">
    <xs:complexType>
      <xs:choice maxOccurs="unbounded">
        <xs:element name="XYs1d" type="xData_XYs1d_primary"/>
        <xs:element name="regions1d" type="xData_regions_1d_primary"/>
        <xs:element name="resonancesWithBackground" type="resonancesWithBackground"/>
        <xs:element name="reference" type="xlink"/>
        <xs:element name="CoulombElasticReference" type="xlink"/>
<!--      do these still appear?
        <xs:element name="weightedPointwise" type="weightedPointwise"/>
        <xs:element name="weightedPiecewise" type="weightedPiecewise"/> -->
      </xs:choice>
    </xs:complexType>
  </xs:element>

    <!-- possible forms of crossSection: -->

      <xs:complexType name="resonancesWithBackground">
        <xs:sequence>
          <xs:element name="resonanceRegion" type="xlink"/>
          <xs:choice>
            <xs:element name="XYs1d" type="xData_XYs1d_primary"/>
            <xs:element name="regions1d" type="xData_regions_1d_primary"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="label" type="xs:string" use="required"/>
      </xs:complexType>

<!--      <xs:complexType name="weightedPointwise">
        <xs:sequence>
          <xs:element name="weight" type="xData_1d"/>
        </xs:sequence>
        <xs:attribute ref="xlink:href" use="required"/>
        <xs:attribute ref="xlink:type" use="required"/>
      </xs:complexType>

      <xs:complexType name="weightedPiecewise">
        <xs:sequence>
          <xs:element name="piecewise" type="regionsXYs"/>
        </xs:sequence>
        <xs:attribute ref="xlink:href" use="required"/>
        <xs:attribute ref="xlink:type" use="required"/>
      </xs:complexType>   -->


  <xs:element name="dCrossSection_dOmega">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="CoulombElastic" type="CoulombElastic"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

    <xs:complexType name="CoulombElastic">
      <xs:sequence>
        <xs:element name="RutherfordScattering">
          <xs:complexType>
            <xs:attribute name="domainMin" type="xs:string"/>
            <xs:attribute name="domainMax" type="xs:string"/>
            <xs:attribute name="domainUnit" type="xs:string"/>
          </xs:complexType>
        </xs:element>
        <xs:choice>
          <xs:element name="CoulombExpansion" type="CoulombExpansion"/>
          <xs:element name="NuclearPlusCoulombInterference" type="NuclearPlusCoulombInterference"/>
        </xs:choice>
      </xs:sequence>
      <xs:attribute name="label" type="xs:string" use="required"/>
      <xs:attribute name="productFrame" type="frame" use="required"/>
      <xs:attribute name="identicalParticles" type="xs:boolean"/>
    </xs:complexType>

    <xs:complexType name="CoulombExpansion">
      <xs:sequence>
        <xs:element name="nuclearTerm" type="CoulombExpansionTerm"/>
        <xs:element name="realInterferenceTerm" type="CoulombExpansionTerm"/>
        <xs:element name="imaginaryInterferenceTerm" type="CoulombExpansionTerm"/>
      </xs:sequence>
    </xs:complexType>

    <xs:complexType name="CoulombExpansionTerm">
      <xs:sequence>
        <xs:choice>
          <xs:element name="regions2d" type="xData_regions_2d_primary"/>
          <xs:element name="XYs2d" type="xData_XYs2d_primary"/>
        </xs:choice>
      </xs:sequence>
    </xs:complexType>

    <xs:complexType name="NuclearPlusCoulombInterference">
      <xs:sequence>
        <xs:element name="effectiveCrossSection">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="XYs1d" type="xData_XYs1d_primary"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
        <xs:element name="effectiveDistribution">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="XYs2d" type="xData_XYs2d_primary"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
      <xs:attribute name="muCutoff" type="xs:double" use="required"/>
    </xs:complexType>


  <!-- reaction Q-value -->
  <xs:complexType name="Q">
    <xs:choice minOccurs="1">
      <xs:element name="constant1d" type="xData_constant1d"/>
      <xs:element name="pointwise" type="xData_XYs1d"/>
      <xs:element name="fissionEnergyReleased" type="fissionEnergyReleased"/>
    </xs:choice>
  </xs:complexType>

    <!-- possible forms of Q: -->
    <xs:complexType name="fissionEnergyReleaseSubform">
      <xs:choice>
        <xs:element name="polynomial1d" type="xData_polynomial_1d_primary"/>
        <xs:element name="XYs1d" type="xData_XYs1d_primary"/>
      </xs:choice>
    </xs:complexType>

    <xs:complexType name="fissionEnergyReleased">
      <xs:sequence>
        <xs:element name="promptProductKE" type="fissionEnergyReleaseSubform"/>
        <xs:element name="promptNeutronKE" type="fissionEnergyReleaseSubform"/>
        <xs:element name="delayedNeutronKE" type="fissionEnergyReleaseSubform"/>
        <xs:element name="promptGammaEnergy" type="fissionEnergyReleaseSubform"/>
        <xs:element name="delayedGammaEnergy" type="fissionEnergyReleaseSubform"/>
        <xs:element name="delayedBetaEnergy" type="fissionEnergyReleaseSubform"/>
        <xs:element name="neutrinoEnergy" type="fissionEnergyReleaseSubform"/>
        <xs:element name="nonNeutrinoEnergy" type="fissionEnergyReleaseSubform"/>
        <xs:element name="totalEnergy" type="fissionEnergyReleaseSubform"/>
      </xs:sequence>
      <xs:attribute name="label" use="required"/>
    </xs:complexType>

  <!-- products of a reaction are listed within 'outputChannel'. If a product decays, the
      resulting decay products are listed within another 'outputChannel' -->
    <xs:complexType name="outputChannel">
      <xs:sequence>
        <xs:element name="Q" type="Q"/>
        <xs:element name="products">
          <xs:complexType>
            <xs:sequence>
              <xs:element ref="product" maxOccurs="unbounded"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
      <xs:attribute name="genre" type="xs:NCName" use="required"/>
      <xs:attribute name="process" type="xs:string"/>
    </xs:complexType>

  <!-- fissionComponent output channels don't always have a list of products -->
    <xs:complexType name="fissionComponentOutputChannel">
      <xs:sequence>
        <xs:element name="Q" type="Q"/>
        <xs:element name="products" minOccurs="0">
          <xs:complexType>
            <xs:sequence>
              <xs:element ref="product" maxOccurs="unbounded"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
      <xs:attribute name="genre" type="xs:NCName" use="required"/>
    </xs:complexType>

  <!-- outputChannel contains a list of products: -->
  <xs:element name="product">
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" name="documentations" type="documentations"/>
        <xs:element name="multiplicity" type="multiplicity"/>
        <xs:element name="distribution" type="distribution"/>
        <xs:element minOccurs="0" name="outputChannel" type="outputChannel"/>
        <xs:element minOccurs="0" name="averageProductEnergy" type="averageProductEnergy"/>
      </xs:sequence>
      <xs:attribute name="name" type="xs:string" use="required"/>
      <xs:attribute name="label" type="xs:string" use="required"/>
      <xs:attribute name="decayRate"/>
      <xs:attribute name="emissionMode" type="xs:NCName"/>
      <!-- remove next two?
      <xs:attribute name="primary"/>
      <xs:attribute name="discrete"/>
      -->
      <xs:attribute name="originationLevel"/>
      <xs:attribute name="ENDFconversionFlag"/>
    </xs:complexType>
  </xs:element>

    <!-- each product has a multiplicity: -->

    <xs:complexType name="multiplicity">
      <xs:choice minOccurs="1">
        <xs:element name="constant1d" type="xData_constant1d"/>
        <xs:element name="XYs1d" type="xData_XYs1d_primary"/>
        <xs:element name="regions1d" type="xData_regions_1d_primary"/>
        <xs:element name="polynomial1d" type="xData_polynomial_1d_primary"/>
        <xs:element name="reference" type="xlink"/>
        <xs:element ref="weightedReference"/>
        <xs:element name="unknown"/>
      </xs:choice>
    </xs:complexType>

    <!-- types of multiplicity data -->
      <xs:element name="weightedReference">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="reference" type="xlink"/>
            <xs:element name="XYs1d" type="xData_XYs1d_primary"/>
          </xs:sequence>
          <xs:attribute name="label" type="xs:NCName" use="required"/>
        </xs:complexType>
      </xs:element>

    <!-- products also have distribution data. Start by defining allowed frames -->
    <xs:simpleType name="frame">
      <xs:restriction base="xs:string">
        <xs:enumeration value="lab" />
        <xs:enumeration value="centerOfMass" />
      </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="distribution">
      <xs:choice minOccurs="0">
        <xs:element name="angularTwoBody" type="angularTwoBody"/>
        <xs:element name="uncorrelated" type="uncorrelated"/>
        <xs:element name="angularEnergy" type="angularEnergy"/>
        <xs:element name="energyAngular" type="energyAngular"/>
        <xs:element name="KalbachMann" type="KalbachMann"/>
        <xs:element name="reference" type="xlink"/>
        <xs:element name="CoulombElasticReference" type="xlink"/>
        <xs:element name="coherentScattering" type="coherentScattering"/>
        <xs:element name="incoherentScattering" type="incoherentScattering"/>
        <xs:element name="unknown"/>
        <xs:element name="unspecified"/>  <!-- 'unknown' has an equivalent in ENDF, 'unspecified' doesn't -->
      </xs:choice>
    </xs:complexType>

    <!-- distribution components (angular, energy, etc) -->
    <xs:complexType name="angularTwoBody">
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="XYs2d" type="xData_XYs2d_primary"/>
        <xs:element name="regions2d" type="xData_regions_2d_primary"/>
        <xs:element name="isotropic" type="isotropic"/>
        <xs:element name="recoil" type="xlink"/>
      </xs:choice>
      <xs:attribute name="label" type="xs:NCName" use="required"/>
      <xs:attribute name="productFrame" type="frame" use="required"/>
    </xs:complexType>

    <xs:complexType name="uncorrelated">
      <xs:sequence>
        <xs:element name="angular" type="angular_uncorrelated"/>
        <xs:element name="energy" type="energy_uncorrelated"/>
      </xs:sequence>
      <xs:attribute name="label" type="xs:NCName" use="required"/>
      <xs:attribute name="productFrame" type="frame" use="required"/>
    </xs:complexType>

    <xs:complexType name="angular_uncorrelated">
      <xs:choice maxOccurs="1">
        <xs:element name="XYs2d" type="xData_XYs2d_primary"/>
        <xs:element name="isotropic" type="isotropic"/>
        <xs:element name="forward" type="forward"/>
      </xs:choice>
    </xs:complexType>

    <xs:complexType name="energy_uncorrelated">
      <xs:choice maxOccurs="1">
        <xs:element name="XYs2d" type="xData_XYs2d_primary"/>
        <xs:element name="regions2d" type="xData_regions_2d_primary"/>
        <xs:element name="generalEvaporation" type="generalEvaporation"/>
        <xs:element name="discreteGamma" type="discreteGamma"/>
        <xs:element name="NBodyPhaseSpace" type="NBodyPhaseSpace"/>
        <xs:element name="primaryGamma" type="primaryGamma"/>
        <xs:element name="evaporation" type="evaporation"/>
        <xs:element name="weightedFunctionals" type="weightedFunctionals"/>
        <xs:element name="simpleMaxwellianFission" type="simpleMaxwellianFission"/>
        <xs:element name="Watt" type="Watt"/>
        <xs:element name="MadlandNix" type="MadlandNix"/>
      </xs:choice>
    </xs:complexType>

      <!-- uncorrelated angular distribution forms -->
      <xs:complexType name="isotropic"/>
      <xs:complexType name="forward"/>

      <!-- uncorrelated energy distribution forms -->

        <xs:complexType name="energyFunctionalData">
          <xs:sequence>
            <xs:element name="XYs1d" type="xData_XYs1d_primary"/>
          </xs:sequence>
        </xs:complexType>

        <xs:complexType name="evaporation">
          <xs:sequence>
            <xs:element name="U" type="PhysicalQuantity"/>
            <xs:element name="theta" type="energyFunctionalData"/>
          </xs:sequence>
        </xs:complexType>

        <xs:complexType name="MadlandNix">
          <xs:sequence>
            <xs:element name="EFL" type="PhysicalQuantity"/>
            <xs:element name="EFH" type="PhysicalQuantity"/>
            <xs:element name="T_M" type="energyFunctionalData"/>
          </xs:sequence>
        </xs:complexType>

        <xs:complexType name="Watt">
          <xs:sequence>
            <xs:element name="U" type="PhysicalQuantity"/>
            <xs:element name="a" type="energyFunctionalData"/>
            <xs:element name="b" type="energyFunctionalData"/>
          </xs:sequence>
        </xs:complexType>

        <xs:complexType name="generalEvaporation">
          <xs:sequence>
            <xs:element name="U" type="PhysicalQuantity"/>
            <xs:element name="theta" type="energyFunctionalData"/>
            <xs:element name="g" type="energyFunctionalData"/>
          </xs:sequence>
        </xs:complexType>

        <xs:complexType name="simpleMaxwellianFission">
          <xs:sequence>
            <xs:element name="U" type="PhysicalQuantity"/>
            <xs:element name="theta" type="energyFunctionalData"/>
          </xs:sequence>
        </xs:complexType>

        <!-- energy distribution may be expressed as weighted sum of two or more
             functional forms: -->
        <xs:complexType name="weightedFunctionals">
          <xs:sequence>
            <xs:element maxOccurs="unbounded" name="weighted">
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="XYs1d" type="xData_XYs1d_primary"/>
                  <xs:choice>
                    <xs:element name="evaporation"/>
                  </xs:choice>
                </xs:sequence>
                <xs:attribute name="index" type="xs:integer"/> <!-- FIXME: use="required"/> -->
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>

        <xs:complexType name="NBodyPhaseSpace">
          <xs:sequence>
            <xs:element name="mass" type="PhysicalQuantity"/>
          </xs:sequence>
          <xs:attribute name="numberOfProducts" type="xs:integer" use="required"/>
        </xs:complexType>

        <xs:complexType name="discreteGamma">
          <xs:sequence>
            <xs:element name="axes" type="axes"/>
          </xs:sequence>
          <xs:attribute name="value" type="xs:double" use="required"/>
          <xs:attribute name="domainMin" type="xs:double" use="required"/>
          <xs:attribute name="domainMax" type="xs:double" use="required"/>
        </xs:complexType>

        <xs:complexType name="primaryGamma">
          <xs:sequence>
            <xs:element name="axes" type="axes"/>
          </xs:sequence>
          <xs:attribute name="value" type="xs:double" use="required"/>
          <xs:attribute name="domainMin" type="xs:double" use="required"/>
          <xs:attribute name="domainMax" type="xs:double" use="required"/>
        </xs:complexType>
        <!-- end of energy distribution forms -->

    <xs:complexType name="angularEnergy">
      <xs:sequence>
        <xs:element name="XYs3d" type="xData_XYs3d_primary"/>
      </xs:sequence>
      <xs:attribute name="label" type="xs:NCName" use="required"/>
      <xs:attribute name="productFrame" type="frame" use="required"/>
    </xs:complexType>

    <xs:complexType name="energyAngular">
      <xs:sequence>
        <xs:element name="XYs3d" type="xData_XYs3d_primary"/>
      </xs:sequence>
      <xs:attribute name="label" type="xs:NCName" use="required"/>
      <xs:attribute name="productFrame" type="frame" use="required"/>
    </xs:complexType>

    <xs:complexType name="KalbachMann">
      <xs:sequence>
        <xs:element name="f" type="KalbachMann_subform"/>
        <xs:element name="r" type="KalbachMann_subform"/>
        <xs:element name="a" type="KalbachMann_subform" minOccurs="0"/>
      </xs:sequence>
      <xs:attribute name="label" type="xs:NCName" use="required"/>
      <xs:attribute name="productFrame" type="frame" use="required"/>
    </xs:complexType>

        <!-- f,r and a inside KalbachMann look the same -->
        <xs:complexType name="KalbachMann_subform">
          <xs:sequence>
            <xs:element name="XYs2d" type="xData_XYs2d_primary"/>
          </xs:sequence>
        </xs:complexType>

    <!-- coherent/incoherent: special distribution types for photo-atomic data -->
    <xs:complexType name="coherentScattering">
      <xs:sequence>
        <!-- expansion has either one or three terms: scattering factor, optionally real and imaginary anomalous factors -->
        <xs:sequence>
          <xs:element name="scatteringFactor" type="coherentScattering_subform"/>
          <xs:element name="realAnomalousFactor" type="coherentScattering_subform" minOccurs="0"/>
          <xs:element name="imaginaryAnomalousFactor" type="coherentScattering_subform" minOccurs="0"/>
        </xs:sequence>
      </xs:sequence>
      <xs:attribute name="label" type="xs:NCName" use="required"/>
      <xs:attribute name="productFrame" type="frame" use="required"/>
    </xs:complexType>

        <xs:complexType name="coherentScattering_subform">
          <xs:choice>
            <xs:element name="XYs1d" type="xData_XYs1d_primary"/>
            <xs:element name="regions1d" type="xData_regions_1d_primary"/>
          </xs:choice>
        </xs:complexType>

    <xs:complexType name="incoherentScattering">
      <xs:choice>
        <xs:element name="XYs1d" type="xData_XYs1d_primary"/>
        <xs:element name="regions1d" type="xData_regions_1d_primary"/>
      </xs:choice>
      <xs:attribute name="label" type="xs:NCName" use="required"/>
      <xs:attribute name="productFrame" type="frame" use="required"/>
    </xs:complexType>

    <xs:complexType name="unknown">
      <xs:attribute name="label" type="xs:NCName" use="required"/>
      <xs:attribute name="productFrame" type="frame" use="required"/>
    </xs:complexType>

    <xs:complexType name="unspecified">
      <xs:attribute name="label" type="xs:NCName" use="required"/>
      <xs:attribute name="productFrame" type="frame" use="required"/>
    </xs:complexType>
    <!-- end of distribution components. -->

    <!-- optional: product may have energy deposition -->
    <xs:complexType name="averageProductEnergy">
      <xs:choice minOccurs="0">
        <xs:element name="XYs1d" type="xData_XYs1d_primary"/>
        <xs:element name="regions1d" type="xData_regions_1d_primary"/>
      </xs:choice>
    </xs:complexType>





  <!-- Some basic data containers are used throughout GND files, and are defined here.
       They include 'axes' which contains information on units and interpolation,
       'PhysicalQuantity' containing a number with units, link (using xlink syntax),
       pointwise and piecewise versions of 1,2 and 3-dimensional data containers,
       and the 'table' element: -->
  
  <xs:complexType name="xlink">
    <xs:attribute name="label" type="xs:NCName"/>
    <xs:attribute ref="xlink:type"/>
    <xs:attribute ref="xlink:href" use="required"/>
  </xs:complexType>

  <!-- check that 'PhysicalQuantity' attributes have both number and unit: '7.24e+7 eV' for example.
      In special cases, they can also start with 'u:' (for undefined levels) -->
  <xs:simpleType name="PhysicalQuantityAttribute">
    <xs:restriction base="xs:string">
      <xs:pattern value="(u:)?(-?[0-9]+)(\.[0-9]*)?(e(\+|\-)?[0-9]+)? [a-zA-Z*/]+"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- Alternate representation for physicalQuantity: element with separate value and unit -->
  <xs:complexType name="PhysicalQuantity">
    <xs:attribute name="value" type="xs:double" use="required"/>
    <xs:attribute name="unit" type="xs:string" use="required"/> <!-- FIXME enumerate allowed units? -->
  </xs:complexType>

  <!-- different types of PQU used by PoPs... unify with previous if possible -->
  <xs:complexType name="PQU_double">
    <xs:attribute name="label" type="xs:string" use="required"/>
    <xs:attribute name="value" type="xs:double" use="required"/>
    <xs:attribute name="unit" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="PQU_integer">
    <xs:attribute name="label" type="xs:string" use="required"/>
    <xs:attribute name="value" type="xs:integer" use="required"/>
    <xs:attribute name="unit" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="PQU_fraction">
    <xs:attribute name="label" type="xs:string" use="required"/>
    <xs:attribute name="value" type="fractionAttribute" use="required"/>
    <xs:attribute name="unit" type="xs:string"/>
  </xs:complexType>

    <xs:simpleType name="fractionAttribute">
      <xs:restriction base="xs:string">
        <xs:pattern value="(-?[0-9]+)(/)?([0-9]+)?"/>
      </xs:restriction>
    </xs:simpleType>

  <xs:complexType name="PQU_string">
    <xs:attribute name="label" type="xs:NMTOKEN" use="required"/>
    <xs:attribute name="value" type="xs:string" use="required"/>
    <xs:attribute name="unit" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="axes">
    <xs:sequence>
      <xs:element name="axis" maxOccurs="unbounded">
        <xs:complexType>
          <xs:attribute name="index" use="required" type="xs:integer"/>
          <xs:attribute name="label" use="required"/>
          <xs:attribute name="unit" use="required"/>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <!-- plain text data (except for documentation) may only contain a list of doubles: -->
  <xs:simpleType name="datalist">
    <xs:list itemType="xs:double"/>
  </xs:simpleType>

  <!-- allowed interpolation types -->
  <xs:simpleType name="interpolation">
    <xs:restriction base="xs:string">
      <xs:enumeration value="flat"/>
      <xs:enumeration value="charged-particle"/>  <!-- FIXME... should this be here? -->
      <xs:enumeration value="lin-lin"/>
      <xs:enumeration value="lin-log"/>
      <xs:enumeration value="log-lin"/>
      <xs:enumeration value="log-log"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- 'values' element contains a list of floating-point numbers plus optional attributes -->
  <xs:complexType name="xData_values">
    <xs:simpleContent>
      <xs:extension base="datalist">
        <xs:attribute name="length" type="xs:integer"/>
        <xs:attribute name="sep" type="xs:string"/> <!-- FIXME limit choices? -->
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <!-- 1d data (for cross section, multiplicity, series, distribution at one incident energy, etc.) -->
  <xs:complexType name="xData_constant1d">
    <xs:sequence>
      <xs:element name="axes" type="axes"/>
    </xs:sequence>
    <xs:attribute name="label" type="xs:NCName"/>
    <xs:attribute name="constant" type="xs:double" use="required"/>
    <xs:attribute name="domainMin" type="xs:double" use="required"/>
    <xs:attribute name="domainMax" type="xs:double" use="required"/>
  </xs:complexType>

  <xs:complexType name="xData_XYs1d_primary">
    <xs:sequence>
      <xs:element name="axes" type="axes"/>
      <xs:element name="values" type="xData_values"/>
      <xs:element name="uncertainties" type="xData_uncertanties" minOccurs="0"/>
    </xs:sequence>
    <xs:attribute name="label" type="xs:NCName"/>
    <xs:attribute name="interpolation" type="interpolation"/>
  </xs:complexType>

  <xs:complexType name="xData_XYs1d_inRegions">
    <xs:sequence>
      <xs:element name="values" type="xData_values"/>
    </xs:sequence>
    <xs:attribute name="index" type="xs:integer" use="required"/>
    <xs:attribute name="interpolation" type="interpolation"/>
  </xs:complexType>

  <xs:complexType name="xData_XYs1d">
    <xs:sequence>
      <xs:element name="values" type="xData_values"/>
    </xs:sequence>
    <xs:attribute name="value" type="xs:double" use="required"/>
    <xs:attribute name="interpolation" type="interpolation"/>
  </xs:complexType>

  <!-- piecewise 1d data -->
  <xs:complexType name="xData_regions_1d_primary">
    <xs:sequence>
      <xs:element name="axes" type="axes"/>
      <xs:element name="XYs1d" type="xData_XYs1d_inRegions" minOccurs="2" maxOccurs="unbounded"/>
      <xs:element name="uncertainties" type="xData_uncertanties" minOccurs="0"/>
    </xs:sequence>
    <xs:attribute name="label" type="xs:NCName"/>
  </xs:complexType>

  <xs:complexType name="xData_regions_1d">
    <xs:sequence>
      <xs:element name="XYs1d" type="xData_XYs1d_inRegions" minOccurs="2" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="value" type="xs:double" use="required"/>
  </xs:complexType>

  <!-- series data: Legendre expansions, polynomials -->
  <xs:complexType name="xData_Legendre_1d">
    <xs:sequence>
      <xs:element name="values" type="xData_values"/>
    </xs:sequence>
    <xs:attribute name="value" type="xs:double" use="required"/>
  </xs:complexType>

  <xs:complexType name="xData_polynomial_1d_primary">
    <xs:sequence>
      <xs:element name="axes"/>
      <xs:element name="values" type="xData_values"/>
      <xs:element name="uncertainties" type="xData_uncertanties" minOccurs="0"/>
    </xs:sequence>
    <xs:attribute name="label" type="xs:NCName"/>
    <xs:attribute name="domainMin" type="xs:double" use="required"/>
    <xs:attribute name="domainMax" type="xs:double" use="required"/>
  </xs:complexType>

  <!-- 2d data: energy or angular distribution -->
  <xs:complexType name="xData_XYs2d_primary">
    <xs:sequence>
      <xs:element name="axes" type="axes"/>
      <xs:choice maxOccurs="unbounded">
        <xs:element name="Legendre" type="xData_Legendre_1d"/>
        <xs:element name="XYs1d" type="xData_XYs1d"/>
        <xs:element name="regions1d" type="xData_regions_1d"/>
      </xs:choice>
      <xs:element name="uncertainties" type="xData_uncertanties" minOccurs="0"/>
    </xs:sequence>
    <xs:attribute name="label" type="xs:string"/>
    <xs:attribute name="interpolation" type="interpolation"/>
    <xs:attribute name="interpolationQualifier" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="xData_XYs2d_inRegions">
    <xs:sequence>
      <xs:choice maxOccurs="unbounded">
        <xs:element name="Legendre" type="xData_Legendre_1d"/>
        <xs:element name="XYs1d" type="xData_XYs1d"/>
        <xs:element name="regions1d" type="xData_regions_1d"/>
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="index" type="xs:integer" use="required"/>
    <xs:attribute name="interpolation" type="interpolation"/>
    <xs:attribute name="interpolationQualifier" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="xData_XYs2d">
    <xs:sequence>
      <xs:choice maxOccurs="unbounded">
        <xs:element name="Legendre" type="xData_Legendre_1d"/>
        <xs:element name="XYs1d" type="xData_XYs1d"/>
        <xs:element name="regions1d" type="xData_regions_1d"/>
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="value" type="xs:double" use="required"/>
    <xs:attribute name="interpolation" type="interpolation"/>
    <xs:attribute name="interpolationQualifier" type="xs:string"/>
  </xs:complexType>

  <!-- 2d regions -->
  <xs:complexType name="xData_regions_2d_primary">
    <xs:sequence>
      <xs:element name="axes" type="axes"/>
      <xs:element name="XYs2d" type="xData_XYs2d_inRegions" minOccurs="2" maxOccurs="unbounded"/>
      <xs:element name="uncertainties" type="xData_uncertanties" minOccurs="0"/>
    </xs:sequence>
    <xs:attribute name="label" type="xs:NCName"/>
    <xs:attribute name="interpolationQualifier" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="xData_regions_2d">
    <xs:sequence>
      <xs:element name="XYs2d" type="xData_XYs2d_inRegions" minOccurs="2" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="value" type="xs:double" use="required"/>
  </xs:complexType>

  <!-- 3d data: double-differential distribution -->
  <xs:complexType name="xData_XYs3d_primary">
    <xs:sequence>
      <xs:element name="axes" type="axes"/>
      <xs:choice maxOccurs="unbounded">
        <xs:element name="XYs2d" type="xData_XYs2d"/>
        <xs:element name="regions2d" type="xData_regions_2d"/>
      </xs:choice>
      <xs:element name="uncertainties" type="xData_uncertanties" minOccurs="0"/>
    </xs:sequence>
    <xs:attribute name="label" type="xs:string"/>
    <xs:attribute name="interpolationQualifier" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="xData_XYs3d_inRegions">
    <xs:sequence>
      <xs:element name="axes" type="axes"/>
      <xs:choice maxOccurs="unbounded">
        <xs:element name="XYs2d" type="xData_XYs2d"/>
        <xs:element name="regions2d" type="xData_regions_2d"/>
      </xs:choice>
      <xs:element name="uncertainties" type="xData_uncertanties" minOccurs="0"/>
    </xs:sequence>
    <xs:attribute name="index" type="xs:integer"/> <!-- use="required"/> -->
  </xs:complexType>

  <!-- 3d regions -->
  <xs:complexType name="xData_regions_3d_primary">
    <xs:sequence>
      <xs:element name="axes" type="axes"/>
      <xs:element name="XYs3d" type="xData_XYs3d_inRegions" minOccurs="2" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="value" type="xs:double" use="required"/>
  </xs:complexType>

  <!-- uncertainties can appear inside many xData containers -->
  <xs:complexType name="xData_uncertanties">
    <xs:sequence>
      <xs:element name="uncertainty" type="xData_uncertainty" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="xData_uncertainty">
    <xs:choice>
      <xs:element name="XYs1d" type="xData_XYs1d_primary"/>
      <xs:element name="polynomial1d" type="xData_polynomial_1d_primary"/>
      <xs:element name="link" type="xlink"/>
    </xs:choice>
    <xs:attribute name="index" type="xs:integer"/>
    <xs:attribute name="label" type="xs:string"/>
    <xs:attribute name="type" type="xs:string"/>
    <xs:attribute name="pdf" type="xs:string"/>
    <xs:attribute name="relation" type="xs:string"/>
  </xs:complexType>

  <!-- 'table' has a list of columns + a rectangular array of data -->
  <xs:complexType name="table">
    <xs:sequence>
      <xs:element name="columnHeaders">
        <xs:complexType>
          <xs:sequence minOccurs="1">
            <xs:element name="column" type="column" maxOccurs="unbounded"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="data" type="datalist"/>
    </xs:sequence>
    <xs:attribute name="rows" type="xs:integer" use="required"/>
    <xs:attribute name="columns" type="xs:integer" use="required"/>
  </xs:complexType>

  <xs:complexType name="column">
    <xs:attribute name="index" type="xs:integer" use="required"/>
    <xs:attribute name="name" type="xs:string" use="required"/>
    <xs:attribute name="unit" type="xs:string"/>
  </xs:complexType>


</xs:schema>
