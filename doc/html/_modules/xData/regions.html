
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>xData.regions &#8212; Fudge and GNDS 6.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/classic.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    
    <link rel="shortcut icon" href="../../_static/gnd-20121206-favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Fudge and GNDS 6.1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">xData.regions</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for xData.regions</h1><div class="highlight"><pre>
<span></span><span class="c1"># &lt;&lt;BEGIN-copyright&gt;&gt;</span>
<span class="c1"># &lt;&lt;END-copyright&gt;&gt;</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module contains the all the classes for handling regions functions. A regions container is designed to handle</span>
<span class="sd">a function that has 1 or more of the following::</span>

<span class="sd">    -) an outer dimension that is multi-value at one of more domain values (e.g., :math:`f(x)` != :math:`f(x)` for one or more values of x).</span>
<span class="sd">    -) the interpolation of the outer dimension of the function is different in different regions of the domain.</span>
<span class="sd">    -) different functions are used in different regions of the domain (e.g., Legendre functions may be used for the outer domain</span>
<span class="sd">        &lt; 5 and XYs1d functions otherwise).</span>

<span class="sd">This module contains the following classes:</span>
<span class="sd">        </span>
<span class="sd">    +-------------------+-------------------------------------------------------------------------------------------------------+</span>
<span class="sd">    | Class             | Description                                                                                           |</span>
<span class="sd">    +===================+=======================================================================================================+</span>
<span class="sd">    | Regions           | This is the base class for the other regions classes.                                                 |</span>
<span class="sd">    +-------------------+-------------------------------------------------------------------------------------------------------+</span>
<span class="sd">    | Regions1d         | This is a class for a 1 dimensional regions function.                                                 |</span>
<span class="sd">    +-------------------+-------------------------------------------------------------------------------------------------------+</span>
<span class="sd">    | RegionsMultiD     | This is the base class for the 2 and dimensional regions classes.                                     |</span>
<span class="sd">    +-------------------+-------------------------------------------------------------------------------------------------------+</span>
<span class="sd">    | Regions2d         | This is a class for a 2 dimensional regions function.                                                 |</span>
<span class="sd">    +-------------------+-------------------------------------------------------------------------------------------------------+</span>
<span class="sd">    | Regions3d         | This is a class for a 3 dimensional regions function.                                                 |</span>
<span class="sd">    +-------------------+-------------------------------------------------------------------------------------------------------+</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="kn">from</span> <span class="nn">pqu</span> <span class="kn">import</span> <span class="n">PQU</span> <span class="k">as</span> <span class="n">PQUModule</span>

<span class="kn">from</span> <span class="nn">fudge</span> <span class="kn">import</span> <span class="n">GNDS_formatVersion</span> <span class="k">as</span> <span class="n">GNDS_formatVersionModule</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">enums</span> <span class="k">as</span> <span class="n">enumsModule</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">XYs1d</span> <span class="k">as</span> <span class="n">XYs1dModule</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">series1d</span> <span class="k">as</span> <span class="n">series1dModule</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">base</span> <span class="k">as</span> <span class="n">baseModule</span>

<span class="n">domainEpsilon</span> <span class="o">=</span> <span class="mf">1e-15</span>

<div class="viewcode-block" id="Regions"><a class="viewcode-back" href="../../xData/index.html#xData.regions.Regions">[docs]</a><span class="k">class</span> <span class="nc">Regions</span><span class="p">(</span> <span class="n">baseModule</span><span class="o">.</span><span class="n">XDataFunctional</span> <span class="p">)</span> <span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is the absract base class for the other regions classes.</span>

<span class="sd">    The following table list the primary members of this class:</span>

<span class="sd">    +-------------------+---------------------------------------------------------------+</span>
<span class="sd">    | Member            | Description                                                   |</span>
<span class="sd">    +===================+===============================================================+</span>
<span class="sd">    | axes              | This is the axes member.                                      |</span>
<span class="sd">    +-------------------+---------------------------------------------------------------+</span>
<span class="sd">    | outerDomainValue  | This is the domain value for the next higher dimension for    |</span>
<span class="sd">    |                   | a function that is embedded in a high dimensional functions.  |</span>
<span class="sd">    +-------------------+---------------------------------------------------------------+</span>
<span class="sd">    | index             | This is the index member use by some xData classes.           |</span>
<span class="sd">    +-------------------+---------------------------------------------------------------+</span>
<span class="sd">    | label             | This is the label member use by some xData classes.           |</span>
<span class="sd">    +-------------------+---------------------------------------------------------------+</span>
<span class="sd">    | valueType         | This describes the type of data in array (i.e., float, int).  |</span>
<span class="sd">    +-------------------+---------------------------------------------------------------+</span>
<span class="sd">    | __regions         | This is a python list of the regions that have been added.    |</span>
<span class="sd">    +-------------------+---------------------------------------------------------------+</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ancestryMembers</span> <span class="o">=</span> <span class="n">baseModule</span><span class="o">.</span><span class="n">XDataFunctional</span><span class="o">.</span><span class="n">ancestryMembers</span>                <span class="c1"># See note in multiD_XYs.py about setting ancestryMembers.</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">valueType</span> <span class="o">=</span> <span class="n">enumsModule</span><span class="o">.</span><span class="n">ValueType</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">outerDomainValue</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="kc">None</span> <span class="p">)</span> <span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param axes:                This is the axes member.</span>
<span class="sd">        :param index:               This is the index member.</span>
<span class="sd">        :param valueType:           This describes the type of data (i.e., float, int) returned by the function.</span>
<span class="sd">        :param outerDomainValue:    This is the domain value for the next higher dimension for a function that is</span>
<span class="sd">                                    embedded in a high dimensional function.</span>
<span class="sd">        :param label:               This is the label member.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">baseModule</span><span class="o">.</span><span class="n">XDataFunctional</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">valueType</span><span class="o">=</span><span class="n">valueType</span><span class="p">,</span> <span class="n">outerDomainValue</span><span class="o">=</span><span class="n">outerDomainValue</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__regions</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns the number of regions in self.</span>

<span class="sd">        :returns:       A python int.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__regions</span> <span class="p">)</span> <span class="p">)</span>

<div class="viewcode-block" id="Regions.allowedSubElements"><a class="viewcode-back" href="../../xData/index.html#xData.regions.Regions.allowedSubElements">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">allowedSubElements</span><span class="p">(</span> <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is abstract and must be over loaded by each sub-class. This method returns a list of all functions of the </span>
<span class="sd">        same dimension as the sub-class that can be added as a region of the sub-class.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">pass</span></div>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">index</span> <span class="p">)</span> <span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns the (i-1)^th region of self.</span>

<span class="sd">        :param index:   The index of the region to return.</span>

<span class="sd">        :returns:       A function that has the same dimension as *self*.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__regions</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">region</span> <span class="p">)</span> <span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method set the region at index *index* to *region*. The *region* must be an instance of </span>
<span class="sd">        base.XDataFunctional with the same dimension as self.</span>
<span class="sd">        The region must fix between any abutting regions. That is, if *index* is greater than 0, the domainMin of </span>
<span class="sd">        *region* must be equal to the domainMax of the prior region. And, if *index* is less than the number of regions</span>
<span class="sd">        in *self* minus 1, then domainMax of *region* must be equal to the domainMin of the next region.</span>

<span class="sd">        :param index:       The index where *region* is inserted.</span>
<span class="sd">        :param region:      This must be an instance of a class in :py:func:`allowedSubElements`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

<span class="c1"># BRB need to check axes.</span>
        <span class="k">if</span><span class="p">(</span> <span class="ow">not</span><span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">region</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">allowedSubElements</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span> <span class="s1">&#39;Invalid class for insertion: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">region</span><span class="o">.</span><span class="vm">__class__</span> <span class="p">)</span>

        <span class="n">n1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">:</span> <span class="n">index</span> <span class="o">+=</span> <span class="n">n1</span>
        <span class="k">if</span><span class="p">(</span> <span class="ow">not</span><span class="p">(</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">index</span> <span class="o">&lt;=</span> <span class="n">n1</span> <span class="p">)</span> <span class="p">)</span> <span class="p">:</span> <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span> <span class="s1">&#39;Index = </span><span class="si">%s</span><span class="s1"> not in range 0 &lt;= index &lt;= </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span> <span class="n">index</span><span class="p">,</span> <span class="n">n1</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">:</span>
            <span class="k">if</span><span class="p">(</span> <span class="ow">not</span><span class="p">(</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__regions</span><span class="p">[</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">domainMax</span><span class="p">,</span> <span class="n">region</span><span class="o">.</span><span class="n">domainMin</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s2">&quot;Prior region&#39;s domainMax </span><span class="si">%s</span><span class="s2"> != new region&#39;s domainMin = </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__regions</span><span class="p">[</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">domainMax</span><span class="p">,</span> <span class="n">region</span><span class="o">.</span><span class="n">domainMin</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="n">n1</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="ow">and</span> <span class="p">(</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="p">(</span> <span class="n">n1</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">:</span>
            <span class="k">if</span><span class="p">(</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__regions</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">domainMin</span><span class="p">,</span> <span class="n">region</span><span class="o">.</span><span class="n">domainMax</span> <span class="p">)</span> <span class="p">)</span> <span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>  <span class="s2">&quot;Next region&#39;s domainMin </span><span class="si">%s</span><span class="s2"> != new region&#39;s domainMax = </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__regions</span><span class="p">[</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">domainMin</span><span class="p">,</span> <span class="n">region</span><span class="o">.</span><span class="n">domainMax</span> <span class="p">)</span> <span class="p">)</span>

        <span class="k">if</span><span class="p">(</span> <span class="n">index</span> <span class="o">==</span> <span class="n">n1</span> <span class="p">)</span> <span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__regions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">region</span> <span class="p">)</span>             <span class="c1"># Append to the end.</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__regions</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">region</span>              <span class="c1"># Replaces the current contents of index with region.</span>

        <span class="n">region</span><span class="o">.</span><span class="n">setAncestor</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span>
        <span class="n">region</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">self2</span><span class="p">,</span> <span class="n">other2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copyToCommonRegions</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i1</span><span class="p">,</span> <span class="n">region</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">self2</span><span class="p">):</span>
            <span class="n">self2</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="o">=</span> <span class="n">region</span> <span class="o">+</span> <span class="n">other2</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">self2</span>

    <span class="fm">__radd__</span> <span class="o">=</span> <span class="fm">__add__</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">)</span> <span class="p">:</span>

        <span class="n">self2</span><span class="p">,</span> <span class="n">other2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copyToCommonRegions</span><span class="p">(</span> <span class="n">other</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">i1</span><span class="p">,</span> <span class="n">region</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="n">self2</span> <span class="p">)</span> <span class="p">:</span> <span class="n">self2</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="o">=</span> <span class="n">region</span> <span class="o">-</span> <span class="n">other2</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">self2</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">domainMin</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns the minimum domain value for *self*.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__regions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">domainMin</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">domainMax</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns the maximum domain value for *self*.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__regions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">domainMax</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">domainGrid</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns all domain values for *self* as a python list.</span>

<span class="sd">        :returns:           A python list.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">grid</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span> <span class="n">grid</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="n">region</span><span class="o">.</span><span class="n">domainGrid</span> <span class="p">)</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span> <span class="n">grid</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">domainUnit</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns the domain unit for *self*.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAxisUnitSafely</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="p">)</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rangeMin</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="p">:</span>

        <span class="k">return</span><span class="p">(</span> <span class="nb">min</span><span class="p">(</span> <span class="p">[</span> <span class="n">region</span><span class="o">.</span><span class="n">rangeMin</span> <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="bp">self</span> <span class="p">]</span> <span class="p">)</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rangeMax</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="p">:</span>

        <span class="k">return</span><span class="p">(</span> <span class="nb">max</span><span class="p">(</span> <span class="p">[</span> <span class="n">region</span><span class="o">.</span><span class="n">rangeMax</span> <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="bp">self</span> <span class="p">]</span> <span class="p">)</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rangeUnit</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="p">:</span>

        <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAxisUnitSafely</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">regions</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns self&#39;s __region.&quot;&quot;&quot;</span>

        <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__regions</span> <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">functionNdsName</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the node name for the child &quot;function#ds&quot;.&quot;&quot;&quot;</span>

        <span class="k">return</span><span class="p">(</span> <span class="s2">&quot;function</span><span class="si">%d</span><span class="s2">ds&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="p">)</span>

<div class="viewcode-block" id="Regions.append"><a class="viewcode-back" href="../../xData/index.html#xData.regions.Regions.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curve</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Appends *curve* to the end of *self*. If *curve* is a **Regions** instance, then **append** is call for </span>
<span class="sd">        each region in curve.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">curve</span><span class="p">,</span> <span class="n">Regions</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">curve</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">region</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">curve</span>
            <span class="n">curve</span><span class="o">.</span><span class="n">keyName</span> <span class="o">=</span> <span class="s1">&#39;index&#39;</span></div>

<div class="viewcode-block" id="Regions.prepend"><a class="viewcode-back" href="../../xData/index.html#xData.regions.Regions.prepend">[docs]</a>    <span class="k">def</span> <span class="nf">prepend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curve</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepends *curve* to the beginning of *self*. If *curve* is a **Regions** instance, then **append** is call </span>
<span class="sd">        for each region in curve.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">curve</span><span class="p">,</span> <span class="n">Regions</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">curve</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">prepend</span><span class="p">(</span><span class="n">curve</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">curve</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">allowedSubElements</span><span class="p">()):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Invalid class for insertion: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">region</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">curve</span><span class="o">.</span><span class="n">domainMax</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">domainMin</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;Prepending region&#39;s domainMax </span><span class="si">%s</span><span class="s1"> != first region&#39;s domainMin = </span><span class="si">%s</span><span class="s1">&#39;&#39;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">region</span><span class="o">.</span><span class="n">domainMax</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">domainMin</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">__regions</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">curve</span><span class="p">)</span>
            <span class="n">curve</span><span class="o">.</span><span class="n">setAncestor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">curve</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="Regions.convertUnits"><a class="viewcode-back" href="../../xData/index.html#xData.regions.Regions.convertUnits">[docs]</a>    <span class="k">def</span> <span class="nf">convertUnits</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">unitMap</span> <span class="p">)</span> <span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts all data in *self* per *unitMap*.</span>

<span class="sd">        :param unitMap:     A dictionary in which each key is a unit that will be replaced by its value which must be an equivalent unit.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">factors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">convertUnits</span><span class="p">(</span> <span class="n">unitMap</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="bp">self</span> <span class="p">:</span> <span class="n">region</span><span class="o">.</span><span class="n">convertUnits</span><span class="p">(</span> <span class="n">unitMap</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixValuePerUnitChange</span><span class="p">(</span> <span class="n">factors</span> <span class="p">)</span></div>

<div class="viewcode-block" id="Regions.copy"><a class="viewcode-back" href="../../xData/index.html#xData.regions.Regions.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="p">:</span>
        <span class="c1"># FIXME some of this should probably move to &#39;returnAsClass&#39; method</span>

        <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">axes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="p">)</span> <span class="p">:</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">axes</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span> <span class="p">)</span>
        <span class="n">newRegions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">axes</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">valueType</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">valueType</span><span class="p">,</span> <span class="n">outerDomainValue</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outerDomainValue</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span> <span class="p">:</span> <span class="n">newRegions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">child</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">newRegions</span> <span class="p">)</span></div>

<div class="viewcode-block" id="Regions.hasData"><a class="viewcode-back" href="../../xData/index.html#xData.regions.Regions.hasData">[docs]</a>    <span class="k">def</span> <span class="nf">hasData</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if one of self&#39;s regions hasData returns True and False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">region</span><span class="o">.</span><span class="n">hasData</span><span class="p">():</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Regions.splitInTwo"><a class="viewcode-back" href="../../xData/index.html#xData.regions.Regions.splitInTwo">[docs]</a>    <span class="k">def</span> <span class="nf">splitInTwo</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">domainValue</span><span class="p">,</span> <span class="n">epsilon</span> <span class="o">=</span> <span class="n">domainEpsilon</span> <span class="p">)</span> <span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Splits the region containing domainValue into two regions.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">i1</span><span class="p">,</span> <span class="n">region</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="p">:</span>
            <span class="n">domainMin</span><span class="p">,</span> <span class="n">domainMax</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">domainMin</span><span class="p">,</span> <span class="n">region</span><span class="o">.</span><span class="n">domainMax</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">domainMin</span> <span class="o">&lt;</span> <span class="n">domainValue</span> <span class="o">&lt;</span> <span class="n">domainMax</span> <span class="p">)</span> <span class="p">:</span>
                <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">splitInTwo</span><span class="p">(</span> <span class="n">domainValue</span><span class="p">,</span> <span class="n">epsilon</span> <span class="o">=</span> <span class="n">domainEpsilon</span> <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__regions</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="o">=</span> <span class="n">r2</span>
                <span class="n">r1</span><span class="o">.</span><span class="n">setAncestor</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__regions</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">i1</span><span class="p">,</span> <span class="n">r1</span> <span class="p">)</span>
                <span class="n">r2</span><span class="o">.</span><span class="n">setAncestor</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span>
                <span class="k">return</span></div>

<div class="viewcode-block" id="Regions.domainUnitConversionFactor"><a class="viewcode-back" href="../../xData/index.html#xData.regions.Regions.domainUnitConversionFactor">[docs]</a>    <span class="k">def</span> <span class="nf">domainUnitConversionFactor</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">unitTo</span> <span class="p">)</span> <span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns the factor needed to convert self&#39;s domain to unit *unitTo*.</span>

<span class="sd">        :param unitTo:      The unit for converting self&#39;s domain.</span>

<span class="sd">        :returns:           A float.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span><span class="p">(</span> <span class="n">unitTo</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">)</span> <span class="p">:</span> <span class="k">return</span><span class="p">(</span> <span class="mf">1.</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">PQUModule</span><span class="o">.</span><span class="n">PQU</span><span class="p">(</span> <span class="s1">&#39;1 &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">domainUnit</span> <span class="p">)</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span> <span class="n">unitTo</span> <span class="p">)</span> <span class="p">)</span></div>

<div class="viewcode-block" id="Regions.domainSlice"><a class="viewcode-back" href="../../xData/index.html#xData.regions.Regions.domainSlice">[docs]</a>    <span class="k">def</span> <span class="nf">domainSlice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">domainMin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">domainMax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dullEps</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new instance with self sliced between ``domainMin`` and ``domainMax``.</span>
<span class="sd">        Result may be a regions container, or it may be XYs, multiD_XYs, etc.</span>

<span class="sd">        :param domainMin:   [optional] the lower x-value of the slice, default is domain minimum of self,</span>
<span class="sd">        :param domainMax:   [optional] the upper x-value of the slice, default is domain maximum of self,</span>
<span class="sd">        :param fill:        [optional] if True, points are added at domainMin and domainMax if they are not in self,</span>
<span class="sd">                                       else only existing points in the range [domainMin, domainMax] are included.</span>
<span class="sd">        :param dullEps:     [optional] (Currently not implemented) the lower and upper points are dulled, default is 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span><span class="p">(</span> <span class="n">domainMin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">)</span> <span class="p">:</span> <span class="n">domainMin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domainMin</span>
        <span class="n">domainMin</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="n">domainMin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">domainMin</span> <span class="p">)</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">domainMax</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">)</span> <span class="p">:</span> <span class="n">domainMax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domainMax</span>
        <span class="n">domainMax</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span> <span class="n">domainMax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">domainMax</span> <span class="p">)</span>

        <span class="k">for</span> <span class="n">ridx1</span><span class="p">,</span> <span class="n">region</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="p">:</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">region</span><span class="o">.</span><span class="n">domainMax</span>  <span class="o">&gt;</span> <span class="n">domainMin</span> <span class="p">)</span> <span class="p">:</span> <span class="k">break</span>
        <span class="k">for</span> <span class="n">ridx2</span><span class="p">,</span> <span class="n">region</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="p">:</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">region</span><span class="o">.</span><span class="n">domainMax</span> <span class="o">&gt;=</span> <span class="n">domainMax</span> <span class="p">)</span> <span class="p">:</span> <span class="k">break</span>

        <span class="k">if</span> <span class="n">ridx1</span> <span class="o">==</span> <span class="n">ridx2</span><span class="p">:</span>  <span class="c1"># only one region left after slicing, return as XYs1d or multiD_XYs</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">ridx1</span><span class="p">]</span><span class="o">.</span><span class="n">domainSlice</span><span class="p">(</span> <span class="n">domainMin</span><span class="o">=</span><span class="n">domainMin</span><span class="p">,</span> <span class="n">domainMax</span><span class="o">=</span><span class="n">domainMax</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="n">fill</span><span class="p">,</span> <span class="n">dullEps</span><span class="o">=</span><span class="n">dullEps</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newRegions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span> <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">valueType</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">valueType</span><span class="p">,</span> <span class="n">outerDomainValue</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outerDomainValue</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="p">)</span>
            <span class="n">newRegions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="bp">self</span><span class="p">[</span><span class="n">ridx1</span><span class="p">]</span><span class="o">.</span><span class="n">domainSlice</span><span class="p">(</span> <span class="n">domainMin</span> <span class="o">=</span> <span class="n">domainMin</span><span class="p">,</span> <span class="n">domainMax</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">ridx1</span><span class="p">]</span><span class="o">.</span><span class="n">domainMax</span><span class="p">,</span> <span class="n">fill</span> <span class="o">=</span> <span class="n">fill</span><span class="p">,</span> <span class="n">dullEps</span> <span class="o">=</span> <span class="n">dullEps</span> <span class="p">)</span> <span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ridx1</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">ridx2</span><span class="p">):</span>
                <span class="n">newRegions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="n">newRegions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="bp">self</span><span class="p">[</span><span class="n">ridx2</span><span class="p">]</span><span class="o">.</span><span class="n">domainSlice</span><span class="p">(</span>
                <span class="n">domainMin</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">ridx2</span><span class="p">]</span><span class="o">.</span><span class="n">domainMin</span><span class="p">,</span> <span class="n">domainMax</span><span class="o">=</span><span class="n">domainMax</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="n">fill</span><span class="p">,</span> <span class="n">dullEps</span><span class="o">=</span><span class="n">dullEps</span> <span class="p">)</span> <span class="p">)</span>

            <span class="k">return</span> <span class="n">newRegions</span></div>

<div class="viewcode-block" id="Regions.fixDomains"><a class="viewcode-back" href="../../xData/index.html#xData.regions.Regions.fixDomains">[docs]</a>    <span class="k">def</span> <span class="nf">fixDomains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">domainMin</span><span class="p">,</span> <span class="n">domainMax</span><span class="p">,</span> <span class="n">fixToDomain</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method sets the domain minimum and maximum per the arguments.</span>

<span class="sd">        :param domainMin:       The lower limit of the domain.</span>
<span class="sd">        :param domainMax:       The upper limit of the domain.</span>
<span class="sd">        :param fixToDomain:     An instance of :py:class:`enumsModule.FixDomain` that specifies which limits are to be fixed.</span>

<span class="sd">        :returns:               This method returns 0 if no domain limit was moved and 1 if at least one was moved.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">OldDomainMin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domainMin</span>
        <span class="n">OldDomainMax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domainMax</span>

        <span class="k">if</span> <span class="n">fixToDomain</span> <span class="o">==</span> <span class="n">enumsModule</span><span class="o">.</span><span class="n">FixDomain</span><span class="o">.</span><span class="n">lower</span><span class="p">:</span>
            <span class="n">regions1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domainSlice</span><span class="p">(</span><span class="n">domainMin</span> <span class="o">=</span> <span class="n">domainMin</span><span class="p">,</span> <span class="n">fill</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">fixToDomain</span> <span class="o">==</span> <span class="n">enumsModule</span><span class="o">.</span><span class="n">FixDomain</span><span class="o">.</span><span class="n">upper</span><span class="p">:</span>
            <span class="n">regions1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domainSlice</span><span class="p">(</span><span class="n">domainMax</span> <span class="o">=</span> <span class="n">domainMax</span><span class="p">,</span> <span class="n">fill</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">regions1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domainSlice</span><span class="p">(</span><span class="n">domainMin</span> <span class="o">=</span> <span class="n">domainMin</span><span class="p">,</span> <span class="n">domainMax</span> <span class="o">=</span> <span class="n">domainMax</span><span class="p">,</span> <span class="n">fill</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__regions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">regions1</span><span class="p">,</span> <span class="n">Regions</span><span class="p">):</span>
           <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">region</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">regions1</span><span class="p">):</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">region</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">regions1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="mi">1</span>             <span class="c1"># Caller beware.</span>
            <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">regions1</span>

        <span class="k">if</span> <span class="n">OldDomainMin</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">domainMin</span> <span class="ow">and</span> <span class="n">OldDomainMax</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">domainMax</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="Regions.rangeUnitConversionFactor"><a class="viewcode-back" href="../../xData/index.html#xData.regions.Regions.rangeUnitConversionFactor">[docs]</a>    <span class="k">def</span> <span class="nf">rangeUnitConversionFactor</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">unitTo</span> <span class="p">)</span> <span class="p">:</span>

        <span class="k">if</span><span class="p">(</span> <span class="n">unitTo</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">)</span> <span class="p">:</span> <span class="k">return</span><span class="p">(</span> <span class="mf">1.</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">PQUModule</span><span class="o">.</span><span class="n">PQU</span><span class="p">(</span> <span class="s1">&#39;1 &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">rangeUnit</span> <span class="p">)</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span> <span class="n">unitTo</span> <span class="p">)</span> <span class="p">)</span></div>

<div class="viewcode-block" id="Regions.evaluate"><a class="viewcode-back" href="../../xData/index.html#xData.regions.Regions.evaluate">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">domainValue</span> <span class="p">)</span> <span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate function at requested domain point. If at discontinuity, return upper region&#39;s value.</span>

<span class="sd">        :param domainValue:</span>
<span class="sd">        :return interpolated point at domainValue:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__regions</span> <span class="p">:</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">domainValue</span> <span class="o">&lt;</span> <span class="n">region</span><span class="o">.</span><span class="n">domainMax</span> <span class="p">)</span> <span class="p">:</span> <span class="k">return</span><span class="p">(</span> <span class="n">region</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span> <span class="n">domainValue</span> <span class="p">)</span> <span class="p">)</span>

        <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__regions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span> <span class="n">domainValue</span> <span class="p">)</span> <span class="p">)</span>  <span class="c1"># Domain value is above the last region. Let the last region determine what to do.</span></div>

<div class="viewcode-block" id="Regions.findInstancesOfClassInChildren"><a class="viewcode-back" href="../../xData/index.html#xData.regions.Regions.findInstancesOfClassInChildren">[docs]</a>    <span class="k">def</span> <span class="nf">findInstancesOfClassInChildren</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="bp">cls</span><span class="p">,</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">9999</span> <span class="p">)</span> <span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds all instances of class *cls* in self&#39;s children, grand-children, etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">foundInstances</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">level</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">level</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">:</span> <span class="k">return</span><span class="p">(</span> <span class="n">foundInstances</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="bp">self</span> <span class="p">:</span>
            <span class="k">if</span><span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">region</span><span class="p">,</span> <span class="bp">cls</span> <span class="p">)</span> <span class="p">)</span> <span class="p">:</span> <span class="n">foundInstances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">region</span> <span class="p">)</span>
            <span class="n">foundInstances</span> <span class="o">+=</span> <span class="n">region</span><span class="o">.</span><span class="n">findInstancesOfClassInChildren</span><span class="p">(</span> <span class="bp">cls</span><span class="p">,</span> <span class="n">level</span> <span class="o">=</span> <span class="n">level</span> <span class="p">)</span>

        <span class="k">return</span><span class="p">(</span> <span class="n">foundInstances</span> <span class="p">)</span></div>

<div class="viewcode-block" id="Regions.integrate"><a class="viewcode-back" href="../../xData/index.html#xData.regions.Regions.integrate">[docs]</a>    <span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">limits</span> <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Integrate a piecewise function. Supports limits for each axis.</span>
<span class="sd">        Example::</span>

<span class="sd">            regions.integrate( energy_in = (&#39;1e-5 eV&#39;, &#39;10 eV&#39;), energy_out = (&#39;1 keV&#39;, &#39;10 keV&#39;) )</span>

<span class="sd">        :param limits: dictionary containing limits for each independent axis (keyed by axis label or index).</span>
<span class="sd">        If an independent axis is missing from the dictionary, integrate over the entire domain of that axis.</span>

<span class="sd">        :return: float</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">multiD_XYs</span> <span class="k">as</span> <span class="n">multiD_XYsModule</span>

        <span class="n">integral</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span><span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">region</span><span class="p">,</span> <span class="p">(</span> <span class="n">XYs1dModule</span><span class="o">.</span><span class="n">XYs1d</span><span class="p">,</span> <span class="n">series1dModule</span><span class="o">.</span><span class="n">Series1d</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">:</span>
                <span class="n">Min</span><span class="p">,</span> <span class="n">Max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">label</span> <span class="ow">in</span> <span class="n">limits</span><span class="p">:</span>
                    <span class="n">Min</span><span class="p">,</span> <span class="n">Max</span> <span class="o">=</span> <span class="n">limits</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">label</span> <span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span> <span class="ow">in</span> <span class="n">limits</span><span class="p">:</span>
                    <span class="n">Min</span><span class="p">,</span> <span class="n">Max</span> <span class="o">=</span> <span class="n">limits</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span> <span class="p">)</span>

                <span class="n">integral</span> <span class="o">+=</span> <span class="n">region</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span> <span class="n">domainMin</span> <span class="o">=</span> <span class="n">Min</span><span class="p">,</span> <span class="n">domainMax</span> <span class="o">=</span> <span class="n">Max</span> <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">region</span><span class="p">,</span> <span class="n">multiD_XYs1dModule</span><span class="o">.</span><span class="n">XYsnd</span> <span class="p">):</span>
                <span class="n">integral</span> <span class="o">+=</span> <span class="n">region</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span> <span class="o">**</span><span class="n">limits</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span> <span class="s2">&quot;Unsupported class for integration: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span> <span class="n">region</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">integral</span> <span class="p">)</span></div>

<div class="viewcode-block" id="Regions.toString"><a class="viewcode-back" href="../../xData/index.html#xData.regions.Regions.toString">[docs]</a>    <span class="k">def</span> <span class="nf">toString</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="p">:</span>

        <span class="n">s1</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">i1</span><span class="p">,</span> <span class="n">region</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="p">:</span> <span class="n">s1</span> <span class="o">+=</span> <span class="s1">&#39;# region </span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i1</span> <span class="o">+</span> <span class="n">region</span><span class="o">.</span><span class="n">toString</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">s1</span> <span class="p">)</span></div>

<div class="viewcode-block" id="Regions.toXML_strList"><a class="viewcode-back" href="../../xData/index.html#xData.regions.Regions.toXML_strList">[docs]</a>    <span class="k">def</span> <span class="nf">toXML_strList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indent</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of str instances representing the XML lines of *self*.</span>

<span class="sd">        :param indent:          The minimum amount of indentation.</span>
<span class="sd">        :param kwargs:          A dictionary of extra arguments that controls how *self* is converted to a list of XML strings.</span>

<span class="sd">        :return:                List of str instances representing the XML lines of self.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">formatVersion</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;formatVersion&#39;</span><span class="p">,</span> <span class="n">GNDS_formatVersionModule</span><span class="o">.</span><span class="n">default</span><span class="p">)</span>

        <span class="n">indent2</span> <span class="o">=</span> <span class="n">indent</span> <span class="o">+</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;incrementalIndent&#39;</span><span class="p">,</span> <span class="s1">&#39;  &#39;</span><span class="p">)</span>
        <span class="n">indent3</span> <span class="o">=</span> <span class="n">indent2</span> <span class="o">+</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;incrementalIndent&#39;</span><span class="p">,</span> <span class="s1">&#39;  &#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">formatVersion</span> <span class="o">==</span> <span class="n">GNDS_formatVersionModule</span><span class="o">.</span><span class="n">version_1_10</span><span class="p">:</span> <span class="n">indent3</span> <span class="o">=</span> <span class="n">indent2</span>

        <span class="n">attributeStr</span> <span class="o">=</span> <span class="n">baseModule</span><span class="o">.</span><span class="n">XDataFunctional</span><span class="o">.</span><span class="n">attributesToXMLAttributeStr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">XML_strList</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&lt;</span><span class="si">%s%s</span><span class="s1">&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span> <span class="n">indent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">moniker</span><span class="p">,</span> <span class="n">attributeStr</span> <span class="p">)</span> <span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isPrimaryXData</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">XML_strList</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">toXML_strList</span><span class="p">(</span><span class="n">indent2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">formatVersion</span> <span class="o">!=</span> <span class="n">GNDS_formatVersionModule</span><span class="o">.</span><span class="n">version_1_10</span><span class="p">:</span> <span class="n">XML_strList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&lt;</span><span class="si">%s</span><span class="s1">&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span> <span class="n">indent2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">functionNdsName</span> <span class="p">))</span>
        <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__regions</span><span class="p">:</span> <span class="n">XML_strList</span> <span class="o">+=</span> <span class="n">region</span><span class="o">.</span><span class="n">toXML_strList</span><span class="p">(</span><span class="n">indent3</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">formatVersion</span> <span class="o">!=</span> <span class="n">GNDS_formatVersionModule</span><span class="o">.</span><span class="n">version_1_10</span><span class="p">:</span> <span class="n">XML_strList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="s2">&quot;&lt;/</span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">functionNdsName</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">uncertainty</span><span class="p">:</span> <span class="n">XML_strList</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uncertainty</span><span class="o">.</span><span class="n">toXML_strList</span><span class="p">(</span><span class="n">indent2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">XML_strList</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="s1">&#39;&lt;/</span><span class="si">%s</span><span class="s1">&gt;&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">moniker</span>

        <span class="k">return</span> <span class="n">XML_strList</span></div>

<div class="viewcode-block" id="Regions.parseNodeUsingClass"><a class="viewcode-back" href="../../xData/index.html#xData.regions.Regions.parseNodeUsingClass">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parseNodeUsingClass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">xPath</span><span class="p">,</span> <span class="n">linkData</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parse *node* into an instance of *cls*.</span>

<span class="sd">        :param cls:         Form class to return.</span>
<span class="sd">        :param node:        Node to parse.</span>
<span class="sd">        :param xPath:       List containing xPath to current node, useful mostly for debugging.</span>
<span class="sd">        :param linkData:    dict that collects unresolved links.</span>
<span class="sd">        :param kwargs:      A dictionary of extra arguments that controls how *self* is converted to a list of XML strings.</span>

<span class="sd">        :returns:           An instance of *cls* representing *node*.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">attributes</span><span class="p">,</span> <span class="n">extraAttributes</span> <span class="o">=</span> <span class="n">baseModule</span><span class="o">.</span><span class="n">XDataFunctional</span><span class="o">.</span><span class="n">parseBareNodeCommonAttributes</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">xPath</span><span class="p">)</span>     <span class="c1"># parseBareNodeCommonAttributes adds to xPath.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">extraAttributes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Invalid attributes: </span><span class="si">%s</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="p">(</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">extraAttributes</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="p">))</span>

        <span class="n">regions1</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">attributes</span><span class="p">)</span>

        <span class="n">extraNodes</span> <span class="o">=</span> <span class="n">baseModule</span><span class="o">.</span><span class="n">XDataFunctional</span><span class="o">.</span><span class="n">parseNodeStandardChildren</span><span class="p">(</span><span class="n">regions1</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">xPath</span><span class="p">,</span> <span class="n">linkData</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">extraNodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>                                                     <span class="c1"># The next few line support GNDS 1.10 and 2.0.</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">extraNode</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">extraNodes</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">extraNode</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="n">regions1</span><span class="o">.</span><span class="n">functionNdsName</span><span class="p">:</span> <span class="k">break</span>
            <span class="k">if</span> <span class="n">extraNode</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="n">regions1</span><span class="o">.</span><span class="n">functionNdsName</span><span class="p">:</span> <span class="n">extraNodes</span> <span class="o">=</span> <span class="n">extraNodes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;axes&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;axes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">regions1</span><span class="o">.</span><span class="n">axes</span>
        <span class="n">allowedSubElements</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">allowedSubElements</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">extraNodes</span><span class="p">:</span>
            <span class="n">childClass</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">allowedChildClass</span> <span class="ow">in</span> <span class="n">allowedSubElements</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">allowedChildClass</span><span class="o">.</span><span class="n">moniker</span> <span class="o">==</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span><span class="p">:</span>
                    <span class="n">childClass</span> <span class="o">=</span> <span class="n">allowedChildClass</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">childClass</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Invalid child &quot;</span><span class="si">%s</span><span class="s1">&quot; for node &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">moniker</span><span class="p">))</span>
            <span class="n">xdata</span> <span class="o">=</span> <span class="n">childClass</span><span class="o">.</span><span class="n">parseNodeUsingClass</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">xPath</span><span class="p">,</span> <span class="n">linkData</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">regions1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xdata</span><span class="p">)</span>

        <span class="n">xPath</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">regions1</span></div></div>

<div class="viewcode-block" id="Regions1d"><a class="viewcode-back" href="../../xData/index.html#xData.regions.Regions1d">[docs]</a><span class="k">class</span> <span class="nc">Regions1d</span><span class="p">(</span> <span class="n">Regions</span> <span class="p">)</span> <span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class supports storing a 1d function as a list of abutting 1d functions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">moniker</span> <span class="o">=</span> <span class="s1">&#39;regions1d&#39;</span>
    <span class="n">dimension</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns self with all regions negated.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">regions1d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">regions1d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">region</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">regions1d</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">)</span> <span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method multiplies *self* by *other* and returns the product. Here, *other* can be an int for a float.</span>

<span class="sd">        :param other:       Instance to multiply *self* by.</span>

<span class="sd">        :return:            A :py:class:`Regions1d` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">_self</span><span class="p">,</span> <span class="n">_other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copyToCommonRegions</span><span class="p">(</span> <span class="n">other</span> <span class="p">)</span>
        <span class="n">_regions1d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">region1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="n">_self</span> <span class="p">)</span> <span class="p">:</span>
            <span class="n">region2</span> <span class="o">=</span> <span class="n">_other</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">region</span> <span class="o">=</span> <span class="n">region1</span> <span class="o">*</span> <span class="n">region2</span>
            <span class="n">_regions1d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">region</span> <span class="p">)</span>

        <span class="k">return</span><span class="p">(</span> <span class="n">_regions1d</span> <span class="p">)</span>

    <span class="fm">__rmul__</span> <span class="o">=</span> <span class="fm">__mul__</span>

<div class="viewcode-block" id="Regions1d.copyToCommonRegions"><a class="viewcode-back" href="../../xData/index.html#xData.regions.Regions1d.copyToCommonRegions">[docs]</a>    <span class="k">def</span> <span class="nf">copyToCommonRegions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">epsilon</span> <span class="o">=</span> <span class="n">domainEpsilon</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns two :py:class:`Regions1d` instances that yield the same function as *self* and *other*,</span>
<span class="sd">        but with *self* and *other* broken up so that they have the same number of regions and the regions align.</span>
<span class="sd">        Currenlty, *other* can only be a :py:class:`Regions1d` or :py:class:`XYs1dModule.XYs1d` instance.</span>

<span class="sd">        :param other:       A :py:class:`Regions1d` or :py:class:`XYs1dModule.XYs1d` instance.</span>
<span class="sd">        :param epsilon:     Two boundaries are considered to be the same if they are relativley within this value.</span>

<span class="sd">        :returns:           Two :py:class:`Regions1d` instances.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">self2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="n">other2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">toLinearXYsClass</span><span class="p">()(</span><span class="n">data</span><span class="o">=</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">domainMin</span><span class="p">,</span> <span class="n">other</span><span class="p">],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">domainMax</span><span class="p">,</span> <span class="n">other</span><span class="p">]])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;self.dimension = </span><span class="si">%s</span><span class="s1"> not equal to other.dimension = </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimension</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">dimension</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">other2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">self2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
               <span class="k">return</span> <span class="n">self2</span><span class="p">,</span> <span class="n">other2</span>

            <span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="n">other2</span><span class="o">.</span><span class="n">domainMin</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="n">other2</span><span class="o">.</span><span class="n">domainMax</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]]</span>
            <span class="n">xys1d</span> <span class="o">=</span> <span class="n">self2</span><span class="o">.</span><span class="n">toLinearXYsClass</span><span class="p">()(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">self2</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">self2</span><span class="p">,</span> <span class="n">Regions1d</span><span class="p">):</span>
                <span class="n">self2</span> <span class="o">=</span> <span class="n">Regions1d</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">self2</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
            <span class="n">self2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xys1d</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">other2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="n">self2</span><span class="o">.</span><span class="n">domainMin</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="n">self2</span><span class="o">.</span><span class="n">domainMax</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]]</span>
            <span class="n">xys1d</span> <span class="o">=</span> <span class="n">other2</span><span class="o">.</span><span class="n">toLinearXYsClass</span><span class="p">()(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">other2</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other2</span><span class="p">,</span> <span class="n">Regions1d</span><span class="p">):</span>
                <span class="n">other2</span> <span class="o">=</span> <span class="n">Regions1d</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">other2</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
            <span class="n">other2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xys1d</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other2</span><span class="p">,</span> <span class="n">XYs1dModule</span><span class="o">.</span><span class="n">XYs1d</span><span class="p">):</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">()</span>
            <span class="n">temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other2</span><span class="p">)</span>
            <span class="n">other2</span> <span class="o">=</span> <span class="n">temp</span> 
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other2</span><span class="p">,</span> <span class="n">Regions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;object of instance &quot;</span><span class="si">%s</span><span class="s1">&quot; not implemented&#39;</span> <span class="o">%</span> <span class="n">other2</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>

        <span class="k">if</span>   <span class="n">self2</span><span class="o">.</span><span class="n">domainMin</span> <span class="o">&lt;</span> <span class="n">other2</span><span class="o">.</span><span class="n">domainMin</span><span class="p">:</span>
            <span class="n">region1</span> <span class="o">=</span> <span class="n">other2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">region1</span><span class="o">.</span><span class="n">setData</span><span class="p">([[</span><span class="n">self2</span><span class="o">.</span><span class="n">domainMin</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">other2</span><span class="o">.</span><span class="n">domainMin</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
            <span class="n">other2</span><span class="o">.</span><span class="n">prepend</span><span class="p">(</span><span class="n">region1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">self2</span><span class="o">.</span><span class="n">domainMin</span> <span class="o">&gt;</span> <span class="n">other2</span><span class="o">.</span><span class="n">domainMin</span><span class="p">:</span>
            <span class="n">region1</span> <span class="o">=</span> <span class="n">self2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">region1</span><span class="o">.</span><span class="n">setData</span><span class="p">([[</span><span class="n">other2</span><span class="o">.</span><span class="n">domainMin</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">self2</span><span class="o">.</span><span class="n">domainMin</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
            <span class="n">self2</span><span class="o">.</span><span class="n">prepend</span><span class="p">(</span><span class="n">region1</span><span class="p">)</span>

        <span class="k">if</span>   <span class="n">self2</span><span class="o">.</span><span class="n">domainMax</span> <span class="o">&gt;</span> <span class="n">other2</span><span class="o">.</span><span class="n">domainMax</span><span class="p">:</span>
            <span class="n">region1</span> <span class="o">=</span> <span class="n">other2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">region1</span><span class="o">.</span><span class="n">setData</span><span class="p">([[</span><span class="n">other2</span><span class="o">.</span><span class="n">domainMax</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">self2</span><span class="o">.</span><span class="n">domainMax</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
            <span class="n">other2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">region1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">self2</span><span class="o">.</span><span class="n">domainMax</span> <span class="o">&lt;</span> <span class="n">other2</span><span class="o">.</span><span class="n">domainMax</span><span class="p">:</span>
            <span class="n">region1</span> <span class="o">=</span> <span class="n">self2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">region1</span><span class="o">.</span><span class="n">setData</span><span class="p">([[</span><span class="n">self2</span><span class="o">.</span><span class="n">domainMax</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">other2</span><span class="o">.</span><span class="n">domainMax</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
            <span class="n">self2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">region1</span><span class="p">)</span>

        <span class="n">boundaries</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">self2</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">boundaries</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">region</span><span class="o">.</span><span class="n">domainMin</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">other2</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">boundaries</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">region</span><span class="o">.</span><span class="n">domainMin</span><span class="p">)</span>
        <span class="n">boundaries</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">boundaries</span><span class="p">)</span>

        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">priorBoundary</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">boundariesToMove</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">boundary</span> <span class="ow">in</span> <span class="n">boundaries</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">priorBoundary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">boundary</span> <span class="o">-</span> <span class="n">priorBoundary</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">epsilon</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">boundary</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">priorBoundary</span><span class="p">)):</span>
                    <span class="n">boundariesToMove</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">boundary</span><span class="p">,</span> <span class="n">priorBoundary</span><span class="p">])</span>
                    <span class="n">boundary</span> <span class="o">=</span> <span class="n">priorBoundary</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;more than one boundary within epsilon = </span><span class="si">%s</span><span class="s1"> of </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">epsilon</span><span class="p">,</span> <span class="n">priorBoundary</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">priorBoundary</span> <span class="o">=</span> <span class="n">boundary</span>

        <span class="k">for</span> <span class="n">boundary</span><span class="p">,</span> <span class="n">priorBoundary</span> <span class="ow">in</span> <span class="n">boundariesToMove</span><span class="p">:</span>
            <span class="n">boundaries</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">boundary</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">processBoundaries</span><span class="p">(</span><span class="n">regions_</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">,</span> <span class="n">boundariesToMove</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This method adds regions to *regions_* so that its has a region boundary for each value in boundaries.</span>

<span class="sd">            :param regions_:            This is the regions to work on.</span>
<span class="sd">            :param boundaries:          This is the list of boundaries that the final regions shall have.</span>
<span class="sd">            :param boundariesToMove:    This is the list of (new, old) boundaries in *regions_* where old is tweaked to become new.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">regions_</span><span class="p">:</span>
                <span class="n">domainMin</span><span class="p">,</span> <span class="n">domainMax</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">domainMin</span><span class="p">,</span> <span class="n">region</span><span class="o">.</span><span class="n">domainMax</span>
                <span class="k">for</span> <span class="n">boundary</span><span class="p">,</span> <span class="n">priorBoundary</span> <span class="ow">in</span> <span class="n">boundariesToMove</span><span class="p">:</span>
                    <span class="k">if</span>   <span class="n">domainMin</span> <span class="o">==</span> <span class="n">boundary</span><span class="p">:</span>
                        <span class="n">region</span><span class="o">.</span><span class="n">tweakDomain</span><span class="p">(</span><span class="n">domainMin</span> <span class="o">=</span> <span class="n">priorBoundary</span><span class="p">,</span> <span class="n">epsilon</span> <span class="o">=</span> <span class="n">epsilon</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">domainMax</span> <span class="o">==</span> <span class="n">boundary</span><span class="p">:</span>
                        <span class="n">region</span><span class="o">.</span><span class="n">tweakDomain</span><span class="p">(</span><span class="n">domainMax</span> <span class="o">=</span> <span class="n">priorBoundary</span><span class="p">,</span> <span class="n">epsilon</span> <span class="o">=</span> <span class="n">epsilon</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">boundary</span> <span class="ow">in</span> <span class="n">boundaries</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">regions_</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">region</span><span class="o">.</span><span class="n">domainMin</span> <span class="o">&lt;</span> <span class="n">boundary</span> <span class="o">&lt;</span> <span class="n">region</span><span class="o">.</span><span class="n">domainMax</span><span class="p">:</span>
                        <span class="n">regions_</span><span class="o">.</span><span class="n">splitInTwo</span><span class="p">(</span><span class="n">boundary</span><span class="p">,</span> <span class="n">epsilon</span> <span class="o">=</span> <span class="n">epsilon</span><span class="p">)</span>
                        <span class="k">break</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">boundaries</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">processBoundaries</span><span class="p">(</span><span class="n">self2</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">,</span> <span class="n">boundariesToMove</span><span class="p">)</span>
            <span class="n">processBoundaries</span><span class="p">(</span><span class="n">other2</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">,</span> <span class="n">boundariesToMove</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">self2</span><span class="p">,</span> <span class="n">other2</span></div>

<div class="viewcode-block" id="Regions1d.copyDataToXsAndYs"><a class="viewcode-back" href="../../xData/index.html#xData.regions.Regions1d.copyDataToXsAndYs">[docs]</a>    <span class="k">def</span> <span class="nf">copyDataToXsAndYs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method copies data in *self* to a list of xs and ys. Only works if each region instance has a &quot;copyDataToXsAndYs&quot; method.</span>

<span class="sd">        :returns:   Two python lists, one with the x-values and one with the y-values.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">xs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">subXs</span><span class="p">,</span> <span class="n">subYs</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">copyDataToXsAndYs</span><span class="p">()</span>
            <span class="n">xs</span> <span class="o">+=</span> <span class="n">subXs</span>
            <span class="n">ys</span> <span class="o">+=</span> <span class="n">subYs</span>
        <span class="k">return</span> <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span></div>

<div class="viewcode-block" id="Regions1d.normalize"><a class="viewcode-back" href="../../xData/index.html#xData.regions.Regions1d.normalize">[docs]</a>    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">insitu</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">dimension</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method normalizes the data in *self*, ergo, scaled so that its integral is 1.0.</span>
<span class="sd">        If *insitu* is True, *self* is normalized and returned, otherwise a copy of *self* is normalizes and the copy is returned.</span>
<span class="sd">        The dimension argument is currently ignored, but kept to be compatible with calling from XYsnd.normalize.</span>

<span class="sd">        :param insitu:          If True, *self* is normalized and returned.</span>
<span class="sd">        :param dimension:       The argument is ignored.</span>

<span class="sd">        :returns:               A *self* like instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">factor</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">integrate</span><span class="p">()</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">insitu</span> <span class="p">)</span> <span class="p">:</span>
            <span class="n">copy</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="n">copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">copy</span> <span class="p">:</span> <span class="n">region</span> <span class="o">*=</span> <span class="n">factor</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">copy</span> <span class="p">)</span></div>

<div class="viewcode-block" id="Regions1d.plot"><a class="viewcode-back" href="../../xData/index.html#xData.regions.Regions1d.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calls multiPlot with only *self* as a curve.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">multiPlot</span><span class="p">([</span><span class="bp">self</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Regions1d.toPointwiseLinear"><a class="viewcode-back" href="../../xData/index.html#xData.regions.Regions1d.toPointwiseLinear">[docs]</a>    <span class="k">def</span> <span class="nf">toPointwiseLinear</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span> <span class="p">)</span> <span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns the results of calling :py:func:`toPointwise_withLinearXYs`.</span>

<span class="sd">        :param kwargs:      A dictionary of data needed by *self*.</span>

<span class="sd">        :returns:           An instance of :py:class:`XYs1dModule.XYs1d`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">toPointwise_withLinearXYs</span><span class="p">(</span> <span class="o">**</span><span class="n">kwargs</span> <span class="p">)</span> <span class="p">)</span></div>

<div class="viewcode-block" id="Regions1d.toPointwise_withLinearXYs"><a class="viewcode-back" href="../../xData/index.html#xData.regions.Regions1d.toPointwise_withLinearXYs">[docs]</a>    <span class="k">def</span> <span class="nf">toPointwise_withLinearXYs</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span> <span class="p">)</span> <span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method converts the regions of *self* into a single :py:class:`XYs1dModule.XYs1d` instance that has &#39;lin-lin&#39; interpolation. At the</span>
<span class="sd">        boundary between two abutting regions, the x-values are the same, which is not allowed for an :py:class:`XYs1dModule.XYs1d` instance</span>
<span class="sd">        so some points may be added or removed as speicfied by data in the argument *kwargs* as described in the following:</span>

<span class="sd">            -) accuracy:    This controls how many points are added when switching interpolation.</span>
<span class="sd">            -) lowerEps and upperEps: These arguments are used to smear the x-values at a boundary as follows. Let :math:`(x, y_l)` and</span>
<span class="sd">                            :math:`(x, y_u)` be the abutting points for two abutting regions. If :math:`y_l = y_u` then the </span>
<span class="sd">                            point :math:`(x, y_u)` is removed.  Otherwise, if( lowerEps &gt; 0 ) the point :math:`(x, y_l)` is </span>
<span class="sd">                            moved to :math:`x&#39; = x * ( 1 - lowerEps )` (or :math:`x&#39; = x * ( 1 + lowerEps )` if :math:`x &lt; 0`) </span>
<span class="sd">                            and the :math:`y` value is interpolated at :math:`x&#39;`. If :math:`x&#39;` is less than the x-value of the point </span>
<span class="sd">                            below :math:`(x&#39;, y_l)` and ``removeOverAdjustedPoints`` is True then the point :math:`(x, y_l)` is removed; </span>
<span class="sd">                            otherwise, a raise is executed. Similarly for upperEps and the point :math:`(x, y_u)`.</span>

<span class="sd">        :param kwargs:      A dictionary of data needed by *self*.</span>

<span class="sd">        :returns:           An instance of :py:class:`XYs1dModule.XYs1d`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">getAdjustedX</span><span class="p">(</span> <span class="n">x</span><span class="p">,</span> <span class="n">eps</span> <span class="p">)</span> <span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This method returns an x-value that is shifted from *x* by *eps*. If *eps* is negative, the returned value will be</span>
<span class="sd">            left than *x*; otherwise, it will be greater than.  Thie method is for internal use.</span>

<span class="sd">            :param x:       The initial x-value.</span>
<span class="sd">            :param eps:     The small amount to move the new x-value from *x*.</span>

<span class="sd">            :returns:       A python float.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">if</span><span class="p">(</span> <span class="n">x</span> <span class="o">==</span> <span class="mf">0.</span> <span class="p">)</span> <span class="p">:</span>
                <span class="n">x_</span> <span class="o">=</span> <span class="n">eps</span>
            <span class="k">elif</span><span class="p">(</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">:</span>
                <span class="n">x_</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span> <span class="mf">1.</span> <span class="o">-</span> <span class="n">eps</span> <span class="p">)</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="n">x_</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span> <span class="mf">1.</span> <span class="o">+</span> <span class="n">eps</span> <span class="p">)</span>
            <span class="k">return</span><span class="p">(</span> <span class="n">x_</span> <span class="p">)</span>

        <span class="n">pointwiseClass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">toLinearXYsClass</span><span class="p">(</span> <span class="p">)</span>
        <span class="k">if</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">regions</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">:</span> <span class="k">return</span><span class="p">(</span> <span class="n">pointwiseClass</span><span class="p">(</span> <span class="n">data</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span> <span class="p">)</span> <span class="p">)</span>

        <span class="n">arguments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getArguments</span><span class="p">(</span> <span class="n">kwargs</span><span class="p">,</span> <span class="p">{</span> <span class="s1">&#39;accuracy&#39;</span> <span class="p">:</span> <span class="n">XYs1dModule</span><span class="o">.</span><span class="n">defaultAccuracy</span><span class="p">,</span> <span class="s1">&#39;lowerEps&#39;</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;upperEps&#39;</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span> 
                <span class="s1">&#39;removeOverAdjustedPoints&#39;</span> <span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;axes&#39;</span> <span class="p">:</span> <span class="kc">None</span> <span class="p">}</span> <span class="p">)</span>
        <span class="n">accuracy</span> <span class="o">=</span> <span class="n">arguments</span><span class="p">[</span><span class="s1">&#39;accuracy&#39;</span><span class="p">]</span>
        <span class="n">lowerEps</span> <span class="o">=</span> <span class="n">arguments</span><span class="p">[</span><span class="s1">&#39;lowerEps&#39;</span><span class="p">]</span>
        <span class="n">upperEps</span> <span class="o">=</span> <span class="n">arguments</span><span class="p">[</span><span class="s1">&#39;upperEps&#39;</span><span class="p">]</span>
        <span class="n">removeOverAdjustedPoints</span> <span class="o">=</span> <span class="n">arguments</span><span class="p">[</span><span class="s1">&#39;removeOverAdjustedPoints&#39;</span><span class="p">]</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="n">arguments</span><span class="p">[</span><span class="s1">&#39;axes&#39;</span><span class="p">]</span>

        <span class="k">if</span><span class="p">(</span> <span class="n">lowerEps</span> <span class="o">&lt;</span> <span class="mf">0.</span> <span class="p">)</span> <span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s1">&#39;lowerEps = </span><span class="si">%s</span><span class="s1"> must &gt;= 0.&#39;</span> <span class="o">%</span> <span class="n">lowerEps</span> <span class="p">)</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">upperEps</span> <span class="o">&lt;</span> <span class="mf">0.</span> <span class="p">)</span> <span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s1">&#39;upperEps = </span><span class="si">%s</span><span class="s1"> must &gt;= 0.&#39;</span> <span class="o">%</span> <span class="n">upperEps</span> <span class="p">)</span>
        <span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="n">lowerEps</span> <span class="o">==</span> <span class="mf">0.</span> <span class="p">)</span> <span class="ow">and</span> <span class="p">(</span> <span class="n">upperEps</span> <span class="o">==</span> <span class="mf">0.</span> <span class="p">)</span> <span class="p">)</span> <span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s1">&#39;lowerEps and upperEps cannot both be 0.&#39;</span> <span class="p">)</span>

        <span class="n">xys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">iRegion</span><span class="p">,</span> <span class="n">region</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">regions</span> <span class="p">)</span> <span class="p">:</span>
            <span class="n">_region</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">changeInterpolation</span><span class="p">(</span><span class="n">enumsModule</span><span class="o">.</span><span class="n">Interpolation</span><span class="o">.</span><span class="n">linlin</span><span class="p">,</span> <span class="n">accuracy</span><span class="p">,</span> <span class="n">lowerEps</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">lowerEps</span><span class="p">,</span> <span class="n">upperEps</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">upperEps</span> <span class="p">)</span>
            <span class="n">_region</span> <span class="o">=</span> <span class="n">_region</span><span class="o">.</span><span class="n">copyDataToXYs</span><span class="p">(</span> <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_region</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span> <span class="k">continue</span>
            <span class="k">if</span> <span class="n">iRegion</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">xys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">x12</span><span class="p">,</span> <span class="n">y12</span> <span class="o">=</span> <span class="n">xys</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">x21</span><span class="p">,</span> <span class="n">y21</span> <span class="o">=</span> <span class="n">_region</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span><span class="p">(</span> <span class="n">y12</span> <span class="o">==</span> <span class="n">y21</span> <span class="p">)</span> <span class="p">:</span>              <span class="c1"># Remove first point of region as it is the same as the last point.</span>
                    <span class="k">del</span> <span class="n">_region</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span> <span class="p">:</span>
                    <span class="k">if</span><span class="p">(</span> <span class="n">lowerEps</span> <span class="o">!=</span> <span class="mf">0.</span> <span class="p">)</span> <span class="p">:</span>
                        <span class="n">x11</span><span class="p">,</span> <span class="n">y11</span> <span class="o">=</span> <span class="n">xys</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">getAdjustedX</span><span class="p">(</span> <span class="n">x12</span><span class="p">,</span> <span class="o">-</span><span class="n">lowerEps</span> <span class="p">)</span>
                        <span class="k">if</span><span class="p">(</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">x11</span> <span class="p">)</span> <span class="p">:</span>
                            <span class="k">if</span><span class="p">(</span> <span class="n">removeOverAdjustedPoints</span> <span class="p">)</span> <span class="p">:</span>
                                <span class="k">del</span> <span class="n">xys</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                            <span class="k">else</span> <span class="p">:</span>
                                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s1">&#39;Adjustment at </span><span class="si">%s</span><span class="s1"> makes new x = </span><span class="si">%s</span><span class="s1"> &gt;= prior x = </span><span class="si">%s</span><span class="s1">; eps = </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span> <span class="n">x12</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x11</span><span class="p">,</span> <span class="n">lowerEps</span> <span class="p">)</span> <span class="p">)</span>
                        <span class="k">else</span> <span class="p">:</span>
                            <span class="n">xys</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">XYs1dModule</span><span class="o">.</span><span class="n">pointwiseXY_C</span><span class="o">.</span><span class="n">interpolatePoint</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">enumsModule</span><span class="o">.</span><span class="n">Interpolation</span><span class="o">.</span><span class="n">linlin</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">x11</span><span class="p">,</span> <span class="n">y11</span><span class="p">,</span> <span class="n">x12</span><span class="p">,</span> <span class="n">y12</span><span class="p">)]</span>
                    <span class="k">if</span><span class="p">(</span> <span class="n">upperEps</span> <span class="o">!=</span> <span class="mf">0.</span> <span class="p">)</span> <span class="p">:</span>
                        <span class="n">x22</span><span class="p">,</span> <span class="n">y22</span> <span class="o">=</span> <span class="n">_region</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">getAdjustedX</span><span class="p">(</span> <span class="n">x21</span><span class="p">,</span> <span class="n">upperEps</span> <span class="p">)</span>
                        <span class="k">if</span><span class="p">(</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">x22</span> <span class="p">)</span> <span class="p">:</span>
                            <span class="k">if</span><span class="p">(</span> <span class="n">removeOverAdjustedPoints</span> <span class="p">)</span> <span class="p">:</span>
                                <span class="k">del</span> <span class="n">_region</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="k">else</span> <span class="p">:</span>
                                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s1">&#39;Adjustment at </span><span class="si">%s</span><span class="s1"> makes new x = </span><span class="si">%s</span><span class="s1"> &gt;= next x = </span><span class="si">%s</span><span class="s1">; eps = </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span> <span class="n">x21</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x22</span><span class="p">,</span> <span class="n">upperEps</span> <span class="p">)</span> <span class="p">)</span>
                        <span class="k">else</span> <span class="p">:</span>
                            <span class="n">_region</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">XYs1dModule</span><span class="o">.</span><span class="n">pointwiseXY_C</span><span class="o">.</span><span class="n">interpolatePoint</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">enumsModule</span><span class="o">.</span><span class="n">Interpolation</span><span class="o">.</span><span class="n">linlin</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">x21</span><span class="p">,</span> <span class="n">y21</span><span class="p">,</span> <span class="n">x22</span><span class="p">,</span> <span class="n">y22</span><span class="p">)]</span>
            <span class="n">xys</span> <span class="o">+=</span> <span class="n">_region</span>
        <span class="n">pointwise</span> <span class="o">=</span> <span class="n">pointwiseClass</span><span class="p">(</span> <span class="n">data</span> <span class="o">=</span> <span class="n">xys</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">outerDomainValue</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outerDomainValue</span> <span class="p">)</span> <span class="c1"># FIXME - need more work to insure all parameters are set properly.</span>
        <span class="k">return</span><span class="p">(</span> <span class="n">pointwise</span> <span class="p">)</span></div>

<div class="viewcode-block" id="Regions1d.toLinearXYsClass"><a class="viewcode-back" href="../../xData/index.html#xData.regions.Regions1d.toLinearXYsClass">[docs]</a>    <span class="k">def</span> <span class="nf">toLinearXYsClass</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method always returns the class :py:class:`XYs1dModule.XYs1d`.</span>

<span class="sd">        :returns:       The class :py:class:`XYs1dModule.XYs1d`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span><span class="p">(</span> <span class="n">XYs1dModule</span><span class="o">.</span><span class="n">XYs1d</span> <span class="p">)</span></div>

<div class="viewcode-block" id="Regions1d.allowedSubElements"><a class="viewcode-back" href="../../xData/index.html#xData.regions.Regions1d.allowedSubElements">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">allowedSubElements</span><span class="p">(</span> <span class="p">)</span> <span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns a list of all 1d functions class that can be added as a region to an instance of :py:class:`Regions1d`.</span>

<span class="sd">        :returns:       A list of 1d functions classes</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span><span class="p">(</span> <span class="p">(</span> <span class="n">XYs1dModule</span><span class="o">.</span><span class="n">XYs1d</span><span class="p">,</span> <span class="n">series1dModule</span><span class="o">.</span><span class="n">Series1d</span> <span class="p">)</span> <span class="p">)</span></div>

<div class="viewcode-block" id="Regions1d.multiPlot"><a class="viewcode-back" href="../../xData/index.html#xData.regions.Regions1d.multiPlot">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">multiPlot</span><span class="p">(</span><span class="n">curve1ds</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots a list of 1d curves on the same plot. Uses each curve&#39;s &#39;plotLabel&#39; as the legend key. Each curve must have a copyDataToXsAndYs method.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">XYs1dModule</span><span class="o">.</span><span class="n">XYs1d</span><span class="o">.</span><span class="n">multiPlot</span><span class="p">(</span><span class="n">curve1ds</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="RegionsMultiD"><a class="viewcode-back" href="../../xData/index.html#xData.regions.RegionsMultiD">[docs]</a><span class="k">class</span> <span class="nc">RegionsMultiD</span><span class="p">(</span> <span class="n">Regions</span> <span class="p">)</span> <span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is the absract base class for the other regions classes of dimension 2 and 3..</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RegionsMultiD.getBoundingSubFunctions"><a class="viewcode-back" href="../../xData/index.html#xData.regions.RegionsMultiD.getBoundingSubFunctions">[docs]</a>    <span class="k">def</span> <span class="nf">getBoundingSubFunctions</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">domainValue</span> <span class="p">)</span> <span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns the two sub-functions in the region containing the domain point *domainValue*</span>
<span class="sd">        whose outerDomainValues bound *value*. Additonal information is also returned.</span>
<span class="sd">        The returned inforamtion is the tuple (flag, functional1, functional2, frac, interpolation, interpolationQualifier).</span>

<span class="sd">        Flag is one of</span>
<span class="sd">            +-------+---------------------------------------------------------------------------+</span>
<span class="sd">            | None  | no data,                                                                  |</span>
<span class="sd">            +-------+---------------------------------------------------------------------------+</span>
<span class="sd">            | &#39;&lt;&#39;   | value below domainMin,                                                    |</span>
<span class="sd">            +-------+---------------------------------------------------------------------------+</span>
<span class="sd">            | &#39;&gt;&#39;   | value above domainMax,                                                    |</span>
<span class="sd">            +-------+---------------------------------------------------------------------------+</span>
<span class="sd">            | &#39;=&#39;   | value at functional1 or                                                   |</span>
<span class="sd">            +-------+---------------------------------------------------------------------------+</span>
<span class="sd">            | &#39;&#39;    | functional1.outerDomainValue &lt;= value &lt; functional2.outerDomainValue.     |</span>
<span class="sd">            +-------+---------------------------------------------------------------------------+</span>

<span class="sd">        If flag is None then functional1, functional2 and frac are also None.  If flag is not &#39;&#39; then functional2 is None.</span>
<span class="sd">        The data frac, interpolation and interpolationQualifier give the fraction position of *value* between the</span>
<span class="sd">        two sub-functions, and how to interpolate between the two returned sub-functions. this method is mainly for internal use.</span>

<span class="sd">        :param value:   The domain value which is between the two returned sub-functions outerDomainValues.</span>

<span class="sd">        :returns:       A tuple containing information about the bounding sub-functions.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">regions</span> <span class="p">:</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">domainValue</span> <span class="o">&lt;</span> <span class="n">region</span><span class="o">.</span><span class="n">domainMax</span> <span class="p">)</span> <span class="p">:</span> <span class="k">return</span><span class="p">(</span> <span class="n">region</span><span class="o">.</span><span class="n">getBoundingSubFunctions</span><span class="p">(</span> <span class="n">domainValue</span> <span class="p">)</span> <span class="p">)</span>

        <span class="k">return</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">regions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">getBoundingSubFunctions</span><span class="p">(</span> <span class="n">domainValue</span> <span class="p">)</span> <span class="p">)</span>  <span class="c1"># Domain value is above the last region. Let the last region determine what to do.</span></div></div>

<div class="viewcode-block" id="Regions2d"><a class="viewcode-back" href="../../xData/index.html#xData.regions.Regions2d">[docs]</a><span class="k">class</span> <span class="nc">Regions2d</span><span class="p">(</span> <span class="n">RegionsMultiD</span> <span class="p">)</span> <span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class supports storing a 2d function as a list of abutting 2d functions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">moniker</span> <span class="o">=</span> <span class="s1">&#39;regions2d&#39;</span>
    <span class="n">dimension</span> <span class="o">=</span> <span class="mi">2</span>

<div class="viewcode-block" id="Regions2d.toLinearXYsClass"><a class="viewcode-back" href="../../xData/index.html#xData.regions.Regions2d.toLinearXYsClass">[docs]</a>    <span class="k">def</span> <span class="nf">toLinearXYsClass</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method always returns the class :py:class:`Regions`.</span>

<span class="sd">        :returns:       The class :py:class:`Regions`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span><span class="p">(</span> <span class="n">Regions</span> <span class="p">)</span></div>

<div class="viewcode-block" id="Regions2d.allowedSubElements"><a class="viewcode-back" href="../../xData/index.html#xData.regions.Regions2d.allowedSubElements">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">allowedSubElements</span><span class="p">(</span> <span class="p">)</span> <span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns a list of all 2d functions class that can be added as a region to an instance of :py:class:`Regions2d`.</span>

<span class="sd">        :returns:       A list of 2d functions classes</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">multiD_XYs</span> <span class="k">as</span> <span class="n">multiD_XYsModule</span>

        <span class="k">return</span><span class="p">(</span> <span class="p">(</span> <span class="n">multiD_XYsModule</span><span class="o">.</span><span class="n">XYs2d</span><span class="p">,</span> <span class="p">)</span> <span class="p">)</span></div></div>

<div class="viewcode-block" id="Regions3d"><a class="viewcode-back" href="../../xData/index.html#xData.regions.Regions3d">[docs]</a><span class="k">class</span> <span class="nc">Regions3d</span><span class="p">(</span> <span class="n">RegionsMultiD</span> <span class="p">)</span> <span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class supports storing a 3d function as a list of abutting 3d functions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">moniker</span> <span class="o">=</span> <span class="s1">&#39;regions3d&#39;</span>
    <span class="n">dimension</span> <span class="o">=</span> <span class="mi">3</span>

<div class="viewcode-block" id="Regions3d.toLinearXYsClass"><a class="viewcode-back" href="../../xData/index.html#xData.regions.Regions3d.toLinearXYsClass">[docs]</a>    <span class="k">def</span> <span class="nf">toLinearXYsClass</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span> <span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method always returns the class :py:class:`Regions`.</span>

<span class="sd">        :returns:       The class :py:class:`Regions`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span><span class="p">(</span> <span class="n">Regions</span> <span class="p">)</span></div>

<div class="viewcode-block" id="Regions3d.allowedSubElements"><a class="viewcode-back" href="../../xData/index.html#xData.regions.Regions3d.allowedSubElements">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">allowedSubElements</span><span class="p">(</span> <span class="p">)</span> <span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns a list of all 3d functions class that can be added as a region to an instance of :py:class:`Regions3d`.</span>

<span class="sd">        :returns:       A list of 3d functions classes</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">multiD_XYs</span> <span class="k">as</span> <span class="n">multiD_XYsModule</span>

        <span class="k">return</span><span class="p">(</span> <span class="p">(</span> <span class="n">multiD_XYsModule</span><span class="o">.</span><span class="n">XYs3d</span><span class="p">,</span> <span class="p">)</span> <span class="p">)</span></div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/gnd.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Fudge and GNDS 6.1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">xData.regions</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2012, B.Beck, D. Brown, C. Mattoon, N. Patel, N. Summers.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.0.2.
    </div>
  </body>
</html>