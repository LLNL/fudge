
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>fudge.processing.resonances.reconstructResonances &#8212; Fudge and GNDS 6.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/classic.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css" />
    
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    
    <link rel="shortcut icon" href="../../../../_static/gnd-20121206-favicon.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">Fudge and GNDS 6.1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">fudge.processing.resonances.reconstructResonances</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for fudge.processing.resonances.reconstructResonances</h1><div class="highlight"><pre>
<span></span><span class="ch">#! /usr/bin/env python3</span>
<span class="c1">#encoding: utf-8</span>

<span class="c1"># &lt;&lt;BEGIN-copyright&gt;&gt;</span>
<span class="c1"># &lt;&lt;END-copyright&gt;&gt;</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">See ENDF-102 (endf documentation) appendix D for equations</span>

<span class="sd">Basic usage:</span>
<span class="sd">------------</span>

<span class="sd">    if protare is a reactionSuite instance,::</span>

<span class="sd">        &gt;&gt;protare.reconstructResonances(tolerance=0.01)</span>

<span class="sd">    This reconstructs all resolved/unresolved resonance sections. In each section,</span>
<span class="sd">    the results are accurate under linear interpolation to tolerance of 1% or better.</span>
<span class="sd">    Sections are summed together and then added to the appropriate background cross</span>
<span class="sd">    sections to form new pointwise, lin-lin cross sections that are stored in the</span>
<span class="sd">    appropriate reaction inside protare.</span>

<span class="sd">Alternate uses:</span>
<span class="sd">---------------</span>

<span class="sd">    You can skip the final step (adding background cross sections) and just get the</span>
<span class="sd">    resonance parameter contribution to the cross section by doing::</span>

<span class="sd">        &gt;&gt;xsecs = reconstructResonances.reconstructResonances(protare, 0.01)</span>

<span class="sd">    Here,::</span>

<span class="sd">        * xsecs = dictionary containing cross sections: {&#39;total&#39;:XYs, &#39;elastic&#39;:XYs, ...}</span>

<span class="sd">    each cross section is an XYs class instance, containing data and also axes with units</span>

<span class="sd">    Another option would be to only reconstruct a single section::</span>

<span class="sd">        &gt;&gt; resCls = reconstructResonances.RMcrossSection(protare, energyUnit=&#39;eV&#39;)   # for Reich_Moore</span>
<span class="sd">        &gt;&gt; energy_grid = s.generateEnergyGrid()</span>
<span class="sd">        &gt;&gt; crossSections = s.getCrossSection( energy_grid )</span>
<span class="sd">        # the input to getCrossSection is the energy (or list of energies) in self.energyUnit</span>
<span class="sd">        # crossSections are returned as a dictionary {&#39;total&#39;:,&#39;elastic&#39;:,&#39;capture&#39;:,&#39;fission&#39;:,}</span>

<span class="sd">        # improve grid to desired tolerance for linear interpolation:</span>
<span class="sd">        &gt;&gt; new_energy_grid, new_crossSections, messages = s.refineInterpolation(energy_grid, crossSections, tolerance=0.01)</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">numpy</span><span class="o">,</span> <span class="nn">collections</span><span class="o">,</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">abc</span>

<span class="kn">from</span> <span class="nn">pqu</span> <span class="kn">import</span> <span class="n">PQU</span> <span class="k">as</span> <span class="n">PQUModule</span>

<span class="kn">from</span> <span class="nn">fudge</span> <span class="kn">import</span> <span class="n">reactionSuite</span> <span class="k">as</span> <span class="n">reactionSuiteModule</span>
<span class="kn">from</span> <span class="nn">fudge.reactionData</span> <span class="kn">import</span> <span class="n">crossSection</span> <span class="k">as</span> <span class="n">crossSectionModule</span>
<span class="kn">from</span> <span class="nn">fudge.productData.distributions</span> <span class="kn">import</span> <span class="n">angular</span> <span class="k">as</span> <span class="n">angularModule</span>

<span class="kn">from</span> <span class="nn">fudge.resonances</span> <span class="kn">import</span> <span class="n">resolved</span> <span class="k">as</span> <span class="n">resolvedModule</span><span class="p">,</span> <span class="n">common</span> <span class="k">as</span> <span class="n">commonResonancesModule</span>

<span class="kn">import</span> <span class="nn">fudge.processing.resonances.getCoulombWavefunctions</span> <span class="k">as</span> <span class="nn">getCoulombWavefunctions</span>
<span class="kn">from</span> <span class="nn">fudge.core.math.fudgemath</span> <span class="kn">import</span> <span class="n">RoundToSigFigs</span>

<span class="kn">from</span> <span class="nn">xData</span> <span class="kn">import</span> <span class="n">XYs1d</span> <span class="k">as</span> <span class="n">XYs1dModule</span>

<span class="kn">from</span> <span class="nn">PoPs.chemicalElements</span> <span class="kn">import</span> <span class="n">misc</span> <span class="k">as</span> <span class="n">chemicalElementMiscPoPsModule</span>
<span class="kn">from</span> <span class="nn">PoPs.families</span> <span class="kn">import</span> <span class="n">nuclide</span> <span class="k">as</span> <span class="n">nuclidePoPsModule</span>

<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="o">.</span><span class="n">major</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">multiprocessing</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">multiprocessing</span><span class="o">.</span><span class="n">set_start_method</span><span class="p">(</span><span class="s2">&quot;fork&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>    <span class="c1"># multiprocessing context may have already been set</span>
        <span class="k">pass</span>

<span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>   <span class="c1"># recommend setting to True before debugging (disables multiprocessing)</span>

<span class="n">VERBOSE</span> <span class="o">=</span> <span class="kc">False</span>

<span class="n">FISSIONCHANNEL</span><span class="p">,</span> <span class="n">NEUTRONCHANNEL</span><span class="p">,</span> <span class="n">CPCHANNEL</span><span class="p">,</span> <span class="n">GAMMACHANNEL</span><span class="p">,</span> <span class="n">COMPETITIVECHANNEL</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<div class="viewcode-block" id="ChannelDesignator"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.ChannelDesignator">[docs]</a><span class="k">class</span> <span class="nc">ChannelDesignator</span><span class="p">:</span>
    <span class="vm">__slots__</span><span class="o">=</span><span class="p">[</span> <span class="s1">&#39;l&#39;</span><span class="p">,</span> <span class="s1">&#39;J&#39;</span><span class="p">,</span> <span class="s1">&#39;reaction&#39;</span><span class="p">,</span> <span class="s1">&#39;index&#39;</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;gfact&#39;</span><span class="p">,</span> <span class="s1">&#39;particleA&#39;</span><span class="p">,</span> <span class="s1">&#39;particleB&#39;</span><span class="p">,</span> <span class="s1">&#39;Xi&#39;</span><span class="p">,</span> <span class="s1">&#39;isElastic&#39;</span><span class="p">,</span> <span class="s1">&#39;channelClass&#39;</span><span class="p">,</span> <span class="s1">&#39;useRelativistic&#39;</span><span class="p">,</span> <span class="s1">&#39;eliminated&#39;</span> <span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">reaction</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">gfact</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">particleA</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">particleB</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Xi</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">isElastic</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">channelClass</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">useRelativistic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">eliminated</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simple widget to specify a channel</span>

<span class="sd">        RRBaseClass.setResonanceParametersByChannel() creates these mostly and getAllowedTotalSpins() is used to determine the spins in there.</span>
<span class="sd">        So, if you&#39;re wondering why s is really 2*s, unlike l and J, check in those routines.</span>

<span class="sd">        :param l: orbital angular momentum of channel, an int</span>
<span class="sd">        :param J: total angular momentum of a channel, can be an int or 1/2 int (use the _eq_ below to avoid floating point comparisons)</span>
<span class="sd">        :param reaction: string, name of the reaction associated with this channel</span>
<span class="sd">        :param index: int, an optional index of the channel (useful if using this in an unordered dictionary)</span>
<span class="sd">        :param s: total spin of a channel, can be an int or 1/2 int (use the _eq_ below to avoid floating point comparisons)</span>
<span class="sd">        :param gfact: statistical factor</span>
<span class="sd">        :param particleA: the projectile, either a string (&#39;n&#39;) or None if you don&#39;t need it</span>
<span class="sd">        :param particleB: the target, either a string (&#39;Pu239&#39;) or None if you don&#39;t need it</span>
<span class="sd">        :param Xi: threshold energy in lab frame</span>
<span class="sd">        :param isElastic: flag to denote that this channel is, in fact, also incoming channel so this is an elastic channel</span>
<span class="sd">        :param channelClass: nature of channel: gamma, fission, neutron or charged particle</span>
<span class="sd">        :param useRelativistic: flag for using relativistic kinematics</span>
<span class="sd">        :param eliminated: flag for whether to eliminate this channel using Reich-Moore approximation (useful for gamma channels)</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="o">=</span><span class="n">l</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="o">=</span><span class="n">J</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reaction</span><span class="o">=</span><span class="n">reaction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">=</span><span class="n">index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="o">=</span><span class="n">s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gfact</span><span class="o">=</span><span class="n">gfact</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">particleA</span><span class="o">=</span><span class="n">particleA</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">particleB</span><span class="o">=</span><span class="n">particleB</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Xi</span><span class="o">=</span><span class="n">Xi</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isElastic</span><span class="o">=</span><span class="n">isElastic</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channelClass</span><span class="o">=</span><span class="n">channelClass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">useRelativistic</span><span class="o">=</span><span class="n">useRelativistic</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eliminated</span><span class="o">=</span><span class="n">eliminated</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gfact</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">gfact</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">gfact_identical</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gfact</span> <span class="ow">is</span> <span class="n">other</span><span class="o">.</span><span class="n">gfact</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gfact_identical</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gfact</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">gfact</span><span class="p">,</span> <span class="n">rel_tol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">abs_tol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">l</span> <span class="ow">and</span> \
               <span class="nb">int</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">)</span><span class="o">==</span><span class="nb">int</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">J</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="nb">int</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">)</span><span class="o">==</span><span class="nb">int</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="n">gfact_identical</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">particleA</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">particleA</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">particleB</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">particleB</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">isElastic</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">isElastic</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">channelClass</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">channelClass</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">useRelativistic</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">useRelativistic</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">eliminated</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">eliminated</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">theHash</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">ChannelDesignator</span><span class="o">.</span><span class="vm">__slots__</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s1">&#39;Xi&#39;</span><span class="p">:</span> <span class="k">continue</span> <span class="c1"># is computable and is real, so lousy for hashing</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s1">&#39;gfact&#39;</span><span class="p">:</span> <span class="k">continue</span> <span class="c1"># is computable and is real, so lousy for hashing</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s1">&#39;reaction&#39;</span><span class="p">:</span> <span class="k">continue</span> <span class="c1"># LRF=7 calls &#39;elastic&#39; &#39;n+Target&#39;, so the name is kinda meaningless</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s1">&#39;eliminated&#39;</span><span class="p">:</span> <span class="k">continue</span> <span class="c1"># different approximations treat this field differently</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s1">&#39;index&#39;</span><span class="p">:</span> <span class="k">continue</span> <span class="c1"># this isn&#39;t used except for printing out</span>
            <span class="n">theHash</span> <span class="o">+=</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">theHash</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;ChannelDesignator(l=</span><span class="si">%i</span><span class="s2">, J=</span><span class="si">%s</span><span class="s2">, reaction=&#39;</span><span class="si">%s</span><span class="s2">&#39;, index=</span><span class="si">%i</span><span class="s2">, s=</span><span class="si">%s</span><span class="s2">, gfact=</span><span class="si">%s</span><span class="s2">, particleA=&#39;</span><span class="si">%s</span><span class="s2">&#39;, particleB=&#39;</span><span class="si">%s</span><span class="s2">&#39;, Xi=</span><span class="si">%s</span><span class="s2">, isElastic=</span><span class="si">%s</span><span class="s2">, channelClass=</span><span class="si">%s</span><span class="s2">, useRelativistic=</span><span class="si">%s</span><span class="s2">, eliminated=</span><span class="si">%s</span><span class="s2">)&quot;</span> \
               <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">reaction</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gfact</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">particleA</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">particleB</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xi</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">isElastic</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">channelClass</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">useRelativistic</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eliminated</span><span class="p">)</span>

<div class="viewcode-block" id="ChannelDesignator.has_same_J"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.ChannelDesignator.has_same_J">[docs]</a>    <span class="k">def</span> <span class="nf">has_same_J</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="o">-</span><span class="n">other</span><span class="o">.</span><span class="n">J</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">0.001</span></div>

<div class="viewcode-block" id="ChannelDesignator.is_open"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.ChannelDesignator.is_open">[docs]</a>    <span class="k">def</span> <span class="nf">is_open</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">Ein</span><span class="p">):</span> <span class="k">return</span> <span class="n">Ein</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xi</span></div></div>


<div class="viewcode-block" id="spins_equal"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.spins_equal">[docs]</a><span class="k">def</span> <span class="nf">spins_equal</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">):</span> <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">s1</span><span class="p">)</span><span class="o">==</span><span class="nb">int</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">s2</span><span class="p">)</span></div>


<div class="viewcode-block" id="getResonanceReconstructionClass"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.getResonanceReconstructionClass">[docs]</a><span class="k">def</span> <span class="nf">getResonanceReconstructionClass</span><span class="p">(</span> <span class="n">formalism</span> <span class="p">):</span>
    <span class="k">if</span> <span class="n">formalism</span><span class="o">.</span><span class="n">moniker</span> <span class="o">==</span> <span class="n">resolvedModule</span><span class="o">.</span><span class="n">BreitWigner</span><span class="o">.</span><span class="n">moniker</span><span class="p">:</span>
        <span class="n">gndsClass</span> <span class="o">=</span> <span class="n">resolvedModule</span><span class="o">.</span><span class="n">BreitWigner</span>
        <span class="n">proc</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">gndsClass</span><span class="o">.</span><span class="n">Approximation</span><span class="o">.</span><span class="n">singleLevel</span><span class="p">:</span> <span class="n">SLBWcrossSection</span><span class="p">,</span>
            <span class="n">gndsClass</span><span class="o">.</span><span class="n">Approximation</span><span class="o">.</span><span class="n">multiLevel</span><span class="p">:</span> <span class="n">MLBWcrossSection</span>
        <span class="p">}[</span> <span class="n">formalism</span><span class="o">.</span><span class="n">approximation</span> <span class="p">]</span>
        <span class="k">return</span> <span class="n">proc</span>
    <span class="k">elif</span> <span class="n">formalism</span><span class="o">.</span><span class="n">moniker</span> <span class="o">==</span> <span class="n">resolvedModule</span><span class="o">.</span><span class="n">RMatrix</span><span class="o">.</span><span class="n">moniker</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">RMatrixLimitedcrossSection</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Don&#39;t recognize resonance type </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">formalism</span><span class="o">.</span><span class="n">moniker</span><span class="p">)</span></div>


<div class="viewcode-block" id="getAllowedTotalSpins"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.getAllowedTotalSpins">[docs]</a><span class="k">def</span> <span class="nf">getAllowedTotalSpins</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">useFactor2Trick</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of allowed J values from summing angular momenta L and S, where</span>
<span class="sd">    :math:`\\vec{J}=\\vec{L}+\\vec{S}`</span>
<span class="sd">    which implies :math:`|L-S| \\leq J \\leq L+S`</span>

<span class="sd">    The useFactor2Trick flag tells the routine whether we are summing real angular momenta or momenta * 2.</span>
<span class="sd">    If the useFactor2Trick flag is true, then momenta are really momenta*2, meaning they can be pure integers,</span>
<span class="sd">    even if the real momenta refer to 1/2-integer values (e.g. spin).  The default is to useFactor2Trick because</span>
<span class="sd">    most C/C++/Fortran codes that compute angular momentum-stuff use the trick so they can use integer math.</span>
<span class="sd">    Also, it makes the use of the Python range() function possible.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">useFactor2Trick</span><span class="p">:</span> <span class="k">return</span> <span class="nb">list</span><span class="p">(</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">abs</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S</span><span class="p">),</span> <span class="n">L</span><span class="o">+</span><span class="n">S</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="p">[</span> <span class="n">j</span><span class="o">/</span><span class="mf">2.0</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">getAllowedTotalSpins</span><span class="p">(</span> <span class="nb">int</span><span class="p">(</span><span class="n">L</span><span class="o">*</span><span class="mi">2</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">S</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span> <span class="p">]</span></div>


<div class="viewcode-block" id="reconstructResonances"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.reconstructResonances">[docs]</a><span class="k">def</span> <span class="nf">reconstructResonances</span><span class="p">(</span><span class="n">reactionSuite</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">significantDigits</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">disableUnresolvedWidthInterpolation</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reconstruct all resonance cross sections (resolved and unresolved) in reactionSuite,</span>
<span class="sd">    and add results together for full (resonance region) pointwise cross section.</span>

<span class="sd">    Optional arguments:</span>

<span class="sd">        - &#39;tolerance&#39;: fractional tolerance, used to refine interpolation grid.</span>
<span class="sd">          That is, if tolerance = 0.001, points are added until lin-lin interpolation is good to 0.1% everywhere.</span>

<span class="sd">        - &#39;verbose&#39;: print status messages during reconstruction</span>

<span class="sd">        - &#39;significantDigits&#39;: Controls how many digits can be used to represent the energy grid. For example,</span>
<span class="sd">          if significantDigits=4 the resulting energy grid can contain 1.034, 1.035, 1.036 but not 1.0345.</span>
<span class="sd">          Using significantDigits=8 should allow data to be written back to ENDF-6 without loss of precision.</span>

<span class="sd">        - &#39;disableUnresolvedWidthInterpolation&#39;: set &#39;True&#39; to reproduce old ENDF recommendation to interpolate</span>
<span class="sd">          in cross sections rather than widths. That recommendation was reversed before ENDF-VIII release</span>

<span class="sd">    Note that this does not add the background contribution if any (ENDF-MF3 portion).</span>
<span class="sd">    Use the method reactionSuite.reconstructResonances which adds the background contribution.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">energyUnit</span> <span class="o">=</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">domainUnit</span>
    <span class="n">egrids</span><span class="p">,</span> <span class="n">xsecs</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">resolvedReconstruct</span><span class="p">(</span> <span class="n">resolvedForm</span> <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function to reconstruct one region, used for single &amp; multiple regions as well as URR ensembles.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">resCls</span> <span class="o">=</span> <span class="n">getResonanceReconstructionClass</span><span class="p">(</span><span class="n">resolvedForm</span><span class="p">)</span>
        <span class="n">reconstructClass</span> <span class="o">=</span> <span class="n">resCls</span><span class="p">(</span> <span class="n">resolvedForm</span><span class="p">,</span> <span class="n">enableAngDists</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">energyUnit</span><span class="o">=</span><span class="n">energyUnit</span> <span class="p">)</span>
        <span class="n">egrid</span> <span class="o">=</span> <span class="n">reconstructClass</span><span class="o">.</span><span class="n">generateEnergyGrid</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">significantDigits</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">egrid</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span> <span class="nb">set</span><span class="p">(</span> <span class="n">RoundToSigFigs</span><span class="p">(</span><span class="n">egrid</span><span class="p">,</span><span class="n">significantDigits</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">xsecs_now</span> <span class="o">=</span> <span class="n">reconstructClass</span><span class="o">.</span><span class="n">getCrossSection</span><span class="p">(</span> <span class="n">egrid</span> <span class="p">)</span>
        <span class="n">egrid</span><span class="p">,</span> <span class="n">xsecs_now</span><span class="p">,</span> <span class="n">messages</span> <span class="o">=</span> <span class="n">reconstructClass</span><span class="o">.</span><span class="n">refineInterpolation</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">egrid</span><span class="p">),</span> <span class="n">xsecs_now</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span>
                <span class="n">significantDigits</span><span class="o">=</span><span class="n">significantDigits</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">message</span> <span class="ow">in</span> <span class="n">messages</span><span class="p">:</span> <span class="nb">print</span> <span class="p">(</span><span class="n">message</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">egrid</span><span class="p">,</span> <span class="n">xsecs_now</span>

    <span class="c1"># Resolved resonance reconstruction</span>
    <span class="k">if</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span><span class="p">:</span>
        <span class="c1"># For multiple regions, we need to do each region separately, then add them to the unified xs table &amp; egrid</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span><span class="o">.</span><span class="n">evaluated</span><span class="p">,</span> <span class="n">commonResonancesModule</span><span class="o">.</span><span class="n">EnergyIntervals</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;      WARNING! Multiple resolved/unresolved energy intervals are deprecated</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="o">+</span><span class="s2">&quot;        and should be consolidated into single section&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span><span class="o">.</span><span class="n">evaluated</span><span class="p">:</span>
                <span class="n">egrid_now</span><span class="p">,</span> <span class="n">xsecs_now</span> <span class="o">=</span> <span class="n">resolvedReconstruct</span><span class="p">(</span> <span class="n">interval</span><span class="o">.</span><span class="n">evaluated</span> <span class="p">)</span>
                <span class="c1"># merge with &#39;full&#39; energy grid:</span>
                <span class="n">egrids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">egrid_now</span> <span class="p">)</span>
                <span class="n">xsecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">xsecs_now</span> <span class="p">)</span>
        <span class="c1"># Single region, everything goes on unified grid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">resolvedForm</span> <span class="o">=</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span><span class="o">.</span><span class="n">evaluated</span>
            <span class="n">egrid_now</span><span class="p">,</span> <span class="n">xsecs_now</span> <span class="o">=</span> <span class="n">resolvedReconstruct</span><span class="p">(</span> <span class="n">resolvedForm</span> <span class="p">)</span>
            <span class="c1"># merge with &#39;full&#39; energy grid:</span>
            <span class="n">egrids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">egrid_now</span> <span class="p">)</span>
            <span class="n">xsecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">xsecs_now</span> <span class="p">)</span>

    <span class="c1"># Unresolved region has more complex logic, we may do one of a couple of things:</span>
    <span class="c1">#   a) do nothing</span>
    <span class="c1">#   b) reconstruct the average cross section assuming SLBW resonances (traditional ENDF)</span>
    <span class="c1">#   c) reconstruct the average xs and the PDF for the xs</span>
    <span class="k">if</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">unresolved</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">unresolved</span><span class="o">.</span><span class="n">evaluated</span><span class="o">.</span><span class="n">useForSelfShieldingOnly</span><span class="p">:</span> <span class="c1"># don&#39;t reconstruct</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Skipping unresolved: for self shielding only&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unresolvedForm</span> <span class="o">=</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">unresolved</span><span class="o">.</span><span class="n">evaluated</span>
            <span class="n">reconstructClass</span> <span class="o">=</span> <span class="n">URRcrossSection</span><span class="p">(</span> <span class="n">unresolvedForm</span><span class="p">,</span> <span class="n">verbose</span> <span class="p">)</span>
            <span class="n">egrid</span><span class="p">,</span> <span class="n">interpolateWidths</span> <span class="o">=</span> <span class="n">reconstructClass</span><span class="o">.</span><span class="n">generateEnergyGrid</span><span class="p">()</span>
            <span class="n">xsecs_now</span> <span class="o">=</span> <span class="n">reconstructClass</span><span class="o">.</span><span class="n">getCrossSection</span><span class="p">(</span> <span class="n">egrid</span> <span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">disableUnresolvedWidthInterpolation</span><span class="p">:</span>
                <span class="c1"># ENDF manual now states that we should interpolate cross sections rather than parameters for URR.</span>
                <span class="n">egrid</span><span class="p">,</span> <span class="n">xsecs_now</span><span class="p">,</span> <span class="n">messages</span> <span class="o">=</span> <span class="n">reconstructClass</span><span class="o">.</span><span class="n">refineInterpolation</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">egrid</span><span class="p">),</span> <span class="n">xsecs_now</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">message</span> <span class="ow">in</span> <span class="n">messages</span><span class="p">:</span> <span class="nb">print</span> <span class="p">(</span><span class="n">message</span><span class="p">)</span>

            <span class="c1"># meld with resolved region:</span>
            <span class="n">egrids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">egrid</span> <span class="p">)</span>
            <span class="n">xsecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">xsecs_now</span> <span class="p">)</span>

    <span class="c1"># &#39;xsecs&#39; list now holds one or more regions. Convert to pointwise or Regions1d cross section instance:</span>
    <span class="n">xsecs_final</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">crossSectionAxes</span> <span class="o">=</span> <span class="n">crossSectionModule</span><span class="o">.</span><span class="n">defaultAxes</span><span class="p">(</span> <span class="n">energyUnit</span> <span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xsecs</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>   <span class="c1"># only one region: treat as XYs1d</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">xsecs</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">xsecs_final</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">crossSectionModule</span><span class="o">.</span><span class="n">XYs1d</span><span class="p">(</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">crossSectionAxes</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="n">egrids</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xsecs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">key</span><span class="p">]),</span> <span class="n">dataForm</span><span class="o">=</span><span class="s2">&quot;XsAndYs&quot;</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>               <span class="c1"># multiple regions: treat as Regions1d</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">xsecs</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">pwxs</span> <span class="o">=</span> <span class="n">crossSectionModule</span><span class="o">.</span><span class="n">Regions1d</span><span class="p">(</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">crossSectionAxes</span> <span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xsecs</span><span class="p">)):</span>
                <span class="n">xys</span> <span class="o">=</span> <span class="n">crossSectionModule</span><span class="o">.</span><span class="n">XYs1d</span><span class="p">(</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">crossSectionAxes</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="n">egrids</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">xsecs</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">key</span><span class="p">]),</span> <span class="n">dataForm</span><span class="o">=</span><span class="s2">&quot;XsAndYs&quot;</span> <span class="p">)</span>
                <span class="n">pwxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">xys</span> <span class="p">)</span>
            <span class="n">xsecs_final</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">pwxs</span>

    <span class="k">return</span> <span class="n">xsecs_final</span></div>

<div class="viewcode-block" id="reconstructAngularDistributions"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.reconstructAngularDistributions">[docs]</a><span class="k">def</span> <span class="nf">reconstructAngularDistributions</span><span class="p">(</span><span class="n">reactionSuite</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reconstruct all pure two-body angular distributions from the resonance region.</span>
<span class="sd">    For MLBW and RM, that means &#39;elastic&#39; channel only, but R-Matrix evaluations can support additional channels.</span>
<span class="sd">    SLBW cannot be used for angular distributions.</span>

<span class="sd">    Returns a Python dict.  They key is the reaction and the value is a reconstructed</span>
<span class="sd">    angularModule.XYs2d instance containing Legendre expansions for each incident energy.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">energyUnit</span> <span class="o">=</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">domainUnit</span>
    <span class="n">angdists</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">angdistRegions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">egrids</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Helper function to compute the per-region angular distributions</span>
    <span class="k">def</span> <span class="nf">resolvedReconstruct</span><span class="p">(</span> <span class="n">resolvedForm</span> <span class="p">):</span>

        <span class="c1"># Get the correct class</span>
        <span class="n">resCls</span> <span class="o">=</span> <span class="n">getResonanceReconstructionClass</span><span class="p">(</span><span class="n">resolvedForm</span><span class="p">)</span>
        <span class="n">reconstructClass</span> <span class="o">=</span> <span class="n">resCls</span><span class="p">(</span> <span class="n">resolvedForm</span><span class="p">,</span> <span class="n">enableAngDists</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">energyUnit</span><span class="o">=</span><span class="n">energyUnit</span> <span class="p">)</span>

        <span class="c1"># Deal with potential thresholds by splitting up the energy grid at the thresholds</span>
        <span class="n">fullEgrid</span> <span class="o">=</span> <span class="n">reconstructClass</span><span class="o">.</span><span class="n">generateEnergyGrid</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">reconstructClass</span><span class="p">,</span><span class="s1">&#39;_thresholds&#39;</span><span class="p">):</span>
            <span class="n">thresholdIndices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">Xi</span> <span class="ow">in</span> <span class="n">reconstructClass</span><span class="o">.</span><span class="n">_thresholds</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">Xi</span> <span class="ow">in</span> <span class="n">fullEgrid</span><span class="p">:</span>
                    <span class="n">thresholdIndices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">fullEgrid</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">Xi</span><span class="p">))</span>
            <span class="n">thresholdIndices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">subgrids</span> <span class="o">=</span> <span class="p">[</span><span class="n">fullEgrid</span><span class="p">[</span><span class="n">thresholdIndices</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">thresholdIndices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">thresholdIndices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))]</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">subgrids</span><span class="o">=</span><span class="p">[</span><span class="n">fullEgrid</span><span class="p">]</span>

        <span class="c1"># Now do the calculation &amp; merge the different regions</span>
        <span class="n">angularResults</span><span class="o">=</span><span class="p">{}</span>
        <span class="k">for</span> <span class="n">egrid</span> <span class="ow">in</span> <span class="n">subgrids</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Working egrid: [</span><span class="si">%s</span><span class="s2">, ..., </span><span class="si">%s</span><span class="s2">]&quot;</span><span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">egrid</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">str</span><span class="p">(</span><span class="n">egrid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>
            <span class="n">thisAngularResults</span> <span class="o">=</span> <span class="n">reconstructClass</span><span class="o">.</span><span class="n">getAngularDistribution</span><span class="p">(</span> <span class="n">egrid</span><span class="p">,</span> <span class="n">keepL0Term</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">renormalize</span><span class="o">=</span><span class="kc">True</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">tolerance</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Refining interpolation grid for angular distributions&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">reaction</span><span class="p">,</span> <span class="n">results</span> <span class="ow">in</span> <span class="n">thisAngularResults</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">reaction</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">angularResults</span><span class="p">:</span> <span class="n">angularResults</span><span class="p">[</span><span class="n">reaction</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">angularResults</span><span class="p">[</span><span class="n">reaction</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span> <span class="nb">zip</span><span class="p">(</span> <span class="n">egrid</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">results</span> <span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">angularResults</span>

    <span class="k">if</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span><span class="p">:</span>

        <span class="c1"># Compute the per-region angular distributions &amp; make a list of regional distributions</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span><span class="o">.</span><span class="n">evaluated</span><span class="p">,</span> <span class="n">commonResonancesModule</span><span class="o">.</span><span class="n">EnergyIntervals</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Angular reconstruction for multiple resolved regions, untested&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;      WARNING! Multiple resolved/unresolved energy regions are deprecated</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="o">+</span><span class="s2">&quot;        and should be consolidated into single section&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">RRidx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span><span class="o">.</span><span class="n">regions</span><span class="p">)):</span>
                <span class="n">formalism</span> <span class="o">=</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span><span class="o">.</span><span class="n">regions</span><span class="p">[</span><span class="n">RRidx</span><span class="p">]</span><span class="o">.</span><span class="n">evaluated</span>
                <span class="n">angdistRegions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">resolvedReconstruct</span><span class="p">(</span> <span class="n">formalism</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">formalism</span> <span class="o">=</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">resonances</span><span class="o">.</span><span class="n">resolved</span><span class="o">.</span><span class="n">evaluated</span>
            <span class="n">angdistRegions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">resolvedReconstruct</span><span class="p">(</span> <span class="n">formalism</span> <span class="p">)</span> <span class="p">)</span>

        <span class="c1"># Check that egrids don&#39;t overlap</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">angdistRegions</span> <span class="p">)</span> <span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">iRegion</span><span class="p">,</span> <span class="n">this_region</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">angdistRegions</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">next_region</span> <span class="o">=</span> <span class="n">angdistRegions</span><span class="p">[</span><span class="n">iRegion</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">this_region</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">next_region</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s2">&quot;this_region[-1][0] &gt; next_region[0][0] for region </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">iRegion</span> <span class="p">)</span>

        <span class="c1"># &#39;angdistRegions&#39; list holds one or more regions.  Convert to one Legendre coefficient table</span>
        <span class="c1"># right now only do elastic scattering (OK for MLBW &amp; RM, but (unimplemented) RML can do more)</span>
        <span class="n">angdists_final</span><span class="o">=</span><span class="p">{}</span>
        <span class="n">angularAxes</span> <span class="o">=</span> <span class="n">angularModule</span><span class="o">.</span><span class="n">defaultAxes</span><span class="p">(</span><span class="n">energyUnit</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">angdistRegions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>    <span class="c1"># only one region, treat as XYs2d</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">angdistRegions</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">form</span> <span class="o">=</span> <span class="n">angularModule</span><span class="o">.</span><span class="n">XYs2d</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">angularAxes</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i1</span><span class="p">,</span> <span class="n">E_Bs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">angdistRegions</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">key</span><span class="p">]):</span>
                    <span class="n">form</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">angularModule</span><span class="o">.</span><span class="n">Legendre</span><span class="p">(</span><span class="n">coefficients</span><span class="o">=</span><span class="n">E_Bs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">outerDomainValue</span><span class="o">=</span><span class="n">E_Bs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axes</span><span class="o">=</span><span class="n">angularAxes</span><span class="p">))</span>
                <span class="n">angdists_final</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">form</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Still TBD&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">angdists_final</span></div>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">@blockwise: function decorator for improving performance in resolved region.</span>
<span class="sd">Each &#39;getCrossSection&#39; and &#39;getAngularDistribution&#39; method is wrapped by this function.</span>
<span class="sd">If we have lots of incident energies, this splits up a calculation using the multiprocessing module.</span>
<span class="sd">May need to tweak the &#39;NEmax&#39; and &#39;numTasks&#39; variables for best performance.</span>
<span class="sd">&quot;&quot;&quot;</span>
<div class="viewcode-block" id="blockwise"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.blockwise">[docs]</a><span class="k">def</span> <span class="nf">blockwise</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
    <span class="n">NEmax</span> <span class="o">=</span> <span class="mi">1000</span>
    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">E</span><span class="p">):</span>
            <span class="n">NE</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">E</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">NE</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">NE</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span> <span class="c1"># disable multiprocessing</span>
            <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">NE</span> <span class="o">&lt;</span> <span class="n">NEmax</span><span class="p">:</span> <span class="c1"># faster to run directly</span>
            <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Queue</span>
            <span class="n">queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>

            <span class="k">def</span> <span class="nf">enqueue_result</span><span class="p">(</span><span class="n">elist</span><span class="p">,</span> <span class="n">Slice</span><span class="p">,</span> <span class="n">queue</span><span class="p">):</span>
                <span class="c1"># perform the calculation, put result in the queue</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elist</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span> <span class="p">(</span><span class="n">Slice</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span> <span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span> <span class="p">(</span><span class="n">Slice</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span> <span class="p">)</span>

            <span class="n">jobs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="kn">from</span> <span class="nn">fudge.defaults</span> <span class="kn">import</span> <span class="n">numTasks</span> <span class="c1"># number of processes to spawn</span>
            <span class="n">errorsEncountered</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># how many energies does each process calculate?</span>
            <span class="n">chunk</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">NE</span><span class="o">+</span><span class="mf">0.</span><span class="p">)</span> <span class="o">/</span> <span class="n">numTasks</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">pid</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numTasks</span><span class="p">):</span> <span class="c1"># start the calculations</span>
                <span class="n">Slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">pid</span><span class="o">*</span><span class="n">chunk</span><span class="p">,</span> <span class="p">(</span><span class="n">pid</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">chunk</span><span class="p">)</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">enqueue_result</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">Slice</span><span class="p">],</span> <span class="n">Slice</span><span class="p">,</span> <span class="n">queue</span><span class="p">))</span>
                <span class="n">jobs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">pid</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numTasks</span><span class="p">):</span> <span class="c1"># collect results as they finish</span>
                <span class="n">Slice</span><span class="p">,</span> <span class="n">vals</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in child process #</span><span class="si">%d</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">pid</span><span class="p">,</span><span class="n">vals</span><span class="p">))</span>
                    <span class="n">errorsEncountered</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">function</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;getCrossSection&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span> <span class="n">vals</span> <span class="p">)</span>
                        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span> <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">NE</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                        <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">Slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">function</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;getAngularDistribution&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span> <span class="n">vals</span> <span class="p">)</span>
                        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span> <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NE</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">key</span><span class="p">]))]</span>
                    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="n">key</span><span class="p">])):</span>
                            <span class="n">result</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">L</span><span class="p">][</span><span class="n">Slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">L</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Blockwise computation for function </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">function</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

            <span class="c1"># allow child processes to exit:</span>
            <span class="k">for</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">jobs</span><span class="p">:</span> <span class="n">job</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">errorsEncountered</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Aborting due to errors in child processes&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">wrapped</span></div>


<div class="viewcode-block" id="ResonanceReconstructionBaseClass"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.ResonanceReconstructionBaseClass">[docs]</a><span class="k">class</span> <span class="nc">ResonanceReconstructionBaseClass</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class common to resolved and unresolved resonance reconstruction.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">resonanceForm</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span> <span class="p">)</span> <span class="p">:</span>

        <span class="n">reactionSuite</span> <span class="o">=</span> <span class="n">resonanceForm</span><span class="o">.</span><span class="n">findClassInAncestry</span><span class="p">(</span><span class="n">reactionSuiteModule</span><span class="o">.</span><span class="n">ReactionSuite</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">neutron</span> <span class="o">=</span> <span class="n">resonanceForm</span><span class="o">.</span><span class="n">PoPs</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">neutronMass_amu</span> <span class="o">=</span> <span class="n">neutron</span><span class="o">.</span><span class="n">getMass</span><span class="p">(</span><span class="s1">&#39;amu&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">neutronMass_amu</span> <span class="o">=</span> <span class="mf">1.00866491574</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span> <span class="o">=</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">domainUnit</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">projectile</span> <span class="o">=</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">projectile</span>
        <span class="n">projectile</span> <span class="o">=</span> <span class="n">resonanceForm</span><span class="o">.</span><span class="n">PoPs</span><span class="p">[</span><span class="n">reactionSuite</span><span class="o">.</span><span class="n">projectile</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">projectileMass_amu</span> <span class="o">=</span> <span class="n">projectile</span><span class="o">.</span><span class="n">getMass</span><span class="p">(</span><span class="s1">&#39;amu&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">projectile</span><span class="p">,</span> <span class="n">nuclidePoPsModule</span><span class="o">.</span><span class="n">Particle</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">projectileSpin</span> <span class="o">=</span> <span class="n">projectile</span><span class="o">.</span><span class="n">nucleus</span><span class="o">.</span><span class="n">spin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">projectileSpin</span> <span class="o">=</span> <span class="n">projectile</span><span class="o">.</span><span class="n">spin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>

        <span class="n">targetID</span> <span class="o">=</span> <span class="n">reactionSuite</span><span class="o">.</span><span class="n">target</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">resonanceForm</span><span class="o">.</span><span class="n">PoPs</span><span class="o">.</span><span class="n">hasAlias</span><span class="p">(</span> <span class="n">targetID</span> <span class="p">)</span> <span class="p">)</span> <span class="p">:</span> <span class="n">targetID</span> <span class="o">=</span> <span class="n">resonanceForm</span><span class="o">.</span><span class="n">PoPs</span><span class="p">[</span><span class="n">targetID</span><span class="p">]</span><span class="o">.</span><span class="n">pid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">targetID</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">resonanceForm</span><span class="o">.</span><span class="n">PoPs</span><span class="p">[</span><span class="n">targetID</span><span class="p">]</span>
        <span class="k">if</span><span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">target</span><span class="p">,</span> <span class="n">nuclidePoPsModule</span><span class="o">.</span><span class="n">Particle</span> <span class="p">)</span> <span class="p">)</span> <span class="p">:</span>
            <span class="n">nuclide</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">ancestor</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">targetMass_amu</span> <span class="o">=</span> <span class="n">nuclide</span><span class="o">.</span><span class="n">getMass</span><span class="p">(</span><span class="s1">&#39;amu&#39;</span><span class="p">)</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">targetMass_amu</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">getMass</span><span class="p">(</span><span class="s1">&#39;amu&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targetSpin</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">nucleus</span><span class="o">.</span><span class="n">spin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">targetToNeutronMassRatio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetMass_amu</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">neutronMass_amu</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">kConstant1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">PQUModule</span><span class="o">.</span><span class="n">PQU</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">projectileMass_amu</span><span class="p">,</span> <span class="s1">&#39;amu * c**2&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kConstant1</span> <span class="o">/=</span> <span class="n">PQUModule</span><span class="o">.</span><span class="n">PQU</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;hbar * c&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> * 1e-14 * m&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">)</span>   <span class="c1"># 1e-14 m is sqrt(b).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kConstant2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kConstant1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetMass_amu</span> <span class="o">/</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">projectileMass_amu</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetMass_amu</span> <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">energyFactor</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">PQUModule</span><span class="o">.</span><span class="n">PQU</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">)</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;eV&#39;</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">reactionSuite</span> <span class="o">=</span> <span class="n">reactionSuite</span>

<div class="viewcode-block" id="ResonanceReconstructionBaseClass.getCrossSection"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.ResonanceReconstructionBaseClass.getCrossSection">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">getCrossSection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span> <span class="k">pass</span></div>

<div class="viewcode-block" id="ResonanceReconstructionBaseClass.k"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.ResonanceReconstructionBaseClass.k">[docs]</a>    <span class="k">def</span> <span class="nf">k</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">energy</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the wave number for the projectile in the center of mass given the projectile energy in the lab frame.</span>
<span class="sd">        The returned value is in b**-1/2.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">kConstant2</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot; refer to SAMMY manual page 9 for penetration/shift/phase factor equations: &quot;&quot;&quot;</span>
<div class="viewcode-block" id="ResonanceReconstructionBaseClass.penetrationFactor"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.ResonanceReconstructionBaseClass.penetrationFactor">[docs]</a>    <span class="k">def</span> <span class="nf">penetrationFactor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">rho</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">L</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">rho</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="n">rho</span><span class="o">**</span><span class="mi">3</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="k">return</span> <span class="n">rho</span><span class="o">**</span><span class="mi">5</span> <span class="o">/</span> <span class="p">(</span><span class="mi">9</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">rho</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span> <span class="k">return</span> <span class="n">rho</span><span class="o">**</span><span class="mi">7</span> <span class="o">/</span> <span class="p">(</span><span class="mi">225</span><span class="o">+</span><span class="mi">45</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">6</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">4</span><span class="o">+</span><span class="n">rho</span><span class="o">**</span><span class="mi">6</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span> <span class="k">return</span> <span class="n">rho</span><span class="o">**</span><span class="mi">9</span> <span class="o">/</span> <span class="p">(</span><span class="mi">11025</span><span class="o">+</span><span class="mi">1575</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">135</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">4</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">6</span><span class="o">+</span><span class="n">rho</span><span class="o">**</span><span class="mi">8</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">:</span>
            <span class="c1"># find it recursively</span>
            <span class="n">P_Lminus1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span>
            <span class="n">S_Lminus1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shiftFactor</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rho</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">P_Lminus1</span> <span class="o">/</span> <span class="p">((</span><span class="n">L</span><span class="o">-</span><span class="n">S_Lminus1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">P_Lminus1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="ResonanceReconstructionBaseClass.shiftFactor"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.ResonanceReconstructionBaseClass.shiftFactor">[docs]</a>    <span class="k">def</span> <span class="nf">shiftFactor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">rho</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; calculate shift factor used in SLBW and MLBW formalisms &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">L</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="mf">0.0</span><span class="o">*</span><span class="n">rho</span>   <span class="c1"># rho may be an array</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="k">return</span> <span class="o">-</span><span class="p">(</span><span class="mf">18.0</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">9</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">rho</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span> <span class="k">return</span> <span class="o">-</span><span class="p">(</span><span class="mf">675.0</span><span class="o">+</span><span class="mi">90</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">6</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">225</span><span class="o">+</span><span class="mi">45</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">6</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">4</span><span class="o">+</span><span class="n">rho</span><span class="o">**</span><span class="mi">6</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span> <span class="k">return</span> <span class="o">-</span><span class="p">(</span> <span class="p">(</span><span class="mf">44100.0</span><span class="o">+</span><span class="mi">4725</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">270</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">4</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">6</span><span class="p">)</span> <span class="o">/</span>
                <span class="p">(</span><span class="mi">11025</span><span class="o">+</span><span class="mi">1575</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">135</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">4</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">6</span><span class="o">+</span><span class="n">rho</span><span class="o">**</span><span class="mi">8</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">:</span>
            <span class="n">P_Lminus1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span>
            <span class="n">S_Lminus1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shiftFactor</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S_Lminus1</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="n">L</span><span class="o">-</span><span class="n">S_Lminus1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">P_Lminus1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">L</span><span class="p">)</span></div>

<div class="viewcode-block" id="ResonanceReconstructionBaseClass.phi"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.ResonanceReconstructionBaseClass.phi">[docs]</a>    <span class="k">def</span> <span class="nf">phi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">rho</span><span class="p">):</span>
        <span class="c1"># calculate hard-sphere phase-shift</span>
        <span class="k">if</span>   <span class="n">L</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">rho</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="n">rho</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="k">return</span> <span class="n">rho</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">rho</span><span class="o">/</span><span class="p">(</span><span class="mi">3</span><span class="o">-</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span> <span class="k">return</span> <span class="n">rho</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="mi">15</span><span class="o">-</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">15</span><span class="o">-</span><span class="mi">6</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span> <span class="k">return</span> <span class="n">rho</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">rho</span><span class="o">*</span><span class="p">(</span><span class="mi">105</span><span class="o">-</span><span class="mi">10</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">105</span><span class="o">-</span><span class="mi">45</span><span class="o">*</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">rho</span><span class="o">**</span><span class="mi">4</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">L</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">:</span>
            <span class="n">P_Lminus1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span>
            <span class="n">S_Lminus1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shiftFactor</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span>
            <span class="n">phi_Lminus1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">phi_Lminus1</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">P_Lminus1</span> <span class="o">/</span> <span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S_Lminus1</span><span class="p">))</span></div>

    <span class="c1"># for use after the cross section has been calculated on the initial grid:</span>
<div class="viewcode-block" id="ResonanceReconstructionBaseClass.refineInterpolation"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.ResonanceReconstructionBaseClass.refineInterpolation">[docs]</a>    <span class="k">def</span> <span class="nf">refineInterpolation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">egrid</span><span class="p">,</span> <span class="n">xsecs</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">significantDigits</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; generateEnergyGrid may not give a fine enough grid to linearly interpolate to desired tolerance.</span>
<span class="sd">        My solution to that: for all consecutive points (x0,y0), (x1,y1) and (x2,y2) do a linear interpolation between</span>
<span class="sd">        (x0,y0) and (x2,y2). If the interpolation doesn&#39;t agree with (x1,y1) within tolerance,</span>
<span class="sd">        subdivide up the region by adding two more calculated points.  Iterate until interpolation agrees within tolerance.</span>

<span class="sd">        This means that in the end we will have more points than required for given tolerance.</span>
<span class="sd">        The results can be thinned (thinning implemented in xData.XYs1d)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">checkInterpolation</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Does a linear interpolation of each point from its two nearest neighbors,</span>
<span class="sd">            checks where the interpolation grid is insufficient and returns a list of indices (in array x)</span>
<span class="sd">            where additional points are needed.</span>

<span class="sd">            @type x: numpy.multiarray.ndarray</span>
<span class="sd">            @type y: numpy.multiarray.ndarray</span>
<span class="sd">            :return:</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">-</span><span class="n">y</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">-</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">delta_x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>

            <span class="c1"># add first and last points back in, for easier comparison with</span>
            <span class="c1"># original y values:</span>
            <span class="n">interpolated</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">interpolated</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="o">*</span><span class="n">delta_x</span><span class="o">+</span><span class="n">b</span>
            <span class="n">interpolated</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">interpolated</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># find where original and interpolated grids differ by more than tolerance</span>
            <span class="c1"># silence div/0 warnings for this step, since xsc = 0 case is explicitly handled below</span>
            <span class="k">with</span> <span class="n">numpy</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span> <span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span> <span class="p">):</span>
                <span class="n">delt</span> <span class="o">=</span> <span class="n">interpolated</span> <span class="o">/</span> <span class="n">y</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">delt</span><span class="o">&gt;</span><span class="mi">1</span><span class="o">+</span><span class="n">tolerance</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">delt</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">-</span><span class="n">tolerance</span><span class="p">)</span> <span class="c1"># boolean array</span>

            <span class="n">badindices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">))[</span> <span class="n">mask</span> <span class="p">]</span>    <span class="c1"># points where finer mesh is needed</span>

            <span class="c1"># switch to absolute convergence condition for very small cross sections (i.e. near thresholds):</span>
            <span class="n">smallXSec</span> <span class="o">=</span> <span class="mf">1e-50</span>
            <span class="n">zeros</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">badindices</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="n">smallXSec</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">badindices</span><span class="p">]</span><span class="o">&lt;</span><span class="n">smallXSec</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">badindices</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="n">smallXSec</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">zeros</span><span class="p">):</span>
                <span class="n">ignore</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">badindices</span><span class="p">[</span> <span class="n">zeros</span> <span class="p">]:</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">&lt;</span><span class="mf">1e-3</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span><span class="o">&lt;</span><span class="mf">1e-3</span><span class="p">:</span>
                        <span class="n">mask</span><span class="p">[</span> <span class="n">idx</span> <span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="n">ignore</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">idx</span> <span class="p">)</span>
                <span class="n">badindices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">badindices</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">ignore</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">badindices</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">badindices</span>

        <span class="n">messages</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">reactionDone</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">xsecs</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">n_iter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">addedPoints</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">newIdx</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">xsecs</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">xsecs</span><span class="p">[</span><span class="n">key</span><span class="p">]):</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">reactionDone</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                    <span class="n">badindices</span> <span class="o">=</span> <span class="n">checkInterpolation</span><span class="p">(</span><span class="n">egrid</span><span class="p">,</span><span class="n">xsecs</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">badindices</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="n">reactionDone</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">newIdx</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="n">badindices</span> <span class="p">)</span>
            <span class="n">newIdx</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">newIdx</span><span class="p">)</span>

            <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">egrid</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span> <span class="p">)</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">newIdx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">midpoints</span> <span class="o">=</span> <span class="p">(</span><span class="n">egrid</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">egrid</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span><span class="o">/</span><span class="mi">2</span>

            <span class="n">energies_needed</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span> <span class="nb">set</span><span class="p">(</span> <span class="nb">list</span><span class="p">(</span><span class="n">midpoints</span><span class="p">[</span><span class="n">mask</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">midpoints</span><span class="p">[</span><span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span> <span class="p">)</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">significantDigits</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">rounded</span> <span class="o">=</span> <span class="n">RoundToSigFigs</span><span class="p">(</span> <span class="n">energies_needed</span><span class="p">,</span> <span class="n">significantDigits</span> <span class="p">)</span>
                <span class="n">rounded</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span> <span class="n">rounded</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="p">)</span>
                <span class="n">rounded</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span> <span class="n">egrid</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="p">)</span> <span class="c1"># remove any rounded values that were already computed</span>
                <span class="n">energies_needed</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span> <span class="n">rounded</span> <span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">energies_needed</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>    <span class="c1"># success!</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">n_iter</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">:</span>
                <span class="n">messages</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Iteration limit exceeded when refining interpolation grid!&quot;</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="n">n_iter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;Iteration #</span><span class="si">%d</span><span class="s2">: adding </span><span class="si">%d</span><span class="s2"> points to interpolation grid&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n_iter</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">energies_needed</span><span class="p">))</span> <span class="p">)</span>
            <span class="n">addedPoints</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">energies_needed</span><span class="p">)</span>
            <span class="n">newY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getCrossSection</span><span class="p">(</span> <span class="n">energies_needed</span> <span class="p">)</span>
            <span class="c1"># merge new x/y values with original list:</span>
            <span class="n">fulllist</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">egrid</span><span class="p">,</span> <span class="n">energies_needed</span> <span class="p">)</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span> <span class="n">fulllist</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;merged&#39;</span> <span class="p">)</span>
            <span class="n">egrid</span> <span class="o">=</span> <span class="n">fulllist</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">xsecs</span><span class="p">:</span>
                <span class="n">xsecs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">xsecs</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">newY</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">)[</span> <span class="n">order</span> <span class="p">]</span>

        <span class="n">messages</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%i</span><span class="s2"> points were added (for total of </span><span class="si">%i</span><span class="s2">) to achieve tolerance of </span><span class="si">%s%%</span><span class="s2">&quot;</span> <span class="o">%</span>
            <span class="p">(</span><span class="n">addedPoints</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">egrid</span><span class="p">),</span> <span class="n">tolerance</span><span class="o">*</span><span class="mi">100</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">egrid</span><span class="p">,</span> <span class="n">xsecs</span><span class="p">,</span> <span class="n">messages</span></div></div>


<span class="c1">#### base class for resolved resonance reconstruction ####</span>
<div class="viewcode-block" id="RRBaseClass"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass">[docs]</a><span class="k">class</span> <span class="nc">RRBaseClass</span><span class="p">(</span><span class="n">ResonanceReconstructionBaseClass</span><span class="p">,</span> <span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resolvedForm</span><span class="p">,</span> <span class="n">lowerBound</span><span class="p">,</span> <span class="n">upperBound</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>

        <span class="n">ResonanceReconstructionBaseClass</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resolvedForm</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; store resonance parameters in convenient structure for quick cross section calculations: &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">RR</span> <span class="o">=</span> <span class="n">resolvedForm</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span> <span class="o">=</span> <span class="n">lowerBound</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span> <span class="o">=</span> <span class="n">upperBound</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">removeNegatives</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># set to False to allow returning negative cross section values</span>

<div class="viewcode-block" id="RRBaseClass.sortLandJ"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.sortLandJ">[docs]</a>    <span class="k">def</span> <span class="nf">sortLandJ</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SLBW, MLBW and Reich_Moore formalisms have similar structure</span>
<span class="sd">        it&#39;s convenient to sort their resonances by L and J</span>
<span class="sd">        This method should NOT be used for R-Matrix Limited</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># make a unified table of resonance parameter data, convert to self.energyUnit if necessary</span>
        <span class="n">nRes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span> <span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">,</span><span class="s1">&#39;L&#39;</span><span class="p">,</span><span class="s1">&#39;J&#39;</span><span class="p">,</span><span class="s1">&#39;channelSpin&#39;</span><span class="p">,</span><span class="s1">&#39;totalWidth&#39;</span><span class="p">,</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">,</span><span class="s1">&#39;captureWidth&#39;</span><span class="p">,</span>
                <span class="s1">&#39;fissionWidth&#39;</span><span class="p">,</span><span class="s1">&#39;fissionWidthB&#39;</span><span class="p">)</span>
        <span class="n">EU</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span>
        <span class="n">units</span> <span class="o">=</span> <span class="p">(</span><span class="n">EU</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="n">EU</span><span class="p">,</span><span class="n">EU</span><span class="p">,</span><span class="n">EU</span><span class="p">,</span><span class="n">EU</span><span class="p">,</span><span class="n">EU</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span> <span class="n">quant</span><span class="p">,</span><span class="n">unit</span> <span class="p">)</span> <span class="k">for</span> <span class="n">quant</span><span class="p">,</span><span class="n">unit</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="n">units</span><span class="p">)</span> <span class="p">]</span>
        <span class="n">missingColumns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">,</span><span class="s1">&#39;L&#39;</span><span class="p">,</span><span class="s1">&#39;J&#39;</span><span class="p">,</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">,</span><span class="s1">&#39;captureWidth&#39;</span><span class="p">):</span>
                    <span class="n">missingColumns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">nRes</span>
        <span class="k">if</span> <span class="n">missingColumns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Required columns </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">missingColumns</span><span class="p">)</span><span class="si">}</span><span class="s2"> missing from BreitWigner parameters table!&quot;</span><span class="p">)</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">data</span> <span class="p">)</span>

        <span class="c1"># sort resonances by L and J, store parameters in numpy arrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ls</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">Llist</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;L&#39;</span><span class="p">)</span> <span class="p">]</span>
        <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span> <span class="n">Llist</span> <span class="p">))</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">Lres</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span> <span class="p">:,</span> <span class="n">table</span><span class="p">[</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;L&#39;</span><span class="p">)</span> <span class="p">]</span><span class="o">==</span><span class="n">L</span> <span class="p">]</span>
            <span class="n">Jlist</span> <span class="o">=</span> <span class="n">Lres</span><span class="p">[</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;J&#39;</span><span class="p">)</span> <span class="p">]</span>
            <span class="n">Js</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">J</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">Jlist</span><span class="p">)):</span>
                <span class="n">LJres</span> <span class="o">=</span> <span class="n">Lres</span><span class="p">[</span> <span class="p">:,</span> <span class="n">Lres</span><span class="p">[</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;J&#39;</span><span class="p">)</span> <span class="p">]</span><span class="o">==</span><span class="n">J</span> <span class="p">]</span>
                <span class="n">spinList</span> <span class="o">=</span> <span class="n">LJres</span><span class="p">[</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;channelSpin&#39;</span><span class="p">)</span> <span class="p">]</span>
                <span class="n">spins</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">spin</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">spinList</span><span class="p">)):</span>
                    <span class="n">spinRes</span> <span class="o">=</span> <span class="n">LJres</span><span class="p">[</span> <span class="p">:,</span> <span class="n">LJres</span><span class="p">[</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;channelSpin&#39;</span><span class="p">)</span> <span class="p">]</span><span class="o">==</span><span class="n">spin</span> <span class="p">]</span>
                    <span class="n">energies</span> <span class="o">=</span> <span class="n">spinRes</span><span class="p">[</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span> <span class="p">]</span>
                    <span class="n">neutronWidth</span> <span class="o">=</span> <span class="p">(</span> <span class="n">spinRes</span><span class="p">[</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">)</span> <span class="p">]</span> <span class="o">/</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">energies</span><span class="p">)))</span> <span class="p">)</span>
                    <span class="c1"># FIXME for easier-to-read code, should I wait until getCrossSection</span>
                    <span class="c1"># to adjust the neutronWidth for penetrability at resonances?</span>

                    <span class="n">spindict</span> <span class="o">=</span> <span class="p">{</span>
                            <span class="s1">&#39;channelSpin&#39;</span><span class="p">:</span> <span class="n">spin</span><span class="p">,</span>
                            <span class="s1">&#39;energy&#39;</span><span class="p">:</span> <span class="n">energies</span><span class="p">,</span>
                            <span class="s1">&#39;neutronWidth&#39;</span><span class="p">:</span> <span class="n">neutronWidth</span><span class="p">,</span>
                            <span class="s1">&#39;captureWidth&#39;</span><span class="p">:</span> <span class="n">spinRes</span><span class="p">[</span><span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;captureWidth&#39;</span><span class="p">)],</span>
                            <span class="s1">&#39;fissionWidth&#39;</span><span class="p">:</span> <span class="n">spinRes</span><span class="p">[</span><span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;fissionWidth&#39;</span><span class="p">)],</span>
                            <span class="s1">&#39;fissionWidthB&#39;</span><span class="p">:</span> <span class="n">spinRes</span><span class="p">[</span><span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;fissionWidthB&#39;</span><span class="p">)],</span>
                            <span class="s1">&#39;shiftFactor&#39;</span><span class="p">:</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">shiftFactor</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">energies</span><span class="p">))),</span>
                            <span class="p">}</span>
                    <span class="n">spins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">spindict</span> <span class="p">)</span>
                <span class="n">Jdict</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s1">&#39;J&#39;</span><span class="p">:</span> <span class="n">J</span><span class="p">,</span>
                        <span class="s1">&#39;gfact&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">projectileSpin</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">targetSpin</span><span class="o">+</span><span class="mi">1</span><span class="p">)),</span>
                        <span class="s1">&#39;channelSpins&#39;</span><span class="p">:</span> <span class="n">spins</span><span class="p">,</span>
                        <span class="p">}</span>
                <span class="n">Js</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">Jdict</span> <span class="p">)</span>

            <span class="n">Ldict</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;L&#39;</span><span class="p">:</span> <span class="n">L</span><span class="p">,</span> <span class="s1">&#39;Js&#39;</span><span class="p">:</span> <span class="n">Js</span> <span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Ls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">Ldict</span> <span class="p">)</span>

        <span class="c1"># for each L, gfactors should sum to 2*L+1.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missingGfactor</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ls</span><span class="p">:</span>
            <span class="n">gsum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span> <span class="p">[</span><span class="n">J</span><span class="p">[</span><span class="s1">&#39;gfact&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">J</span><span class="p">[</span><span class="s1">&#39;channelSpins&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">J</span> <span class="ow">in</span> <span class="n">L</span><span class="p">[</span><span class="s1">&#39;Js&#39;</span><span class="p">]]</span> <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">missingGfactor</span><span class="p">[</span><span class="n">L</span><span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span> <span class="o">-</span> <span class="n">gsum</span>

        <span class="c1"># for energy grid generation:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_energies</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">)</span> <span class="p">]</span>
        <span class="n">totalWidths</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;totalWidth&#39;</span><span class="p">)</span> <span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">totalWidths</span><span class="p">):</span> <span class="c1"># total widths aren&#39;t specified in Reich_Moore case</span>
            <span class="n">totalWidths</span> <span class="o">=</span> <span class="p">(</span> <span class="n">table</span><span class="p">[</span><span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">)]</span> <span class="o">+</span> <span class="n">table</span><span class="p">[</span><span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;captureWidth&#39;</span><span class="p">)]</span>
                    <span class="o">+</span> <span class="n">table</span><span class="p">[</span><span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;fissionWidth&#39;</span><span class="p">)]</span> <span class="o">+</span> <span class="n">table</span><span class="p">[</span><span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;fissionWidthB&#39;</span><span class="p">)]</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_widths</span> <span class="o">=</span> <span class="n">totalWidths</span></div>

<div class="viewcode-block" id="RRBaseClass.getAPByChannel"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getAPByChannel">[docs]</a>    <span class="k">def</span> <span class="nf">getAPByChannel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">trueOrEffective</span><span class="o">=</span><span class="s1">&#39;true&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;get the channel radius, rho. If L is specified try to get L-dependent value&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">calculateChannelRadius</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="mf">0.123</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetMass_amu</span><span class="o">**</span><span class="p">(</span> <span class="mf">1.</span> <span class="o">/</span> <span class="mf">3.</span> <span class="p">)</span> <span class="o">+</span> <span class="mf">0.08</span>  <span class="c1"># eq. D.14 in ENDF manual, a in b^-1/2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">getScatteringRadius</span><span class="p">()</span><span class="o">.</span><span class="n">isEnergyDependent</span><span class="p">():</span>
                <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">getScatteringRadius</span><span class="p">()</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;10**-12*cm&#39;</span><span class="p">)</span>   <span class="c1"># a in b^-1/2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">getScatteringRadius</span><span class="p">()</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span> <span class="s1">&#39;10**-12*cm&#39;</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="n">c</span><span class="o">.</span><span class="n">l</span> <span class="p">)</span>   <span class="c1"># a in b^-1/2</span>
        <span class="k">return</span> <span class="n">a</span></div>

<div class="viewcode-block" id="RRBaseClass.rho"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.rho">[docs]</a>    <span class="k">def</span> <span class="nf">rho</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">forceUseTabulated</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the channel radius rho. May be computed from a simple expression or from the tabulated scattering radius.</span>

<span class="sd">        :param E: incident energy grid, necessary if the tabulated scattering radius is energy-dependent</span>
<span class="sd">        :param forceUseTabulated: override &#39;calculateChannelRadius&#39; flag (should be used for computing phase shift)</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">calculateChannelRadius</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">forceUseTabulated</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="mf">0.123</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetMass_amu</span><span class="o">**</span><span class="p">(</span> <span class="mf">1.</span> <span class="o">/</span> <span class="mf">3.</span> <span class="p">)</span> <span class="o">+</span> <span class="mf">0.08</span>  <span class="c1"># eq. D.14 in ENDF manual, a in b^-1/2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">getScatteringRadius</span><span class="p">()</span><span class="o">.</span><span class="n">isEnergyDependent</span><span class="p">():</span>
                <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">getScatteringRadius</span><span class="p">()</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;10**-12*cm&#39;</span><span class="p">,</span> <span class="n">energy_grid</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">E</span><span class="p">))</span>   <span class="c1"># a in b^-1/2</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">E</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">getScatteringRadius</span><span class="p">()</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span> <span class="s1">&#39;10**-12*cm&#39;</span> <span class="p">)</span>   <span class="c1"># a in b^-1/2</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span> <span class="c1"># dimensionless</span></div>

<div class="viewcode-block" id="RRBaseClass.generateEnergyGrid"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.generateEnergyGrid">[docs]</a>    <span class="k">def</span> <span class="nf">generateEnergyGrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lowBound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">highBound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Create an initial energy grid by merging a rough mesh for the entire region (~10 points / decade)</span>
<span class="sd">        with a denser grid around each resonance. For the denser grid, multiply the total resonance width by</span>
<span class="sd">        the &#39;resonancePos&#39; array defined below. &quot;&quot;&quot;</span>
        <span class="n">energies</span><span class="p">,</span> <span class="n">widths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_energies</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_widths</span>
        <span class="n">thresholds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_thresholds&#39;</span><span class="p">):</span>
            <span class="n">thresholds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_thresholds</span>
        <span class="k">if</span> <span class="n">lowBound</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lowBound</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span>
        <span class="k">if</span> <span class="n">highBound</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">highBound</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span>
        <span class="c1"># ignore negative resonances</span>
        <span class="k">for</span> <span class="n">lidx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">energies</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">energies</span><span class="p">[</span><span class="n">lidx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">break</span>
        <span class="n">energies</span> <span class="o">=</span> <span class="n">energies</span><span class="p">[</span><span class="n">lidx</span><span class="p">:]</span>
        <span class="n">widths</span> <span class="o">=</span> <span class="n">widths</span><span class="p">[</span><span class="n">lidx</span><span class="p">:]</span>
        <span class="c1"># generate grid for a single peak, should be good to 1% using linear interpolation using default stride</span>
        <span class="n">resonancePos</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="mf">0.000e+00</span><span class="p">,</span> <span class="mf">1.000e-03</span><span class="p">,</span> <span class="mf">2.000e-03</span><span class="p">,</span> <span class="mf">3.000e-03</span><span class="p">,</span> <span class="mf">4.000e-03</span><span class="p">,</span> <span class="mf">5.000e-03</span><span class="p">,</span> <span class="mf">6.000e-03</span><span class="p">,</span> <span class="mf">7.000e-03</span><span class="p">,</span> <span class="mf">8.000e-03</span><span class="p">,</span> <span class="mf">9.000e-03</span><span class="p">,</span> <span class="mf">1.000e-02</span><span class="p">,</span> <span class="mf">2.000e-02</span><span class="p">,</span>
            <span class="mf">3.000e-02</span><span class="p">,</span> <span class="mf">4.000e-02</span><span class="p">,</span> <span class="mf">5.000e-02</span><span class="p">,</span> <span class="mf">6.000e-02</span><span class="p">,</span> <span class="mf">7.000e-02</span><span class="p">,</span> <span class="mf">8.000e-02</span><span class="p">,</span> <span class="mf">9.000e-02</span><span class="p">,</span> <span class="mf">1.000e-01</span><span class="p">,</span> <span class="mf">1.100e-01</span><span class="p">,</span> <span class="mf">1.200e-01</span><span class="p">,</span> <span class="mf">1.300e-01</span><span class="p">,</span> <span class="mf">1.400e-01</span><span class="p">,</span>
            <span class="mf">1.500e-01</span><span class="p">,</span> <span class="mf">1.600e-01</span><span class="p">,</span> <span class="mf">1.700e-01</span><span class="p">,</span> <span class="mf">1.800e-01</span><span class="p">,</span> <span class="mf">1.900e-01</span><span class="p">,</span> <span class="mf">2.000e-01</span><span class="p">,</span> <span class="mf">2.100e-01</span><span class="p">,</span> <span class="mf">2.200e-01</span><span class="p">,</span> <span class="mf">2.300e-01</span><span class="p">,</span> <span class="mf">2.400e-01</span><span class="p">,</span> <span class="mf">2.500e-01</span><span class="p">,</span> <span class="mf">2.600e-01</span><span class="p">,</span>
            <span class="mf">2.800e-01</span><span class="p">,</span> <span class="mf">3.000e-01</span><span class="p">,</span> <span class="mf">3.200e-01</span><span class="p">,</span> <span class="mf">3.400e-01</span><span class="p">,</span> <span class="mf">3.600e-01</span><span class="p">,</span> <span class="mf">3.800e-01</span><span class="p">,</span> <span class="mf">4.000e-01</span><span class="p">,</span> <span class="mf">4.200e-01</span><span class="p">,</span> <span class="mf">4.400e-01</span><span class="p">,</span> <span class="mf">4.600e-01</span><span class="p">,</span> <span class="mf">4.800e-01</span><span class="p">,</span> <span class="mf">5.000e-01</span><span class="p">,</span>
            <span class="mf">5.500e-01</span><span class="p">,</span> <span class="mf">6.000e-01</span><span class="p">,</span> <span class="mf">6.500e-01</span><span class="p">,</span> <span class="mf">7.000e-01</span><span class="p">,</span> <span class="mf">7.500e-01</span><span class="p">,</span> <span class="mf">8.000e-01</span><span class="p">,</span> <span class="mf">8.500e-01</span><span class="p">,</span> <span class="mf">9.000e-01</span><span class="p">,</span> <span class="mf">9.500e-01</span><span class="p">,</span> <span class="mf">1.000e+00</span><span class="p">,</span> <span class="mf">1.050e+00</span><span class="p">,</span> <span class="mf">1.100e+00</span><span class="p">,</span>
            <span class="mf">1.150e+00</span><span class="p">,</span> <span class="mf">1.200e+00</span><span class="p">,</span> <span class="mf">1.250e+00</span><span class="p">,</span> <span class="mf">1.300e+00</span><span class="p">,</span> <span class="mf">1.350e+00</span><span class="p">,</span> <span class="mf">1.400e+00</span><span class="p">,</span> <span class="mf">1.450e+00</span><span class="p">,</span> <span class="mf">1.500e+00</span><span class="p">,</span> <span class="mf">1.550e+00</span><span class="p">,</span> <span class="mf">1.600e+00</span><span class="p">,</span> <span class="mf">1.650e+00</span><span class="p">,</span> <span class="mf">1.700e+00</span><span class="p">,</span>
            <span class="mf">1.750e+00</span><span class="p">,</span> <span class="mf">1.800e+00</span><span class="p">,</span> <span class="mf">1.850e+00</span><span class="p">,</span> <span class="mf">1.900e+00</span><span class="p">,</span> <span class="mf">1.950e+00</span><span class="p">,</span> <span class="mf">2.000e+00</span><span class="p">,</span> <span class="mf">2.050e+00</span><span class="p">,</span> <span class="mf">2.100e+00</span><span class="p">,</span> <span class="mf">2.150e+00</span><span class="p">,</span> <span class="mf">2.200e+00</span><span class="p">,</span> <span class="mf">2.250e+00</span><span class="p">,</span> <span class="mf">2.300e+00</span><span class="p">,</span>
            <span class="mf">2.350e+00</span><span class="p">,</span> <span class="mf">2.400e+00</span><span class="p">,</span> <span class="mf">2.450e+00</span><span class="p">,</span> <span class="mf">2.500e+00</span><span class="p">,</span> <span class="mf">2.600e+00</span><span class="p">,</span> <span class="mf">2.700e+00</span><span class="p">,</span> <span class="mf">2.800e+00</span><span class="p">,</span> <span class="mf">2.900e+00</span><span class="p">,</span> <span class="mf">3.000e+00</span><span class="p">,</span> <span class="mf">3.100e+00</span><span class="p">,</span> <span class="mf">3.200e+00</span><span class="p">,</span> <span class="mf">3.300e+00</span><span class="p">,</span>
            <span class="mf">3.400e+00</span><span class="p">,</span> <span class="mf">3.600e+00</span><span class="p">,</span> <span class="mf">3.800e+00</span><span class="p">,</span> <span class="mf">4.000e+00</span><span class="p">,</span> <span class="mf">4.200e+00</span><span class="p">,</span> <span class="mf">4.400e+00</span><span class="p">,</span> <span class="mf">4.600e+00</span><span class="p">,</span> <span class="mf">4.800e+00</span><span class="p">,</span> <span class="mf">5.000e+00</span><span class="p">,</span> <span class="mf">5.200e+00</span><span class="p">,</span> <span class="mf">5.400e+00</span><span class="p">,</span> <span class="mf">5.600e+00</span><span class="p">,</span>
            <span class="mf">5.800e+00</span><span class="p">,</span> <span class="mf">6.000e+00</span><span class="p">,</span> <span class="mf">6.200e+00</span><span class="p">,</span> <span class="mf">6.400e+00</span><span class="p">,</span> <span class="mf">6.500e+00</span><span class="p">,</span> <span class="mf">6.800e+00</span><span class="p">,</span> <span class="mf">7.000e+00</span><span class="p">,</span> <span class="mf">7.500e+00</span><span class="p">,</span> <span class="mf">8.000e+00</span><span class="p">,</span> <span class="mf">8.500e+00</span><span class="p">,</span> <span class="mf">9.000e+00</span><span class="p">,</span> <span class="mf">9.500e+00</span><span class="p">,</span>
            <span class="mf">1.000e+01</span><span class="p">,</span> <span class="mf">1.050e+01</span><span class="p">,</span> <span class="mf">1.100e+01</span><span class="p">,</span> <span class="mf">1.150e+01</span><span class="p">,</span> <span class="mf">1.200e+01</span><span class="p">,</span> <span class="mf">1.250e+01</span><span class="p">,</span> <span class="mf">1.300e+01</span><span class="p">,</span> <span class="mf">1.350e+01</span><span class="p">,</span> <span class="mf">1.400e+01</span><span class="p">,</span> <span class="mf">1.450e+01</span><span class="p">,</span> <span class="mf">1.500e+01</span><span class="p">,</span> <span class="mf">1.550e+01</span><span class="p">,</span>
            <span class="mf">1.600e+01</span><span class="p">,</span> <span class="mf">1.700e+01</span><span class="p">,</span> <span class="mf">1.800e+01</span><span class="p">,</span> <span class="mf">1.900e+01</span><span class="p">,</span> <span class="mf">2.000e+01</span><span class="p">,</span> <span class="mf">2.100e+01</span><span class="p">,</span> <span class="mf">2.200e+01</span><span class="p">,</span> <span class="mf">2.300e+01</span><span class="p">,</span> <span class="mf">2.400e+01</span><span class="p">,</span> <span class="mf">2.500e+01</span><span class="p">,</span> <span class="mf">2.600e+01</span><span class="p">,</span> <span class="mf">2.700e+01</span><span class="p">,</span>
            <span class="mf">2.800e+01</span><span class="p">,</span> <span class="mf">2.900e+01</span><span class="p">,</span> <span class="mf">3.000e+01</span><span class="p">,</span> <span class="mf">3.100e+01</span><span class="p">,</span> <span class="mf">3.200e+01</span><span class="p">,</span> <span class="mf">3.300e+01</span><span class="p">,</span> <span class="mf">3.400e+01</span><span class="p">,</span> <span class="mf">3.600e+01</span><span class="p">,</span> <span class="mf">3.800e+01</span><span class="p">,</span> <span class="mf">4.000e+01</span><span class="p">,</span> <span class="mf">4.200e+01</span><span class="p">,</span> <span class="mf">4.400e+01</span><span class="p">,</span>
            <span class="mf">4.600e+01</span><span class="p">,</span> <span class="mf">4.800e+01</span><span class="p">,</span> <span class="mf">5.000e+01</span><span class="p">,</span> <span class="mf">5.300e+01</span><span class="p">,</span> <span class="mf">5.600e+01</span><span class="p">,</span> <span class="mf">5.900e+01</span><span class="p">,</span> <span class="mf">6.200e+01</span><span class="p">,</span> <span class="mf">6.600e+01</span><span class="p">,</span> <span class="mf">7.000e+01</span><span class="p">,</span> <span class="mf">7.400e+01</span><span class="p">,</span> <span class="mf">7.800e+01</span><span class="p">,</span> <span class="mf">8.200e+01</span><span class="p">,</span>
            <span class="mf">8.600e+01</span><span class="p">,</span> <span class="mf">9.000e+01</span><span class="p">,</span> <span class="mf">9.400e+01</span><span class="p">,</span> <span class="mf">9.800e+01</span><span class="p">,</span> <span class="mf">1.020e+02</span><span class="p">,</span> <span class="mf">1.060e+02</span><span class="p">,</span> <span class="mf">1.098e+02</span><span class="p">,</span> <span class="mf">1.140e+02</span><span class="p">,</span> <span class="mf">1.180e+02</span><span class="p">,</span> <span class="mf">1.232e+02</span><span class="p">,</span> <span class="mf">1.260e+02</span><span class="p">,</span> <span class="mf">1.300e+02</span><span class="p">,</span>
            <span class="mf">1.382e+02</span><span class="p">,</span> <span class="mf">1.550e+02</span><span class="p">,</span> <span class="mf">1.600e+02</span><span class="p">,</span> <span class="mf">1.739e+02</span><span class="p">,</span> <span class="mf">1.800e+02</span><span class="p">,</span> <span class="mf">1.951e+02</span><span class="p">,</span> <span class="mf">2.000e+02</span><span class="p">,</span> <span class="mf">2.100e+02</span><span class="p">,</span> <span class="mf">2.189e+02</span><span class="p">,</span> <span class="mf">2.300e+02</span><span class="p">,</span> <span class="mf">2.456e+02</span><span class="p">,</span> <span class="mf">2.500e+02</span><span class="p">,</span>
            <span class="mf">2.600e+02</span><span class="p">,</span> <span class="mf">2.756e+02</span><span class="p">,</span> <span class="mf">3.092e+02</span><span class="p">,</span> <span class="mf">3.200e+02</span><span class="p">,</span> <span class="mf">3.469e+02</span><span class="p">,</span> <span class="mf">3.600e+02</span><span class="p">,</span> <span class="mf">3.892e+02</span><span class="p">,</span> <span class="mf">4.000e+02</span><span class="p">,</span> <span class="mf">4.200e+02</span><span class="p">,</span> <span class="mf">4.367e+02</span><span class="p">,</span> <span class="mf">4.600e+02</span><span class="p">,</span> <span class="mf">4.800e+02</span><span class="p">,</span>
            <span class="mf">5.000e+02</span><span class="p">,</span> <span class="mf">6.000e+02</span><span class="p">,</span> <span class="mf">7.000e+02</span><span class="p">,</span> <span class="mf">8.000e+02</span><span class="p">,</span> <span class="mf">9.000e+02</span><span class="p">,</span> <span class="mf">1.000e+03</span><span class="p">][::</span><span class="n">stride</span><span class="p">])</span>

        <span class="n">grid</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># get the midpoints (on log10 scale) between each resonance:</span>
        <span class="c1"># emid = [lowBound] + list(10**( ( numpy.log10(energies[1:])+numpy.log10(energies[:-1]) ) / 2.0)) + [highBound]</span>
        <span class="c1"># or get midpoints on linear scale:</span>
        <span class="n">emid</span> <span class="o">=</span> <span class="p">[</span><span class="n">lowBound</span><span class="p">]</span> <span class="o">+</span> <span class="p">[(</span><span class="n">e1</span><span class="o">+</span><span class="n">e2</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span> <span class="k">for</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">energies</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">energies</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span> <span class="o">+</span> <span class="p">[</span><span class="n">highBound</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">lowedge</span><span class="p">,</span> <span class="n">highedge</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">energies</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="n">emid</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">emid</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">e</span><span class="o">-</span><span class="n">w</span><span class="o">*</span><span class="n">resonancePos</span>
            <span class="n">grid</span> <span class="o">+=</span> <span class="p">[</span><span class="n">lowedge</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">points</span><span class="o">&gt;</span><span class="n">lowedge</span><span class="p">])</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">e</span><span class="o">+</span><span class="n">w</span><span class="o">*</span><span class="n">resonancePos</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">grid</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">points</span> <span class="o">&lt;</span> <span class="n">highedge</span><span class="p">])</span>
        <span class="c1"># also add rough grid, to cover any big gaps between resonances, should give at least 10 points per decade:</span>
        <span class="n">npoints</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">highBound</span><span class="p">)</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">lowBound</span><span class="p">))</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">grid</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">lowBound</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">highBound</span><span class="p">),</span> <span class="n">npoints</span><span class="p">))[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">grid</span> <span class="o">+=</span> <span class="p">[</span><span class="n">lowBound</span><span class="p">,</span> <span class="n">highBound</span><span class="p">,</span> <span class="mf">0.0253</span><span class="p">]</span>   <span class="c1"># region boundaries + thermal</span>
        <span class="c1"># if threshold reactions present, add dense grid at and above threshold</span>
        <span class="k">for</span> <span class="n">threshold</span> <span class="ow">in</span> <span class="n">thresholds</span><span class="p">:</span>
            <span class="n">grid</span> <span class="o">+=</span> <span class="p">[</span><span class="n">threshold</span><span class="p">]</span>
            <span class="n">grid</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">threshold</span> <span class="o">+</span> <span class="n">resonancePos</span> <span class="o">*</span> <span class="mf">1e-2</span><span class="p">)</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">grid</span><span class="p">))</span>
        <span class="c1"># toss any points outside of energy bounds:</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">grid</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">lowBound</span><span class="p">)</span> <span class="p">:</span> <span class="n">grid</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">highBound</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">grid</span></div>

<div class="viewcode-block" id="RRBaseClass.setResonanceParametersByChannel"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.setResonanceParametersByChannel">[docs]</a>    <span class="k">def</span> <span class="nf">setResonanceParametersByChannel</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">multipleSScheme</span><span class="o">=</span><span class="s1">&#39;ENDF&#39;</span><span class="p">,</span> <span class="n">useReichMooreApproximation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">Ein</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">warnOnly</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reorganize member data into channels (relies heavily on groundwork in sortLandJ).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nResonances</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lMax</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c1"># updated below</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channelConstantsBc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">allowedSs</span> <span class="o">=</span> <span class="n">getAllowedTotalSpins</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">projectileSpin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetSpin</span><span class="p">,</span> <span class="n">useFactor2Trick</span><span class="o">=</span><span class="kc">False</span> <span class="p">)</span>
        <span class="n">warnings</span><span class="o">=</span><span class="p">[]</span>

        <span class="c1"># Make a unified table of resonance parameter data, convert to self.energyUnit if necessary</span>
        <span class="n">lList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">,</span><span class="s1">&#39;L&#39;</span><span class="p">,</span><span class="s1">&#39;J&#39;</span><span class="p">,</span><span class="s1">&#39;channelSpin&#39;</span><span class="p">,</span><span class="s1">&#39;totalWidth&#39;</span><span class="p">,</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">,</span><span class="s1">&#39;captureWidth&#39;</span><span class="p">,</span> <span class="s1">&#39;fissionWidth&#39;</span><span class="p">,</span><span class="s1">&#39;fissionWidthB&#39;</span><span class="p">)</span>
        <span class="n">EU</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span>
        <span class="n">units</span> <span class="o">=</span> <span class="p">(</span><span class="n">EU</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="n">EU</span><span class="p">,</span><span class="n">EU</span><span class="p">,</span><span class="n">EU</span><span class="p">,</span><span class="n">EU</span><span class="p">,</span><span class="n">EU</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span> <span class="n">quant</span><span class="p">,</span><span class="n">unit</span> <span class="p">)</span> <span class="k">for</span> <span class="n">quant</span><span class="p">,</span><span class="n">unit</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="n">units</span><span class="p">)</span> <span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nResonances</span>

        <span class="k">def</span> <span class="nf">addOrUpdateDict</span><span class="p">(</span> <span class="n">theDict</span><span class="p">,</span> <span class="n">theKey</span><span class="p">,</span> <span class="n">theValue</span> <span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">theKey</span> <span class="ow">in</span> <span class="n">theDict</span><span class="p">:</span> <span class="n">theDict</span><span class="p">[</span> <span class="n">theKey</span> <span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">theDict</span><span class="p">[</span> <span class="n">theKey</span> <span class="p">][</span> <span class="n">theValue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">]</span> <span class="o">=</span> <span class="n">theValue</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">particlePairs</span><span class="o">=</span><span class="p">{</span>
            <span class="s1">&#39;capture&#39;</span><span class="p">:(</span><span class="s1">&#39;gamma&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">rootAncestor</span><span class="o">.</span><span class="n">compound_nucleus</span><span class="p">),</span>
            <span class="s1">&#39;elastic&#39;</span><span class="p">:(</span><span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">rootAncestor</span><span class="o">.</span><span class="n">projectile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">rootAncestor</span><span class="o">.</span><span class="n">target</span><span class="p">)}</span>
        <span class="n">pA102</span> <span class="o">=</span> <span class="n">particlePairs</span><span class="p">[</span><span class="s1">&#39;capture&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pB102</span> <span class="o">=</span> <span class="n">particlePairs</span><span class="p">[</span><span class="s1">&#39;capture&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">pA2</span> <span class="o">=</span> <span class="n">particlePairs</span><span class="p">[</span><span class="s1">&#39;elastic&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pB2</span> <span class="o">=</span> <span class="n">particlePairs</span><span class="p">[</span><span class="s1">&#39;elastic&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Now make the dictionary of channels</span>
        <span class="n">channelDict</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">iR</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">nResonances</span> <span class="p">):</span>
            <span class="n">ER</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span>
            <span class="n">L</span> <span class="o">=</span>  <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span>
            <span class="n">J</span> <span class="o">=</span>  <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span>
            <span class="n">S</span> <span class="o">=</span>  <span class="kc">None</span> <span class="c1"># not given in MLBW, RM or RML, I just list it here for completeness</span>
            <span class="n">GT</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span>
            <span class="n">GN</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span>
            <span class="n">GG</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span>
            <span class="n">GF</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span>
            <span class="n">GX</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">8</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span>
            <span class="n">JisAllowed</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lMax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">lMax</span><span class="p">,</span> <span class="n">L</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">L</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lList</span><span class="p">:</span> <span class="n">lList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
            <span class="n">allowedSByThisJl</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">SS</span> <span class="ow">in</span> <span class="n">allowedSs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="ow">in</span> <span class="n">getAllowedTotalSpins</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">useFactor2Trick</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
                    <span class="n">JisAllowed</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">allowedSByThisJl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">SS</span> <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">JisAllowed</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">warnOnly</span><span class="p">:</span>
                    <span class="kn">from</span> <span class="nn">fudge</span> <span class="kn">import</span> <span class="n">warning</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">warning</span><span class="o">.</span><span class="n">InvalidAngularMomentaCombination</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;all channels&#39;</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s2">&quot;Invalid total angular momentum and/or orbital momentum: cannot couple up to J = &quot;</span>
                                      <span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">J</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; with I = &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetSpin</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;, i = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">projectileSpin</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; and L = &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="p">)</span>
            <span class="n">gfact</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">)</span><span class="o">+</span><span class="mf">1.</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="mf">2.</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">projectileSpin</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">targetSpin</span><span class="o">+</span><span class="mf">1.</span><span class="p">))</span>

            <span class="c1"># Way recommended by NJOY:</span>
            <span class="c1">#   * One of valid S&#39;s get width, other(s) get zero width</span>
            <span class="c1">#   * Zero width channels left in sum to get potential scattering correct</span>
            <span class="c1">#   * Gets good (cs from U) to (cs from Fudge) comparison; good (cs from U) to (cs from BB)</span>
            <span class="k">if</span> <span class="n">multipleSScheme</span> <span class="o">==</span> <span class="s1">&#39;NJOY&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">allowedSByThisJl</span><span class="p">:</span>
                    <span class="n">addOrUpdateDict</span><span class="p">(</span> <span class="n">channelDict</span><span class="p">,</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;elastic&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">allowedSByThisJl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gfact</span><span class="p">,</span> <span class="n">pA2</span><span class="p">,</span> <span class="n">pB2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">NEUTRONCHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">),</span> <span class="p">(</span> <span class="n">iR</span><span class="p">,</span> <span class="n">GN</span> <span class="p">)</span> <span class="p">)</span>
                    <span class="n">addOrUpdateDict</span><span class="p">(</span> <span class="n">channelDict</span><span class="p">,</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;capture&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">allowedSByThisJl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gfact</span><span class="p">,</span> <span class="n">pA102</span><span class="p">,</span> <span class="n">pB102</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">GAMMACHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">useReichMooreApproximation</span> <span class="p">),</span> <span class="p">(</span> <span class="n">iR</span><span class="p">,</span> <span class="n">GG</span> <span class="p">)</span> <span class="p">)</span>
                    <span class="k">if</span> <span class="n">GF</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="n">addOrUpdateDict</span><span class="p">(</span> <span class="n">channelDict</span><span class="p">,</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;fission&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">allowedSByThisJl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">FISSIONCHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">),</span> <span class="p">(</span> <span class="n">iR</span><span class="p">,</span> <span class="n">GF</span> <span class="p">)</span> <span class="p">)</span>
                    <span class="k">if</span> <span class="n">GX</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="n">addOrUpdateDict</span><span class="p">(</span><span class="n">channelDict</span><span class="p">,</span> <span class="n">ChannelDesignator</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;competitive&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">allowedSByThisJl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">COMPETITIVECHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span> <span class="p">(</span><span class="n">iR</span><span class="p">,</span> <span class="n">GX</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">SS</span> <span class="ow">in</span> <span class="n">allowedSByThisJl</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                        <span class="n">addOrUpdateDict</span><span class="p">(</span> <span class="n">channelDict</span><span class="p">,</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;elastic&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="n">pA2</span><span class="p">,</span> <span class="n">pB2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">NEUTRONCHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">),</span> <span class="p">(</span> <span class="n">iR</span><span class="p">,</span> <span class="mf">0.0</span> <span class="p">)</span> <span class="p">)</span>
                        <span class="n">addOrUpdateDict</span><span class="p">(</span> <span class="n">channelDict</span><span class="p">,</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;capture&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="n">pA102</span><span class="p">,</span> <span class="n">pB102</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">GAMMACHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">useReichMooreApproximation</span> <span class="p">),</span> <span class="p">(</span> <span class="n">iR</span><span class="p">,</span> <span class="mf">0.0</span> <span class="p">)</span> <span class="p">)</span>
                        <span class="k">if</span> <span class="n">GF</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="n">addOrUpdateDict</span><span class="p">(</span> <span class="n">channelDict</span><span class="p">,</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;fission&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">FISSIONCHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">),</span> <span class="p">(</span> <span class="n">iR</span><span class="p">,</span> <span class="mf">0.0</span> <span class="p">)</span> <span class="p">)</span>
                        <span class="k">if</span> <span class="n">GX</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="n">addOrUpdateDict</span><span class="p">(</span><span class="n">channelDict</span><span class="p">,</span> <span class="n">ChannelDesignator</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;competitive&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">COMPETITIVECHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span> <span class="p">(</span><span class="n">iR</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>

            <span class="c1"># Way mandated by ENDF manual:</span>
            <span class="c1">#   * Width divided between channels with valid S&#39;s based on sign of J:</span>
            <span class="c1">#       ** if J&gt;0, S is max possible value</span>
            <span class="c1">#       ** if J&lt;0, S is min possible value</span>
            <span class="c1">#   * All channels left in sum to get potential scattering correct</span>
            <span class="c1">#   * Gets poor (cs from U) to (cs from Fudge) comparison; poor (cs from U) to (cs from BB)</span>
            <span class="k">elif</span> <span class="n">multipleSScheme</span> <span class="o">==</span> <span class="s1">&#39;ENDF&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">allowedSByThisJl</span><span class="p">:</span>
                    <span class="n">allowedSByThisJl</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">allowedSByThisJl</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="n">SS</span><span class="o">=</span><span class="n">allowedSByThisJl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span> <span class="n">SS</span><span class="o">=</span><span class="n">allowedSByThisJl</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">)</span><span class="o">==</span><span class="n">J</span><span class="p">)]</span>
                    <span class="n">addOrUpdateDict</span><span class="p">(</span> <span class="n">channelDict</span><span class="p">,</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;elastic&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="n">pA2</span><span class="p">,</span> <span class="n">pB2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">NEUTRONCHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">),</span> <span class="p">(</span> <span class="n">iR</span><span class="p">,</span> <span class="n">GN</span> <span class="p">)</span> <span class="p">)</span>
                    <span class="n">addOrUpdateDict</span><span class="p">(</span> <span class="n">channelDict</span><span class="p">,</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;capture&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="n">pA102</span><span class="p">,</span> <span class="n">pB102</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">GAMMACHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">useReichMooreApproximation</span> <span class="p">),</span> <span class="p">(</span> <span class="n">iR</span><span class="p">,</span> <span class="n">GG</span> <span class="p">)</span> <span class="p">)</span>
                    <span class="k">if</span> <span class="n">GF</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="n">addOrUpdateDict</span><span class="p">(</span> <span class="n">channelDict</span><span class="p">,</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;fission&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">FISSIONCHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">),</span> <span class="p">(</span> <span class="n">iR</span><span class="p">,</span> <span class="n">GF</span> <span class="p">)</span> <span class="p">)</span>
                    <span class="k">if</span> <span class="n">GX</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="n">addOrUpdateDict</span><span class="p">(</span><span class="n">channelDict</span><span class="p">,</span> <span class="n">ChannelDesignator</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;competitive&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">COMPETITIVECHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span> <span class="p">(</span><span class="n">iR</span><span class="p">,</span> <span class="n">GX</span><span class="p">))</span>

            <span class="c1"># Ignore problem:</span>
            <span class="c1">#   * Ignore spin of channels and the fact may be multiple valid spins</span>
            <span class="c1">#   * Gets best (cs from U) to (cs from Fudge) comparison; poor (cs from U) to (cs from BB)</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="n">addOrUpdateDict</span><span class="p">(</span> <span class="n">channelDict</span><span class="p">,</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;elastic&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="n">pA2</span><span class="p">,</span> <span class="n">pB2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">NEUTRONCHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">),</span> <span class="p">(</span> <span class="n">iR</span><span class="p">,</span> <span class="n">GN</span> <span class="p">)</span> <span class="p">)</span>
                <span class="n">addOrUpdateDict</span><span class="p">(</span> <span class="n">channelDict</span><span class="p">,</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;capture&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="n">pA102</span><span class="p">,</span> <span class="n">pB102</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">GAMMACHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">useReichMooreApproximation</span> <span class="p">),</span> <span class="p">(</span> <span class="n">iR</span><span class="p">,</span> <span class="n">GG</span> <span class="p">)</span> <span class="p">)</span>
                <span class="k">if</span> <span class="n">GF</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="n">addOrUpdateDict</span><span class="p">(</span> <span class="n">channelDict</span><span class="p">,</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;fission&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">FISSIONCHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">),</span> <span class="p">(</span> <span class="n">iR</span><span class="p">,</span> <span class="n">GF</span> <span class="p">)</span> <span class="p">)</span>
                <span class="k">if</span> <span class="n">GX</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="n">addOrUpdateDict</span><span class="p">(</span><span class="n">channelDict</span><span class="p">,</span> <span class="n">ChannelDesignator</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;competitive&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">COMPETITIVECHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span> <span class="p">(</span><span class="n">iR</span><span class="p">,</span> <span class="n">GX</span><span class="p">))</span>

        <span class="c1"># Take care of extra l&#39;s needed to get potential scattering correct</span>
        <span class="c1"># Make a single elastic channel with a zero width resonance at the energy of the first real resonance</span>
        <span class="c1"># This won&#39;t add to the resonance scattering part, but it will make a potential scattering part.</span>
        <span class="c1"># We add in channels for all spins and total angular momenta to make sure get the angular momentum algebra correct.</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lMax</span><span class="o">+</span><span class="mi">1</span> <span class="p">):</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">allowedSs</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">getAllowedTotalSpins</span><span class="p">(</span> <span class="n">l</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">useFactor2Trick</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
                    <span class="n">newChannel</span> <span class="o">=</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">l</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="s1">&#39;elastic&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">projectileSpin</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">targetSpin</span><span class="o">+</span><span class="mi">1</span><span class="p">)),</span> <span class="n">pA2</span><span class="p">,</span> <span class="n">pB2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">NEUTRONCHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">newChannel</span> <span class="ow">in</span> <span class="n">channelDict</span><span class="p">:</span> <span class="n">addOrUpdateDict</span><span class="p">(</span> <span class="n">channelDict</span><span class="p">,</span> <span class="n">newChannel</span><span class="p">,</span> <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">)</span>

        <span class="c1"># Set up the channel-&gt;resonance mappings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span> <span class="o">=</span> <span class="n">channelDict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>  <span class="c1"># just the kept ones</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eliminatedChannels</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">eliminated</span><span class="p">:</span>    <span class="bp">self</span><span class="o">.</span><span class="n">eliminatedChannels</span><span class="p">[</span> <span class="n">c</span> <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span><span class="p">[</span> <span class="n">c</span> <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>               <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span> <span class="n">c</span> <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span><span class="p">[</span> <span class="n">c</span> <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">identityMatrix</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span> <span class="p">)</span>

        <span class="k">if</span> <span class="n">warnOnly</span><span class="p">:</span> <span class="k">return</span> <span class="n">warnings</span></div>

<div class="viewcode-block" id="RRBaseClass.resetResonanceParametersByChannel"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.resetResonanceParametersByChannel">[docs]</a>    <span class="k">def</span> <span class="nf">resetResonanceParametersByChannel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multipleSScheme</span><span class="o">=</span><span class="s1">&#39;ENDF&#39;</span><span class="p">,</span> <span class="n">useReichMooreApproximation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">Ein</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span> <span class="k">pass</span></div>

<div class="viewcode-block" id="RRBaseClass.penetrationFactorByChannel"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.penetrationFactorByChannel">[docs]</a>    <span class="k">def</span> <span class="nf">penetrationFactorByChannel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">Ein</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">channelClass</span> <span class="ow">in</span> <span class="p">[</span><span class="n">FISSIONCHANNEL</span><span class="p">,</span> <span class="n">GAMMACHANNEL</span><span class="p">]:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">Ein</span><span class="p">)</span><span class="o">==</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Ein</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mf">1.0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">Ein</span><span class="p">))</span></div>

<div class="viewcode-block" id="RRBaseClass.phiByChannel"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.phiByChannel">[docs]</a>    <span class="k">def</span> <span class="nf">phiByChannel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">Ein</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">channelClass</span> <span class="ow">in</span> <span class="p">[</span><span class="n">FISSIONCHANNEL</span><span class="p">,</span> <span class="n">GAMMACHANNEL</span><span class="p">]:</span> <span class="k">return</span> <span class="mf">0.0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">Ein</span><span class="p">)</span> <span class="p">)</span></div>

<div class="viewcode-block" id="RRBaseClass.shiftFactorByChannel"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.shiftFactorByChannel">[docs]</a>    <span class="k">def</span> <span class="nf">shiftFactorByChannel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">Ein</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">channelClass</span> <span class="ow">in</span> <span class="p">[</span><span class="n">FISSIONCHANNEL</span><span class="p">,</span> <span class="n">GAMMACHANNEL</span><span class="p">]:</span> <span class="k">return</span> <span class="mf">0.0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shiftFactor</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">Ein</span><span class="p">))</span></div>

<div class="viewcode-block" id="RRBaseClass.getChannelConstantsBc"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getChannelConstantsBc">[docs]</a>    <span class="k">def</span> <span class="nf">getChannelConstantsBc</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span> <span class="s2">&quot;Override in derived classes if used&quot;</span> <span class="p">)</span></div>

<div class="viewcode-block" id="RRBaseClass.getRMatrix"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getRMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">getRMatrix</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span> <span class="p">):</span> <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span> <span class="s2">&quot;Override in derived classes if used&quot;</span> <span class="p">)</span></div>

<div class="viewcode-block" id="RRBaseClass.getKMatrix"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getKMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">getKMatrix</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span> <span class="p">):</span> <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span> <span class="s2">&quot;Override in derived classes if used&quot;</span> <span class="p">)</span></div>

<div class="viewcode-block" id="RRBaseClass.getAMatrix"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getAMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">getAMatrix</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span> <span class="p">):</span> <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span> <span class="s2">&quot;Override in derived classes if used&quot;</span> <span class="p">)</span></div>

<div class="viewcode-block" id="RRBaseClass.getL0Matrix"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getL0Matrix">[docs]</a>    <span class="k">def</span> <span class="nf">getL0Matrix</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span> <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the L0 matrix of Froehner:</span>

<span class="sd">            ..math::</span>
<span class="sd">                {\\bf L^0}_{cc&#39;} = \\delta_{cc&#39;} (L_c-B_c)</span>

<span class="sd">        where</span>

<span class="sd">            ..math::</span>
<span class="sd">                L_c = S_c + i P_c</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channelConstantsBc</span> <span class="o">==</span> <span class="p">[]:</span> <span class="bp">self</span><span class="o">.</span><span class="n">channelConstantsBc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChannelConstantsBc</span><span class="p">()</span>
        <span class="n">L0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Ein</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">ic</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">):</span>
            <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span> <span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span> <span class="p">)</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shiftFactor</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">rho</span> <span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">penet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">rho</span> <span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

            <span class="c1"># Note, you have to add the numpy.array&#39;s this way to make a complex number</span>
            <span class="c1"># because the numpy array trickery doesn&#39;t work with the complex() or</span>
            <span class="c1"># numpy.complex() constructors</span>
            <span class="n">L0</span><span class="p">[:,</span><span class="n">ic</span><span class="p">,</span><span class="n">ic</span><span class="p">]</span> <span class="o">=</span> <span class="n">shift</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span> <span class="n">penet</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">channelConstantsBc</span><span class="p">[</span> <span class="n">ic</span> <span class="p">]</span>
        <span class="k">return</span> <span class="n">L0</span></div>

<div class="viewcode-block" id="RRBaseClass.getXMatrix"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getXMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">getXMatrix</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span> <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the X matrix for use in computing W.  X is:</span>

<span class="sd">            ..math::</span>
<span class="sd">                {\\bf X}_{cc&#39;} = P^{-1/2}_c ( ( {\\bf I} - {\\bf R}{\\bf L^0} )^{-1}{\\bf R} )_{cc&#39;} P_{c&#39;}^{-1/2}\\delta_{JJ&#39;}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">L0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getL0Matrix</span><span class="p">(</span> <span class="n">Ein</span> <span class="p">)</span>
        <span class="n">penFact</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ein</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span> <span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span> <span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ein</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span> <span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span> <span class="p">)</span>

        <span class="c1"># Precompute phase factor, sqrt(Penetrability)</span>
        <span class="k">for</span> <span class="n">ic</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">channelClass</span> <span class="ow">in</span> <span class="p">[</span><span class="n">NEUTRONCHANNEL</span><span class="p">,</span> <span class="n">CPCHANNEL</span><span class="p">]:</span> <span class="n">penFact</span><span class="p">[:,</span><span class="n">ic</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">L0</span><span class="p">[:,</span><span class="n">ic</span><span class="p">,</span><span class="n">ic</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span> <span class="p">)</span>

        <span class="c1"># Compute the (unscaled) X matrix</span>
        <span class="c1"># Hafta be real careful about combining numpy&#39;s broadcasting rules with numpy&#39;s linear algebra</span>
        <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getRMatrix</span><span class="p">(</span> <span class="n">Ein</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">iE</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Ein</span><span class="p">)):</span>
            <span class="n">thisR</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">iE</span><span class="p">])</span>
            <span class="n">thisL0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L0</span><span class="p">[</span><span class="n">iE</span><span class="p">])</span>
            <span class="n">X</span><span class="p">[</span><span class="n">iE</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">identityMatrix</span><span class="p">)</span> <span class="o">-</span> <span class="n">thisR</span> <span class="o">*</span> <span class="n">thisL0</span> <span class="p">)</span> <span class="o">*</span> <span class="n">thisR</span>

        <span class="c1"># Apply the sqrt(Penetrability) rescaling</span>
        <span class="k">for</span> <span class="n">ic1</span><span class="p">,</span> <span class="n">c1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="p">):</span>
            <span class="k">for</span> <span class="n">ic2</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="p">):</span>
                <span class="k">if</span> <span class="n">c1</span><span class="o">.</span><span class="n">J</span> <span class="o">!=</span> <span class="n">c2</span><span class="o">.</span><span class="n">J</span><span class="p">:</span> <span class="k">continue</span>
                <span class="n">X</span><span class="p">[:,</span> <span class="n">ic1</span><span class="p">,</span> <span class="n">ic2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">penFact</span><span class="p">[:,</span> <span class="n">ic1</span><span class="p">]</span> <span class="o">*</span> <span class="n">penFact</span><span class="p">[:,</span> <span class="n">ic2</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">X</span></div>

<div class="viewcode-block" id="RRBaseClass.getWMatrix"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getWMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">getWMatrix</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span> <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the W matrix for use in computing U.  W is:</span>

<span class="sd">            ..math::</span>
<span class="sd">                {\bf W} = {\bf I} + 2i{\bf X}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ein</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span> <span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span> <span class="p">)</span>
        <span class="n">W</span><span class="p">[</span> <span class="p">:,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span> <span class="p">)</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">W</span> <span class="o">+=</span> <span class="mf">2.0</span><span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">getXMatrix</span><span class="p">(</span> <span class="n">Ein</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">W</span></div>

<div class="viewcode-block" id="RRBaseClass.getEiPhis"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getEiPhis">[docs]</a>    <span class="k">def</span> <span class="nf">getEiPhis</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span><span class="p">,</span> <span class="n">useTabulatedScatteringRadius</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">enableExtraCoulombPhase</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The phase factor for the collision matrix:</span>

<span class="sd">            ..math::</span>
<span class="sd">                \\Omega_c = e^{-\\varphi_c}</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Precompute phase factor</span>
        <span class="n">eiphis</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ic</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">reaction</span> <span class="o">==</span> <span class="s1">&#39;elastic&#39;</span><span class="p">:</span>
                <span class="c1"># For calculating phi, default is to use tabulated scattering radius:</span>
                <span class="k">if</span> <span class="n">useTabulatedScatteringRadius</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">getScatteringRadius</span><span class="p">()</span><span class="o">.</span><span class="n">isEnergyDependent</span><span class="p">():</span>
                        <span class="n">rhohat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">getScatteringRadius</span><span class="p">()</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;10*fm&#39;</span><span class="p">,</span> <span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">rhohat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">getScatteringRadius</span><span class="p">()</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;10*fm&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span> <span class="n">rhohat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">)</span>
                <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">rhohat</span> <span class="p">)</span>
                <span class="n">eiphis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phi</span> <span class="p">)</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">eiphis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span> <span class="n">Ein</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">eiphis</span></div>

<div class="viewcode-block" id="RRBaseClass.getScatteringMatrixU"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getScatteringMatrixU">[docs]</a>    <span class="k">def</span> <span class="nf">getScatteringMatrixU</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span><span class="p">,</span> <span class="n">useTabulatedScatteringRadius</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">enableExtraCoulombPhase</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the scattering matrix using</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure all channels are open at all requested energies</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">is_open</span><span class="p">(</span><span class="n">Ein</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">]):</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;One or more channels are not open on all energies in requested energy grid&quot;</span><span class="p">)</span>

        <span class="c1"># Initialize lists and matrices</span>
        <span class="n">eiphis</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">getEiPhis</span><span class="p">(</span> <span class="n">Ein</span><span class="p">,</span>
                                  <span class="n">useTabulatedScatteringRadius</span><span class="o">=</span><span class="n">useTabulatedScatteringRadius</span><span class="p">,</span>
                                  <span class="n">enableExtraCoulombPhase</span><span class="o">=</span><span class="n">enableExtraCoulombPhase</span> <span class="p">)</span>
        <span class="n">W</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getWMatrix</span><span class="p">(</span> <span class="n">Ein</span> <span class="p">)</span>

        <span class="c1"># This adds in the phase factors to get us U</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ein</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span> <span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">ic1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span> <span class="p">):</span>
            <span class="k">for</span> <span class="n">ic2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span> <span class="p">):</span>
                <span class="n">U</span><span class="p">[:,</span> <span class="n">ic1</span><span class="p">,</span> <span class="n">ic2</span> <span class="p">]</span> <span class="o">=</span> <span class="n">W</span><span class="p">[:,</span> <span class="n">ic1</span><span class="p">,</span> <span class="n">ic2</span> <span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">eiphis</span><span class="p">[</span><span class="n">ic1</span><span class="p">][:]</span> <span class="o">*</span> <span class="n">eiphis</span><span class="p">[</span><span class="n">ic2</span><span class="p">][:])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">U</span></div>

<div class="viewcode-block" id="RRBaseClass.getScatteringMatrixT"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getScatteringMatrixT">[docs]</a>    <span class="k">def</span> <span class="nf">getScatteringMatrixT</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span><span class="p">,</span> <span class="n">useTabulatedScatteringRadius</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">enableExtraCoulombPhase</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
        <span class="c1"># Make sure all channels are open at all requested energies</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">is_open</span><span class="p">(</span><span class="n">Ein</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">]):</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;One or more channels are not open on all energies in requested energy grid&quot;</span><span class="p">)</span>

        <span class="n">T</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ein</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span> <span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span> <span class="p">)</span>
        <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getScatteringMatrixU</span><span class="p">(</span> <span class="n">Ein</span><span class="p">,</span>
                                       <span class="n">useTabulatedScatteringRadius</span><span class="o">=</span><span class="n">useTabulatedScatteringRadius</span><span class="p">,</span>
                                       <span class="n">enableExtraCoulombPhase</span><span class="o">=</span><span class="n">enableExtraCoulombPhase</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">ic1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span> <span class="p">):</span>
            <span class="k">for</span> <span class="n">ic2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span> <span class="p">):</span>
                <span class="n">T</span><span class="p">[:,</span> <span class="n">ic1</span><span class="p">,</span> <span class="n">ic2</span> <span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ic1</span><span class="o">==</span><span class="n">ic2</span><span class="p">)</span> <span class="o">-</span> <span class="n">U</span><span class="p">[:,</span> <span class="n">ic1</span><span class="p">,</span> <span class="n">ic2</span> <span class="p">]</span>
        <span class="k">return</span> <span class="n">T</span></div>

<div class="viewcode-block" id="RRBaseClass.getLMax"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getLMax">[docs]</a>    <span class="k">def</span> <span class="nf">getLMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">maxLmax</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        LMax is determined by the behavior of the Blatt-Biedenharn Zbar coefficients.  Inside each one, there is</span>
<span class="sd">        a Racah coefficient and a Clebsh-Gordon coefficient.  The CG coefficient looks like this::</span>

<span class="sd">            ( l1 l2  L )</span>
<span class="sd">            (  0  0  0 )</span>

<span class="sd">        So, this means two things.  First, the CG coeff (and hence Zbar) will be zero if l1+l2+L=odd.</span>
<span class="sd">        Second, the maximum value of L will be l1max+l2max.  Hence, Lmax=2*lmax.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span> <span class="nb">max</span><span class="p">(</span> <span class="p">[</span> <span class="mi">2</span><span class="o">*</span><span class="n">xL</span><span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">xL</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ls</span> <span class="p">]</span> <span class="p">),</span> <span class="n">maxLmax</span> <span class="p">)</span></div>

<div class="viewcode-block" id="RRBaseClass.getParticleParities"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getParticleParities">[docs]</a>    <span class="k">def</span> <span class="nf">getParticleParities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">rxn</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper around getParticleSpinParities to extract just the parities</span>

<span class="sd">        :param rxn: the reaction string for this resonanceReaction (or equivalent).  We&#39;ll process this string to</span>
<span class="sd">                    out what the light particle and heavy &quot;residual&quot; is and then look up their JPi.</span>
<span class="sd">        :return: a tuple: (JPi_light, JPi_heavy).  JPi itself is a tuple (J,Pi).</span>
<span class="sd">                 J is float (either integer or 1/2 integer) and Pi is -1 or +1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getParticleSpinParities</span><span class="p">(</span><span class="n">rxn</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="RRBaseClass.getParticleSpins"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getParticleSpins">[docs]</a>    <span class="k">def</span> <span class="nf">getParticleSpins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">rxn</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper around getParticleSpinParities to extract just the spins</span>

<span class="sd">        :param rxn: the reaction string for this resonanceReaction (or equivalent).  We&#39;ll process this string to</span>
<span class="sd">                    out what the light particle and heavy &quot;residual&quot; is and then look up their JPi.</span>
<span class="sd">        :return: a tuple: (JPi_light, JPi_heavy).  JPi itself is a tuple (J,Pi).</span>
<span class="sd">                 J is float (either integer or 1/2 integer) and Pi is -1 or +1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getParticleSpinParities</span><span class="p">(</span><span class="n">rxn</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="RRBaseClass.getParticleSpinParities"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getParticleSpinParities">[docs]</a>    <span class="k">def</span> <span class="nf">getParticleSpinParities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rxn</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        6 cases:</span>
<span class="sd">            rxn==&#39;capture&#39;</span>
<span class="sd">            rxn==&#39;elastic&#39; (equivalent to &#39;projectile + target&#39;)</span>
<span class="sd">            rxn==&#39;fission&#39; or &#39;fissionA&#39; or &#39;fissionB&#39;</span>
<span class="sd">            rxn==&#39;competitive&#39;</span>
<span class="sd">            rxn==&#39;something + something&#39; where one of somethings is photon (same as &#39;capture&#39;)</span>
<span class="sd">            rxn==&#39;something + something&#39; where neither something is a photon</span>

<span class="sd">            A word about capture channels:</span>
<span class="sd">            Because of the use of the Reich-Moore approximation, photon channels may be quasi-channels consisting</span>
<span class="sd">            of many photon channels lumped together.  This makes determination of the residual nucleus spin &amp; parity</span>
<span class="sd">            difficult since it really corresponds to a bunch of states.  Here, we just compute the lowest spin</span>
<span class="sd">            consistent with the target &amp; photon and leave it up to the code to override these values as needed.</span>

<span class="sd">            A word about fission and competitive channels:</span>
<span class="sd">            Here we don&#39;t really know or need the spins &amp; parities of the particles.  Both are many channels</span>
<span class="sd">            lumped together, in a way that makes capture look simple.  We&#39;ll just return the elastic parameters</span>
<span class="sd">            under the assumption that they&#39;re not needed.</span>

<span class="sd">        :param rxn: the reaction string for this resonanceReaction (or equivalent).  We&#39;ll process this string to</span>
<span class="sd">                    out what the light particle and heavy &quot;residual&quot; is and then look up their JPi.</span>
<span class="sd">        :return: a tuple: (JPi_a, JPi_b).  JPi itself is a tuple (J,Pi).</span>
<span class="sd">                 J is float (either integer or 1/2 integer) and Pi is -1 or +1.</span>
<span class="sd">                 It doesn&#39;t matter whether particle a or b is heaviest</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">get_spin_parity</span><span class="p">(</span><span class="n">_p</span><span class="p">):</span>
            <span class="n">s</span><span class="p">,</span> <span class="n">par</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">_p</span><span class="p">,</span> <span class="s1">&#39;nucleus&#39;</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">_p</span><span class="o">.</span><span class="n">nucleus</span><span class="o">.</span><span class="n">spin</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="s1">&#39;hbar&#39;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">err</span><span class="o">.</span><span class="n">message</span> <span class="o">+</span> <span class="s1">&#39; for particle &#39;</span> <span class="o">+</span> <span class="n">_p</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                    <span class="c1"># Sometimes (mainly with MLBW and SLBW), there&#39;s no spin given for a nucleus.</span>
                    <span class="c1"># In that case, an IndexError gets raised.  We have to punt.</span>
                    <span class="k">pass</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">par</span> <span class="o">=</span> <span class="n">_p</span><span class="o">.</span><span class="n">nucleus</span><span class="o">.</span><span class="n">parity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
                <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                    <span class="c1"># Sometimes (mainly with MLBW and SLBW), there&#39;s no parity given for a nucleus.</span>
                    <span class="c1"># In that case, an IndexError gets raised.  We have to punt.</span>
                    <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">s</span><span class="o">=</span><span class="n">_p</span><span class="o">.</span><span class="n">spin</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="s1">&#39;hbar&#39;</span><span class="p">)</span>
                    <span class="n">par</span><span class="o">=</span><span class="n">_p</span><span class="o">.</span><span class="n">parity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
                <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                    <span class="c1">#print(_p)</span>
                    <span class="k">raise</span> <span class="n">err</span>
            <span class="k">return</span> <span class="n">s</span><span class="p">,</span> <span class="n">par</span>

        <span class="c1"># Treat elastic, fission and competitive channels as elastic</span>
        <span class="c1"># for elastic is appropriate, for others it doesn&#39;t matter</span>
        <span class="k">if</span> <span class="n">rxn</span><span class="o">==</span><span class="s1">&#39;elastic&#39;</span> <span class="ow">or</span> <span class="s1">&#39;fission&#39;</span> <span class="ow">in</span> <span class="n">rxn</span> <span class="ow">or</span> <span class="s2">&quot;competitive&quot;</span> <span class="ow">in</span> <span class="n">rxn</span><span class="p">:</span>
            <span class="n">spinA</span><span class="p">,</span> <span class="n">parityA</span> <span class="o">=</span> <span class="n">get_spin_parity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">PoPs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">reactionSuite</span><span class="o">.</span><span class="n">projectile</span><span class="p">])</span>
            <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">PoPs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">PoPs</span><span class="o">.</span><span class="n">aliases</span><span class="p">):</span>
                <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">PoPs</span><span class="p">[</span><span class="n">target</span><span class="o">.</span><span class="n">pid</span><span class="p">]</span>
            <span class="n">spinB</span><span class="p">,</span> <span class="n">parityB</span> <span class="o">=</span> <span class="n">get_spin_parity</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">spinA</span><span class="p">,</span> <span class="n">parityA</span><span class="p">),</span> <span class="p">(</span><span class="n">spinB</span><span class="p">,</span> <span class="n">parityB</span><span class="p">)</span>

        <span class="c1"># Capture...</span>
        <span class="k">if</span> <span class="n">rxn</span><span class="o">==</span><span class="s1">&#39;capture&#39;</span> <span class="ow">or</span> <span class="s1">&#39;photon&#39;</span> <span class="ow">in</span> <span class="n">rxn</span><span class="p">:</span>
            <span class="n">spinA</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">projectileSpin</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">projectileSpin</span><span class="o">-</span><span class="mf">0.5</span><span class="p">))</span>
            <span class="n">parityA</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">compound</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">PoPs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">reactionSuite</span><span class="o">.</span><span class="n">compound_nucleus</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">compound</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">PoPs</span><span class="o">.</span><span class="n">aliases</span><span class="p">):</span>
                <span class="n">compound</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">PoPs</span><span class="p">[</span><span class="n">compound</span><span class="o">.</span><span class="n">pid</span><span class="p">]</span>
            <span class="n">spinB</span><span class="p">,</span> <span class="n">parityB</span> <span class="o">=</span> <span class="n">get_spin_parity</span><span class="p">(</span><span class="n">compound</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">spinA</span><span class="p">,</span> <span class="n">parityA</span><span class="p">),</span> <span class="p">(</span><span class="n">spinB</span><span class="p">,</span> <span class="n">parityB</span><span class="p">)</span>

        <span class="c1"># Everything else...</span>
        <span class="k">if</span> <span class="s1">&#39; + &#39;</span> <span class="ow">in</span> <span class="n">rxn</span><span class="p">:</span> <span class="c1"># gotta search</span>
            <span class="n">spinA</span><span class="p">,</span> <span class="n">parityA</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
            <span class="n">spinB</span><span class="p">,</span> <span class="n">parityB</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
            <span class="n">pa</span><span class="p">,</span><span class="n">pb</span><span class="o">=</span><span class="n">rxn</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; + &#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">PoPs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pa</span><span class="o">==</span><span class="n">p</span><span class="o">.</span><span class="n">id</span><span class="p">:</span> <span class="n">spinA</span><span class="p">,</span><span class="n">parityA</span><span class="o">=</span><span class="n">get_spin_parity</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">pb</span><span class="o">==</span><span class="n">p</span><span class="o">.</span><span class="n">id</span><span class="p">:</span> <span class="n">spinB</span><span class="p">,</span><span class="n">parityB</span><span class="o">=</span><span class="n">get_spin_parity</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">spinA</span><span class="p">,</span> <span class="n">parityA</span><span class="p">),</span> <span class="p">(</span><span class="n">spinB</span><span class="p">,</span> <span class="n">parityB</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot determine spins for reactants in reaction &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span><span class="o">%</span><span class="n">rxn</span><span class="p">)</span></div>

<div class="viewcode-block" id="RRBaseClass.getAngularDistribution"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getAngularDistribution">[docs]</a>    <span class="nd">@blockwise</span>
    <span class="k">def</span> <span class="nf">getAngularDistribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">keepL0Term</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">renormalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">outChannelNames</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">useTabulatedScatteringRadius</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">enableExtraCoulombPhase</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param numpy.array(type=float) E:</span>
<span class="sd">        :param bool keepL0Term:</span>
<span class="sd">        :param bool renormalize:</span>
<span class="sd">        :param list(str) outChannelNames:</span>
<span class="sd">        :param bool useTabulatedScatteringRadius:</span>
<span class="sd">        :param bool enableExtraCoulombPhase:</span>
<span class="sd">        :return:</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">numericalFunctions</span> <span class="kn">import</span> <span class="n">angularMomentumCoupling</span> <span class="k">as</span> <span class="n">nf_amc</span>

        <span class="c1"># Make sure the incident energies are in the correct form for vectorization</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">]:</span> <span class="n">E</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">E</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Make sure all channels are open at all requested energies</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resetResonanceParametersByChannel</span><span class="p">(</span> <span class="n">Ein</span><span class="o">=</span><span class="n">E</span> <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">is_open</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">]):</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;One or more channels are not open on all energies in requested energy grid&quot;</span><span class="p">)</span>

        <span class="c1"># Get the names of the input channel and all output channels to consider</span>
        <span class="n">channelNames</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">reaction</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">])</span>
        <span class="n">inChannelName</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> + </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">projectile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inChannelName</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">channelNames</span><span class="p">:</span>   <span class="c1"># FIXME change MLBW and R-M to label channels by particle pairs like LRF=7</span>
            <span class="k">if</span> <span class="s1">&#39;elastic&#39;</span> <span class="ow">in</span> <span class="n">channelNames</span><span class="p">:</span>
                <span class="n">inChannelName</span> <span class="o">=</span> <span class="s1">&#39;elastic&#39;</span>
        <span class="k">if</span> <span class="n">outChannelNames</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">outChannelNames</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">chan</span><span class="o">.</span><span class="n">reaction</span> <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">chan</span><span class="o">.</span><span class="n">eliminated</span> <span class="ow">and</span> <span class="n">chan</span><span class="o">.</span><span class="n">reaction</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;capture&#39;</span><span class="p">,</span><span class="s1">&#39;fission&#39;</span><span class="p">,</span><span class="s1">&#39;fissionA&#39;</span><span class="p">,</span><span class="s1">&#39;fissionB&#39;</span><span class="p">,</span><span class="s1">&#39;competitive&#39;</span><span class="p">]])</span>

        <span class="c1"># Set up variables, first the easy ones</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>                                           <span class="c1"># Relative momentum, comes out in b^-1/2</span>
        <span class="n">B</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:[]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">outChannelNames</span><span class="p">}</span>                 <span class="c1"># List of Blatt-Biedenharn coefficients, used in Legendre series expansion of the angular distribution</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:[]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">outChannelNames</span><span class="p">}</span>
        <span class="n">relTol</span> <span class="o">=</span> <span class="mf">1e-8</span>                                           <span class="c1"># Relative tolerance used to decide when to cut off Legendre series</span>
        <span class="n">Lmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getLMax</span><span class="p">(</span> <span class="p">)</span>                                  <span class="c1"># Lmax also used to decide when to cut off Legendre series</span>

        <span class="c1"># Now, the T matrix, the most important variable of all...</span>
        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getScatteringMatrixT</span><span class="p">(</span> <span class="n">E</span><span class="p">,</span>                       <span class="c1"># The scattering matrix</span>
                                       <span class="n">useTabulatedScatteringRadius</span><span class="o">=</span><span class="n">useTabulatedScatteringRadius</span><span class="p">,</span>
                                       <span class="n">enableExtraCoulombPhase</span><span class="o">=</span><span class="n">enableExtraCoulombPhase</span> <span class="p">)</span>

        <span class="c1"># The in channel stuff...</span>
        <span class="n">projSpin</span><span class="p">,</span> <span class="n">targSpin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getParticleSpins</span><span class="p">(</span><span class="n">inChannelName</span><span class="p">)</span>
        <span class="n">prefactor</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">k</span><span class="o">/</span><span class="n">k</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">projSpin</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">targSpin</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>       <span class="c1"># Prefactor for cross section, gets units, main energy dependence, and spin dep. prefactor</span>
        <span class="n">allowedSpins</span> <span class="o">=</span> <span class="n">getAllowedTotalSpins</span><span class="p">(</span> <span class="n">targSpin</span><span class="p">,</span>          <span class="c1"># Possible values of the total channel spin, based on the projectile spin (projSpin) and target spin (targSpin)</span>
                                             <span class="n">projSpin</span><span class="p">,</span>
                                             <span class="kc">False</span> <span class="p">)</span>
        <span class="n">incidentChannels</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">chan</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">chan</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">chan</span><span class="o">.</span><span class="n">eliminated</span> <span class="ow">and</span> <span class="n">chan</span><span class="o">.</span><span class="n">reaction</span> <span class="o">==</span> <span class="n">inChannelName</span><span class="p">]</span>

        <span class="c1"># Loop over out channels</span>
        <span class="k">for</span> <span class="n">reactionp</span> <span class="ow">in</span> <span class="n">outChannelNames</span><span class="p">:</span>
            <span class="n">ejectSpin</span><span class="p">,</span> <span class="n">resSpin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getParticleSpins</span><span class="p">(</span><span class="n">reactionp</span><span class="p">)</span>
            <span class="n">allowedSpinsp</span> <span class="o">=</span> <span class="n">getAllowedTotalSpins</span><span class="p">(</span> <span class="n">resSpin</span><span class="p">,</span>          <span class="c1"># Possible values of the total channel spin, based on the ejectile spin (ejectSpin) and residual nucleus spin (resSpin)</span>
                                                  <span class="n">ejectSpin</span><span class="p">,</span>
                                                  <span class="kc">False</span> <span class="p">)</span>
            <span class="n">outgoingChannels</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">chan</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">chan</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span>
                                <span class="k">if</span> <span class="ow">not</span> <span class="n">chan</span><span class="o">.</span><span class="n">eliminated</span> <span class="ow">and</span> <span class="n">chan</span><span class="o">.</span><span class="n">reaction</span> <span class="o">==</span> <span class="n">reactionp</span><span class="p">]</span>

            <span class="c1"># Main algorithm</span>
            <span class="c1"># Some words on the looping over L here.  There are 3 reasons to keep looping:</span>
            <span class="c1">#   1. We have less than 3 Legendre moments (L=0,1,2).  At threshold we have L=0 only, but otherwise had better have more.</span>
            <span class="c1">#   2. If we hit LMax or all the biggest L moments are too small, then stop, otherwise keep going</span>
            <span class="c1">#   3. We end on an odd L index.  That means Lmax must be even because LMax = last L-1</span>
            <span class="c1"># By the way, we must have an even LMax.  See the getLMax() documentation for reasoning.</span>
            <span class="n">L</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">reactionp</span><span class="p">])</span><span class="o">&lt;=</span><span class="mi">3</span> <span class="ow">or</span> <span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">reactionp</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">&gt;=</span><span class="n">relTol</span><span class="o">*</span><span class="n">B</span><span class="p">[</span><span class="n">reactionp</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span> <span class="ow">and</span> <span class="n">L</span><span class="o">&lt;=</span><span class="n">Lmax</span> <span class="p">)</span> <span class="ow">or</span> <span class="n">L</span><span class="o">%</span><span class="mi">2</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">B</span><span class="p">[</span><span class="n">reactionp</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">E</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">S</span> <span class="ow">in</span> <span class="n">allowedSpins</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">Sp</span> <span class="ow">in</span> <span class="n">allowedSpinsp</span><span class="p">:</span>
                        <span class="n">spinFactor</span> <span class="o">=</span>  <span class="nb">pow</span><span class="p">(</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">S</span> <span class="o">-</span> <span class="n">Sp</span> <span class="p">)</span> <span class="o">/</span> <span class="mf">4.0</span>
                        <span class="k">for</span> <span class="n">i1</span><span class="p">,</span> <span class="n">c1</span> <span class="ow">in</span> <span class="n">incidentChannels</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">c1</span><span class="o">.</span><span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">spins_equal</span><span class="p">(</span><span class="n">c1</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span> <span class="k">continue</span> <span class="c1"># c1.s != S: continue</span>
                            <span class="k">for</span> <span class="n">i2</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="n">incidentChannels</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">c2</span><span class="o">.</span><span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">spins_equal</span><span class="p">(</span><span class="n">c2</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span> <span class="k">continue</span> <span class="c1"># c2.s != S: continue</span>
                                <span class="n">Z</span> <span class="o">=</span> <span class="n">nf_amc</span><span class="o">.</span><span class="n">zbar_coefficient</span><span class="p">(</span> <span class="nb">int</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">c1</span><span class="o">.</span><span class="n">l</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">c1</span><span class="o">.</span><span class="n">J</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">c2</span><span class="o">.</span><span class="n">l</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">c2</span><span class="o">.</span><span class="n">J</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">S</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">L</span><span class="p">)</span> <span class="p">)</span>
                                <span class="k">if</span> <span class="n">Z</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span> <span class="k">continue</span>
                                <span class="k">for</span> <span class="n">i1p</span><span class="p">,</span> <span class="n">c1p</span> <span class="ow">in</span> <span class="n">outgoingChannels</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="n">c1</span><span class="o">.</span><span class="n">J</span> <span class="o">!=</span> <span class="n">c1p</span><span class="o">.</span><span class="n">J</span><span class="p">:</span> <span class="k">continue</span>
                                    <span class="k">if</span> <span class="n">c1p</span><span class="o">.</span><span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">spins_equal</span><span class="p">(</span><span class="n">c1p</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">Sp</span><span class="p">):</span> <span class="k">continue</span> <span class="c1"># c1p.s != Sp: continue</span>
                                    <span class="k">for</span> <span class="n">i2p</span><span class="p">,</span> <span class="n">c2p</span> <span class="ow">in</span> <span class="n">outgoingChannels</span><span class="p">:</span>
                                        <span class="k">if</span> <span class="n">c2</span><span class="o">.</span><span class="n">J</span> <span class="o">!=</span> <span class="n">c2p</span><span class="o">.</span><span class="n">J</span><span class="p">:</span> <span class="k">continue</span>
                                        <span class="k">if</span> <span class="n">c2p</span><span class="o">.</span><span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">spins_equal</span><span class="p">(</span><span class="n">c2p</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">Sp</span><span class="p">):</span> <span class="k">continue</span> <span class="c1"># c2p.s != Sp: continue</span>
                                        <span class="n">Zp</span> <span class="o">=</span> <span class="n">nf_amc</span><span class="o">.</span><span class="n">zbar_coefficient</span><span class="p">(</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">c1p</span><span class="o">.</span><span class="n">l</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">c1p</span><span class="o">.</span><span class="n">J</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">c2p</span><span class="o">.</span><span class="n">l</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">c2p</span><span class="o">.</span><span class="n">J</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Sp</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="p">)</span> <span class="p">)</span>
                                        <span class="k">if</span> <span class="n">Zp</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span> <span class="k">continue</span>
                                        <span class="n">thisB</span> <span class="o">=</span> <span class="n">spinFactor</span> <span class="o">*</span> <span class="n">Z</span> <span class="o">*</span> <span class="n">Zp</span> <span class="o">*</span> <span class="p">(</span> <span class="n">T</span><span class="p">[:,</span><span class="n">i1</span><span class="p">,</span><span class="n">i1p</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="o">*</span> <span class="n">T</span><span class="p">[:,</span><span class="n">i2</span><span class="p">,</span><span class="n">i2p</span><span class="p">]</span> <span class="p">)</span><span class="o">.</span><span class="n">real</span>
                                        <span class="n">B</span><span class="p">[</span><span class="n">reactionp</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">thisB</span><span class="p">[:,</span><span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                <span class="n">L</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">for</span> <span class="n">l</span><span class="p">,</span><span class="n">coefs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="n">B</span><span class="p">[</span><span class="n">reactionp</span><span class="p">]</span> <span class="p">):</span>
                <span class="n">results</span><span class="p">[</span><span class="n">reactionp</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">prefactor</span> <span class="o">/</span> <span class="p">(</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">l</span><span class="o">+</span><span class="mf">1.0</span> <span class="p">)</span> <span class="o">*</span> <span class="n">coefs</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">renormalize</span><span class="p">:</span>
                <span class="n">L0term</span><span class="o">=</span><span class="n">results</span><span class="p">[</span><span class="n">reactionp</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">L0term</span><span class="o">&lt;</span><span class="mf">1e-16</span><span class="p">):</span> <span class="n">L0term</span><span class="p">[</span><span class="n">L0term</span><span class="o">&lt;</span><span class="mf">1e-16</span><span class="p">]</span><span class="o">=</span><span class="mf">1e-16</span> <span class="c1">#takes care of questionable behavior near threshold</span>
                <span class="n">results</span><span class="p">[</span><span class="n">reactionp</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="n">x</span><span class="o">/</span><span class="n">L0term</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">results</span><span class="p">[</span><span class="n">reactionp</span><span class="p">]</span> <span class="p">]</span>

        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="RRBaseClass.getAverageQuantities"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getAverageQuantities">[docs]</a>    <span class="k">def</span> <span class="nf">getAverageQuantities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nBins</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">binScheme</span><span class="o">=</span><span class="s1">&#39;linspacing&#39;</span><span class="p">,</span> <span class="n">computeUncertainty</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes average widths and level spacings from the set of resonance parameters in self, on a per-channel basis</span>

<span class="sd">        The averages are computed in equal lethargy bins starting at the lowest resonance energy in a sequence up to the</span>
<span class="sd">        upperBound of the resonance region.  I tried to keep on average 10 resonances/logrithmic bin so I can get a</span>
<span class="sd">        reasonable average.</span>

<span class="sd">        :param nBins: the number of resonances per logrithmic bin to aim for, on average</span>
<span class="sd">        :param binScheme: the scheme to use to determine the binning</span>
<span class="sd">        :param computeUncertainty: toggle the calculation of the uncertainty of the quantities</span>
<span class="sd">        :return: a dictionary of results, sorted by channel.  If an entry is None, this indicates it could not be computed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">mean</span><span class="p">,</span><span class="n">var</span>
        <span class="n">results</span><span class="o">=</span><span class="p">{}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">binScheme</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;linspacing&#39;</span><span class="p">,</span><span class="s1">&#39;logspacing&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Allowed binning schemes are &#39;linspacing&#39; and &#39;logspacing&#39;&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span><span class="p">:</span>
            <span class="c1"># initialize the acumulators</span>
            <span class="n">numResonancesUsed</span><span class="o">=</span><span class="mi">0</span>
            <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;energyGrid&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;widths&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;spacings&#39;</span><span class="p">:</span> <span class="p">[]}</span>

            <span class="c1"># determine if we have resonances to average</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span><span class="p">[</span><span class="n">c</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">continue</span>
            <span class="k">try</span><span class="p">:</span>                <span class="n">ERmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span> <span class="p">[</span> <span class="n">xx</span> <span class="k">for</span> <span class="n">xx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">xx</span><span class="o">&gt;</span><span class="mi">0</span> <span class="p">]</span> <span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="n">ERmin</span> <span class="o">=</span> <span class="mf">1.0</span>

            <span class="c1"># get the resonances for this channel</span>
            <span class="n">res</span><span class="o">=</span><span class="p">[</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_energies</span><span class="p">[</span><span class="n">iR</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">iR</span><span class="p">])</span> <span class="k">for</span> <span class="n">iR</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="p">]</span>
            <span class="n">res</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># compute the number of bins to use in practice, must be at least 1 bin</span>
            <span class="n">nBins</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">nBins</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)),</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># compute the bin boundaries</span>
            <span class="n">lowerBound</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span><span class="p">,</span> <span class="mf">25.85e-3</span><span class="p">),</span> <span class="n">ERmin</span><span class="p">)</span>
            <span class="n">upperBound</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span>
            <span class="k">if</span> <span class="n">binScheme</span><span class="o">==</span><span class="s1">&#39;logspacing&#39;</span><span class="p">:</span>
                <span class="n">bins</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">lowerBound</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">upperBound</span><span class="p">),</span> <span class="n">nBins</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bins</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">lowerBound</span><span class="p">,</span> <span class="n">upperBound</span><span class="p">,</span> <span class="n">nBins</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;energyGrid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bins</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">reaction</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">J</span><span class="p">,</span> <span class="s1">&#39;bins:&#39;</span><span class="p">,</span><span class="n">bins</span><span class="p">)</span>

            <span class="c1"># compute averages in a bin</span>
            <span class="k">for</span> <span class="n">i1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="c1"># note filters out negative energy resonances and high energy resonances whose tails make a background</span>
                <span class="n">EGam</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_energies</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_energies</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">bins</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_energies</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">bins</span><span class="p">[</span><span class="n">i1</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">EGam</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                <span class="c1"># Compute mean level spacing</span>
                <span class="n">spacingsList</span><span class="o">=</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">EGam</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">EGam</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">EGam</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
                <span class="n">widthList</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">EGam</span><span class="p">]</span>

                <span class="c1"># initialization</span>
                <span class="n">actualResonancesPerBin</span> <span class="o">=</span>  <span class="nb">len</span><span class="p">(</span><span class="n">widthList</span><span class="p">)</span>
                <span class="n">numResonancesUsed</span>      <span class="o">+=</span> <span class="n">actualResonancesPerBin</span>
                <span class="n">D</span>     <span class="o">=</span> <span class="kc">None</span>
                <span class="n">Gamma</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">spacingsList</span><span class="p">,</span> <span class="n">widthList</span><span class="p">)</span>

                <span class="c1"># enough resonances to make an average D, Gamma</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spacingsList</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">computeUncertainty</span><span class="p">:</span>
                        <span class="n">D</span>     <span class="o">=</span> <span class="n">PQUModule</span><span class="o">.</span><span class="n">PQU</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">mean</span><span class="p">(</span><span class="n">spacingsList</span><span class="p">),</span> <span class="n">uncertainty</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var</span><span class="p">(</span><span class="n">spacingsList</span><span class="p">)),</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;eV&#39;</span><span class="p">)</span>
                        <span class="n">Gamma</span> <span class="o">=</span> <span class="n">PQUModule</span><span class="o">.</span><span class="n">PQU</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">mean</span><span class="p">(</span><span class="n">widthList</span><span class="p">),</span> <span class="n">uncertainty</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var</span><span class="p">(</span><span class="n">widthList</span><span class="p">)),</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;eV&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">D</span>     <span class="o">=</span> <span class="n">PQUModule</span><span class="o">.</span><span class="n">PQU</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">mean</span><span class="p">(</span><span class="n">spacingsList</span><span class="p">),</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;eV&#39;</span><span class="p">)</span>
                        <span class="n">Gamma</span> <span class="o">=</span> <span class="n">PQUModule</span><span class="o">.</span><span class="n">PQU</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">mean</span><span class="p">(</span><span class="n">widthList</span><span class="p">),</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;eV&#39;</span><span class="p">)</span>

                <span class="c1"># only one width, we can &quot;average&quot; it, but the spacing is meaningless</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">widthList</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">Gamma</span> <span class="o">=</span> <span class="n">PQUModule</span><span class="o">.</span><span class="n">PQU</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">widthList</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;eV&#39;</span><span class="p">)</span>

                <span class="c1"># save results</span>
                <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;spacings&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
                <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;widths&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Gamma</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="RRBaseClass.getTransmissionCoefficients"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getTransmissionCoefficients">[docs]</a>    <span class="k">def</span> <span class="nf">getTransmissionCoefficients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resonancesPerBin</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">computeUncertainty</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;weakCoupling&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the effective transmission coefficient in the resolved resonance regime.</span>
<span class="sd">        The method argument controls the schemes to do this.</span>

<span class="sd">        In each case, define the variable tau as::</span>

<span class="sd">            ..math::</span>
<span class="sd">                x_c = \\pi\\overline{\\Gamma}_c/D</span>

<span class="sd">        These are the options:</span>

<span class="sd">            * `method==&#39;weakCoupling&#39;`:  This is the traditional weak coupling limit::</span>

<span class="sd">                ..math::</span>
<span class="sd">                    T_c=2x_c</span>

<span class="sd">            * `method==&#39;1stOrder&#39;`: This is the same as the weak coupling limit.</span>

<span class="sd">            * `method==&#39;2ndOrder&#39;`: This is the 2nd order correction to the weak coupling limit::</span>

<span class="sd">                ..math::</span>
<span class="sd">                    T_c=2x_c(1-x_c)</span>

<span class="sd">            * `method==&#39;sumRule&#39;`: Use Moldauer&#39;s sum rule to extract the transmission coefficients directly from</span>
<span class="sd">              the RRR tables P.A. Moldauer Phys. Rev. Lett. 19, 1047-1048 (1967).  The equation is::</span>

<span class="sd">                ..math::</span>
<span class="sd">                    T_c=2x_c\\left[\\sqrt{1+x_c^2}-x_c\\right]</span>

<span class="sd">            * `method==&#39;opticalModel&#39;`: Use Moldauer&#39;s &#39;optical model&#39; transmission coefficient::</span>

<span class="sd">                ..math::</span>
<span class="sd">                    T_c=1-\\exp{(-2x_c)}</span>

<span class="sd">            * `method==&#39;SPRT&#39;`: Use the</span>

<span class="sd">                ..math::</span>
<span class="sd">                    T_c=\\frac{2x_c}{ (1 + x_c/2)^2 + (P_c R^\\inf_c)^2 }</span>

<span class="sd">        :param computeUncertainty: toggle the calculation of the uncertainty of the transmission coefficients</span>
<span class="sd">        :param resonancesPerBin: we&#39;ll try to get at least this number of resonances in each energy bin</span>
<span class="sd">        :param method: method to compute the transmission coefficient</span>
<span class="sd">        :return: a dictionary of results, sorted by channel.  Tc entries are all PQU&#39;s or None if it cannot be computed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">allowedMethods</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;weakCoupling&quot;</span><span class="p">,</span> <span class="s1">&#39;1stOrder&#39;</span><span class="p">,</span> <span class="s1">&#39;2ndOrder&#39;</span><span class="p">,</span> <span class="s1">&#39;sumRule&#39;</span><span class="p">,</span> <span class="s1">&#39;opticalModel&#39;</span><span class="p">,</span> <span class="s1">&#39;SPRT&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allowedMethods</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Transmission coefficient calculation method must be one of &#39;</span><span class="o">+</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">allowedMethods</span><span class="p">))</span>
        <span class="n">nBins</span><span class="o">=</span><span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span><span class="p">[</span><span class="n">c</span><span class="p">])</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span><span class="p">[</span><span class="n">c</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span><span class="o">//</span><span class="n">resonancesPerBin</span>
        <span class="n">aves</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getAverageQuantities</span><span class="p">(</span><span class="n">nBins</span><span class="o">=</span><span class="n">nBins</span><span class="p">,</span><span class="n">computeUncertainty</span><span class="o">=</span><span class="n">computeUncertainty</span><span class="p">)</span>
        <span class="n">results</span><span class="o">=</span><span class="p">{}</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">aves</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;Tc&#39;</span><span class="p">:[],</span><span class="s1">&#39;energyGrid&#39;</span><span class="p">:</span><span class="n">aves</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;energyGrid&#39;</span><span class="p">]}</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">aves</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;energyGrid&#39;</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">aves</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;spacings&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">aves</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;widths&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;Tc&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">twoPiGOverD</span><span class="o">=</span><span class="mf">2.0</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">aves</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;widths&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">aves</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;spacings&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;weakCoupling&quot;</span><span class="p">,</span><span class="s1">&#39;1stOrder&#39;</span><span class="p">]:</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;Tc&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">twoPiGOverD</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;2ndOrder&#39;</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;Tc&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">twoPiGOverD</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">twoPiGOverD</span><span class="o">/</span><span class="mf">2.0</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;sumRule&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">twoPiGOverD</span> <span class="o">&lt;</span> <span class="mf">1e-16</span><span class="p">:</span> <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;Tc&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">PQUModule</span><span class="o">.</span><span class="n">PQU</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">unit</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span> <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;Tc&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">twoPiGOverD</span><span class="o">*</span><span class="n">twoPiGOverD</span><span class="o">*</span><span class="p">(</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="mf">4.0</span><span class="o">/</span><span class="n">twoPiGOverD</span><span class="o">/</span><span class="n">twoPiGOverD</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;opticalModel&#39;</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;Tc&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">PQUModule</span><span class="o">.</span><span class="n">PQU</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">twoPiGOverD</span><span class="p">),</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1">#method==&quot;SPRT&quot;</span>
                    <span class="n">xx</span><span class="o">=</span><span class="mf">1.0</span><span class="o">+</span><span class="n">twoPiGOverD</span><span class="o">*</span><span class="n">twoPiGOverD</span><span class="o">/</span><span class="mf">4.0</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;Tc&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">twoPiGOverD</span><span class="o">/</span><span class="n">xx</span><span class="o">/</span><span class="n">xx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="RRBaseClass.getPoleStrength"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getPoleStrength">[docs]</a>    <span class="k">def</span> <span class="nf">getPoleStrength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">computeUncertainty</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the (usu. neutron) pole strength from Eq. (209) from JEFF Report 18::</span>

<span class="sd">            ..math::</span>
<span class="sd">                s_c(E) = \\frac{\\left&lt;\\gamma_c^2\\right&gt;}{D} = \\frac{\\overline{\\Gamma_c}(ER)}{2 D P_c(ER)}</span>

<span class="sd">        In the weak coupling limit, we could also use the transmission coefficient :math:`s_c(E)=T_c(ER)/4\\pi P_c`</span>

<span class="sd">        :param computeUncertainty:</span>
<span class="sd">        :return:  a dictionary of results, sorted by channel.</span>
<span class="sd">                  Pole strength entries are all PQU&#39;s or None if it cannot be computed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">numbers</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">aves</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAverageQuantities</span><span class="p">(</span><span class="n">computeUncertainty</span><span class="o">=</span><span class="n">computeUncertainty</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">aves</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;sc&#39;</span><span class="p">:[],</span> <span class="s1">&#39;energyGrid&#39;</span><span class="p">:</span><span class="n">aves</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;energyGrid&#39;</span><span class="p">]}</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">aves</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;energyGrid&#39;</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">aves</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;spacings&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">aves</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;widths&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span><span class="p">[</span><span class="n">c</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;sc&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="n">Emin</span><span class="o">=</span><span class="n">aves</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;energyGrid&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">Emax</span><span class="o">=</span><span class="n">aves</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;energyGrid&#39;</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">redWidths</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getReducedWidths</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">Emin</span><span class="o">=</span><span class="n">Emin</span><span class="p">,</span> <span class="n">Emax</span><span class="o">=</span><span class="n">Emax</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">redWidths</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>  <span class="c1"># Why do I need this test?</span>
                    <span class="n">redWidths</span> <span class="o">=</span> <span class="p">[</span><span class="n">redWidths</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">redWidths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">gg</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">g</span><span class="o">*</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">redWidths</span><span class="p">])</span>
                <span class="n">ggUnc</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">var</span><span class="p">([</span><span class="n">g</span><span class="o">*</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">redWidths</span><span class="p">]))</span>
                <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;sc&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">PQUModule</span><span class="o">.</span><span class="n">PQU</span><span class="p">(</span><span class="n">gg</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;eV&#39;</span><span class="p">,</span> <span class="n">uncertainty</span><span class="o">=</span><span class="n">ggUnc</span><span class="p">)</span><span class="o">/</span><span class="n">aves</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;spacings&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="RRBaseClass.getScatteringLength"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getScatteringLength">[docs]</a>    <span class="k">def</span> <span class="nf">getScatteringLength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Said Mughabghab (Atlas of Neutron Resonances, 5th edition (2006) p. 19, eq. (1.54))</span>
<span class="sd">        defines R&#39; as the s-wave scattering length, calculable from the potential</span>
<span class="sd">        scattering cross section sigPot = 4 Pi (R&#39;)^2.</span>

<span class="sd">        We compute the potential scattering cross section at E=1e-5 eV via</span>

<span class="sd">        ..math::</span>
<span class="sd">            \\sigma_{pot} = \\sum_L 4\\pi g_J\\frac{\\sin(\\phi_L(E))}{k^2}</span>

<span class="sd">        As Mughabghab only gives the S-wave scattering length, we provide the option of choosing an L as an argument</span>
<span class="sd">        to the function.  If L is supplied by the user, only that L is used in the calculation of R&#39;, otherwise all</span>
<span class="sd">        L&#39;s are used.</span>

<span class="sd">        R&#39; is given in in b**1/2 and should be close to AP.  It won&#39;t be exactly the same because of the</span>
<span class="sd">        contribution of distant levels.  Froehner (JEFF Report 18) Eq. (214) and the Atlas Eq. (1.51) give</span>

<span class="sd">        ..math::</span>
<span class="sd">            R&#39; = AP*(1-R^\\infty)</span>

<span class="sd">        where AP is the scattering length given in the file for the R-matrix parameterization and R^\\infty is the</span>
<span class="sd">        distant level parameter, related to the pole strength (call getPoleStrength) as a Hilbert transform, or</span>
<span class="sd">        by direct summation such as Atlas Eq. (1.52):</span>

<span class="sd">        ..math::</span>
<span class="sd">            R^\\infty=\\sum_n \\frac{\\gamma_n^2}{E_n-E}</span>

<span class="sd">        :param L: either an integer (the angular momentum to use) or None (all angular momentum)</span>
<span class="sd">        :return: R&#39;, the scattering radius, in b**1/2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">E</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">PQUModule</span><span class="o">.</span><span class="n">PQU</span><span class="p">(</span><span class="mf">1e-5</span><span class="p">,</span> <span class="s1">&#39;eV&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">)</span> <span class="p">])</span>
        <span class="n">sigPotL</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">isElastic</span><span class="p">:</span> <span class="k">continue</span>
            <span class="k">if</span> <span class="n">L</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span> <span class="o">==</span> <span class="n">L</span><span class="p">:</span>
                <span class="n">sigPotL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">gfact</span> <span class="o">*</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">phiByChannel</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">E</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span>
        <span class="n">sigPot</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">sigPotL</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sigPot</span><span class="o">/</span><span class="mf">4.0</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="RRBaseClass.getReducedWidths"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getReducedWidths">[docs]</a>    <span class="k">def</span> <span class="nf">getReducedWidths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">Emin</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">Emax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the widths corresponding to `channel` to reduced widths in the usual way (JEFF Report 18, Eq. (174))::</span>

<span class="sd">            ..math::</span>
<span class="sd">                \\gamma_c = \\sqrt{\\Gamma_c(E_R)/2P_c(E_R)}</span>

<span class="sd">        Here :math:`\\gamma_c` is the reduced width, :math:`\\Gamma_c` is the regular width, tabulated in the ENDF file,</span>
<span class="sd">        :math:`E_R` is the resonance energy (ignoring shifts), and :math:`P_c(E)` is the penetrability factor.</span>

<span class="sd">        :param Emin: The minimum resonance energy to convert to reduced width (in eV), defaults to 0.0.</span>
<span class="sd">                     If set to None, all resonances will be converted.</span>
<span class="sd">        :param Emax: The maximum resonance energy to convert to reduced width (in eV), defaults to None.</span>
<span class="sd">                     If set to None, all resonances will be converted.</span>
<span class="sd">        :param channel: The ChannelDesignator of the widths to be converted.</span>
<span class="sd">        :return: the list of reduced widths corresponding to the resonances in the range [Emin, Emax]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reducedWidthList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ERs</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">iR</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span><span class="p">[</span><span class="n">channel</span><span class="p">]:</span>
            <span class="n">ER</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_energies</span><span class="p">[</span><span class="n">iR</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">Emin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ER</span> <span class="o">&lt;</span> <span class="n">Emin</span><span class="p">:</span> <span class="k">continue</span>
            <span class="k">if</span> <span class="n">Emax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ER</span> <span class="o">&gt;</span> <span class="n">Emax</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">ERs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ER</span><span class="p">)</span>
            <span class="n">reducedWidthList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="n">iR</span><span class="p">])</span><span class="o">/</span><span class="mf">2.0</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactorByChannel</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">ER</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">reducedWidthList</span></div>

<div class="viewcode-block" id="RRBaseClass.getPorterThomasFitToWidths"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RRBaseClass.getPorterThomasFitToWidths">[docs]</a>    <span class="k">def</span> <span class="nf">getPorterThomasFitToWidths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Emin</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">Emax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform a channel-by-channel fit of the histogram of widths to a Porter-Thomas distribution.</span>

<span class="sd">        :param verbose:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">scipy.optimize</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;WARNING: scipy.optimize not imported, Porter-Thomas analysis not done&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{}</span>
        <span class="k">try</span><span class="p">:</span> <span class="kn">import</span> <span class="nn">numpy</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;WARNING: numpy&#39;s histogram() and mean() functions not imported, Porter-Thomas analysis not done&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{}</span>
        <span class="n">results</span><span class="o">=</span><span class="p">{}</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span><span class="p">[</span><span class="n">c</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span> <span class="s1">&#39;    not enough data&#39;</span> <span class="p">)</span>
                <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span><span class="mf">1.0</span><span class="p">,</span><span class="s1">&#39;ddof&#39;</span><span class="p">:</span><span class="mf">0.0</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">reducedWidthList</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getReducedWidths</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">Emin</span><span class="o">=</span><span class="n">Emin</span><span class="p">,</span> <span class="n">Emax</span><span class="o">=</span><span class="n">Emax</span><span class="p">)</span>
                <span class="n">aveWidth</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">reducedWidthList</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reducedWidthList</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="n">norm</span><span class="o">=</span><span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">norm</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">reducedWidthList</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span> <span class="s1">&#39;    widths&#39;</span><span class="p">,</span> <span class="n">reducedWidthList</span> <span class="p">)</span>
                <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    not enough widths to fit&#39;</span><span class="p">)</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;ddof&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">}</span>
                <span class="k">elif</span> <span class="nb">all</span><span class="p">([</span><span class="n">w</span><span class="o">==</span><span class="n">reducedWidthList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">reducedWidthList</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span> <span class="s1">&#39;    widths identical&#39;</span> <span class="p">)</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span><span class="mf">1.0</span><span class="p">,</span><span class="s1">&#39;ddof&#39;</span><span class="p">:</span><span class="mf">0.0</span><span class="p">}</span>
                <span class="k">elif</span> <span class="n">aveWidth</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">aveWidth</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span> <span class="s1">&#39;    widths are zero or nan&#39;</span> <span class="p">)</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span><span class="mf">1.0</span><span class="p">,</span><span class="s1">&#39;ddof&#39;</span><span class="p">:</span><span class="mf">0.0</span><span class="p">}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span> <span class="s1">&#39;    scaled widths&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">w</span><span class="o">/</span><span class="n">aveWidth</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">reducedWidthList</span><span class="p">]</span> <span class="p">)</span>
                    <span class="n">hist</span><span class="p">,</span> <span class="n">bin_edges</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">histogram</span><span class="p">([</span><span class="n">w</span><span class="o">/</span><span class="n">aveWidth</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">reducedWidthList</span><span class="p">])</span>
                    <span class="c1">#if verbose:  print &#39;    hist&#39;,hist, any(hist)</span>
                    <span class="c1">#if verbose:  print &#39;    bins&#39;, bin_edges, any(bin_edges)</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span> <span class="s1">&#39;    fitting:&#39;</span> <span class="p">)</span>

                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">hist</span><span class="p">):</span>

                        <span class="k">def</span> <span class="nf">PorterThomasDistribution</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">nu</span><span class="p">):</span>
<span class="w">                            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                            Porter-Thomas distribution</span>
<span class="sd">                            Froehner&#39;s eq. (277).</span>
<span class="sd">                            Really just a chi^2 distribution with nu degrees of freedom</span>

<span class="sd">                            :param y:</span>
<span class="sd">                            :param nu:</span>
<span class="sd">                            :return:</span>
<span class="sd">                            &quot;&quot;&quot;</span>
                            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;        y&#39;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;        norm&#39;</span><span class="p">,</span> <span class="n">norm</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;        nu&#39;</span><span class="p">,</span><span class="n">nu</span><span class="p">)</span>
                            <span class="n">gam</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="n">nu</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">nu</span> <span class="o">&lt;</span> <span class="mf">2.0</span><span class="p">:</span>
                                <span class="n">ycut</span><span class="o">=</span><span class="nb">pow</span><span class="p">(</span><span class="mf">1e4</span><span class="o">*</span><span class="n">gam</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">nu</span><span class="o">/</span><span class="mf">2.0</span><span class="p">))</span>
                                <span class="n">y</span><span class="p">[</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">ycut</span><span class="p">]</span><span class="o">=</span><span class="n">ycut</span>
                            <span class="k">return</span> <span class="n">norm</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">nu</span><span class="o">/</span><span class="mf">2.0</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span><span class="o">/</span><span class="n">gam</span>

                        <span class="n">popt</span><span class="p">,</span><span class="n">pcov</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">curve_fit</span><span class="p">(</span> <span class="n">PorterThomasDistribution</span><span class="p">,</span> <span class="p">[(</span><span class="n">bin_edges</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">bin_edges</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">)],</span> <span class="n">hist</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mf">0.0</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span> <span class="p">)</span> <span class="c1"># dump 1st bin, missing resonances there</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    popt&#39;</span><span class="p">,</span><span class="n">popt</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    pcov&#39;</span><span class="p">,</span><span class="n">pcov</span><span class="p">)</span>
                        <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dof&#39;</span><span class="p">:</span><span class="n">popt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;ddof&#39;</span><span class="p">:</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">pcov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span><span class="s1">&#39;bin_edges&#39;</span><span class="p">:</span><span class="n">bin_edges</span><span class="p">,</span><span class="s1">&#39;hist&#39;</span><span class="p">:</span><span class="n">hist</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">results</span></div></div>


<span class="c1">#### Single-level Breit-Wigner ###</span>
<div class="viewcode-block" id="SLBWcrossSection"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.SLBWcrossSection">[docs]</a><span class="k">class</span> <span class="nc">SLBWcrossSection</span><span class="p">(</span><span class="n">RRBaseClass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resonance reconstructor for Singe-level Breit Wigner.</span>

<span class="sd">    Note, the resonances in the SLBW format each correspond to different &quot;levels&quot; and so do not</span>
<span class="sd">    interfere.  This is unlike all of the other resolved resonance formats.  So, while one resonance energy</span>
<span class="sd">    and one width go with one channel and all the channels associated with one resonance energy</span>
<span class="sd">    go together to make one reaction, the reactions for each resonance are added incoherently (no</span>
<span class="sd">    interference effects at all).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">BreitWignerForm</span><span class="p">,</span> <span class="n">enableAngDists</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="n">BreitWignerForm</span><span class="o">.</span><span class="n">ancestor</span>
        <span class="n">RRBaseClass</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">BreitWignerForm</span><span class="p">,</span> <span class="n">parent</span><span class="o">.</span><span class="n">domainMin</span><span class="p">,</span> <span class="n">parent</span><span class="o">.</span><span class="n">domainMax</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sortLandJ</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;From </span><span class="si">%f</span><span class="s2"> to </span><span class="si">%f</span><span class="s2"> </span><span class="si">%s</span><span class="s2">, reconstructing using Single-level Breit-Wigner&quot;</span> <span class="o">%</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">enableAngDists</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">setResonanceParametersByChannel</span><span class="p">()</span>

<div class="viewcode-block" id="SLBWcrossSection.setResonanceParametersByChannel"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.SLBWcrossSection.setResonanceParametersByChannel">[docs]</a>    <span class="k">def</span> <span class="nf">setResonanceParametersByChannel</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">multipleSScheme</span><span class="o">=</span><span class="s1">&#39;ENDF&#39;</span><span class="p">,</span> <span class="n">useReichMooreApproximation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">Ein</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">warnOnly</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reorganize member data into channels (relies heavily on groundwork in sortLandJ).</span>

<span class="sd">        Note, unlike the getResonanceParametersByChannel() function in MLBW, RM or RML,</span>
<span class="sd">        the fact that different resonances are entirely different reactions means that the</span>
<span class="sd">        channelDicts have to have an additional layer of sorting that corresponds to the SLBW &quot;level&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># make a unified table of resonance parameter data, convert to self.energyUnit if necessary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nResonances</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span> <span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">,</span><span class="s1">&#39;L&#39;</span><span class="p">,</span><span class="s1">&#39;J&#39;</span><span class="p">,</span><span class="s1">&#39;channelSpin&#39;</span><span class="p">,</span><span class="s1">&#39;totalWidth&#39;</span><span class="p">,</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">,</span><span class="s1">&#39;captureWidth&#39;</span><span class="p">,</span>
                <span class="s1">&#39;fissionWidth&#39;</span><span class="p">,</span><span class="s1">&#39;fissionWidthB&#39;</span><span class="p">)</span>
        <span class="n">EU</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span>
        <span class="n">units</span> <span class="o">=</span> <span class="p">(</span><span class="n">EU</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="n">EU</span><span class="p">,</span><span class="n">EU</span><span class="p">,</span><span class="n">EU</span><span class="p">,</span><span class="n">EU</span><span class="p">,</span><span class="n">EU</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span> <span class="n">quant</span><span class="p">,</span><span class="n">unit</span> <span class="p">)</span> <span class="k">for</span> <span class="n">quant</span><span class="p">,</span><span class="n">unit</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="n">units</span><span class="p">)</span> <span class="p">]</span>
        <span class="n">warnings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nResonances</span>

        <span class="n">allowedSs</span> <span class="o">=</span> <span class="n">getAllowedTotalSpins</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">projectileSpin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetSpin</span><span class="p">,</span> <span class="n">useFactor2Trick</span><span class="o">=</span><span class="kc">False</span> <span class="p">)</span>

        <span class="c1"># Now make the dictionary of channels, grouped by independent level</span>
        <span class="n">channelDicts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">iR</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">nResonances</span> <span class="p">):</span>
            <span class="n">ER</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span>
            <span class="n">L</span> <span class="o">=</span>  <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span>
            <span class="n">J</span> <span class="o">=</span>  <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span>
            <span class="n">S</span> <span class="o">=</span>  <span class="kc">None</span> <span class="c1"># not given in SLBW, I just list it here for completeness</span>
            <span class="n">GT</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span>
            <span class="n">GN</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span>
            <span class="n">GG</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span>
            <span class="n">GF</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span>
            <span class="n">GX</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">8</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span>
            <span class="n">JisAllowed</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">allowedSByThisJl</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">SS</span> <span class="ow">in</span> <span class="n">allowedSs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="ow">in</span> <span class="n">getAllowedTotalSpins</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">useFactor2Trick</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
                    <span class="n">JisAllowed</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">allowedSByThisJl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">SS</span> <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">JisAllowed</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">warnOnly</span><span class="p">:</span>
                    <span class="n">allowedSByThisJl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">SS</span> <span class="p">)</span>
                    <span class="kn">from</span> <span class="nn">fudge</span> <span class="kn">import</span> <span class="n">warning</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">warning</span><span class="o">.</span><span class="n">InvalidAngularMomentaCombination</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;SLBW&#39;</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s2">&quot;Invalid total angular momentum and/or orbital momentum: cannot couple up to J = &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">J</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; with I = &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetSpin</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;, i = 0.5 and L = &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="p">)</span>
            <span class="n">gfact</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">projectileSpin</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">targetSpin</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">channelDict</span><span class="o">=</span><span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">numAllowedSByThisJl</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">allowedSByThisJl</span> <span class="p">)</span>

            <span class="c1"># Way recommended by NJOY:</span>
            <span class="c1">#   * One of valid S&#39;s get width, other(s) get zero width</span>
            <span class="c1">#   * Zero width channels left in sum to get potential scattering correct</span>
            <span class="c1">#   * Gets good (cs from U) to (cs from Fudge) comparison; good (cs from U) to (cs from BB)</span>
            <span class="k">if</span> <span class="n">multipleSScheme</span> <span class="o">==</span> <span class="s1">&#39;NJOY&#39;</span><span class="p">:</span>
                <span class="n">channelDict</span><span class="p">[</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;elastic&#39;</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">allowedSByThisJl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">NEUTRONCHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">)]</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span> <span class="n">ER</span><span class="p">,</span> <span class="n">GN</span> <span class="p">)</span> <span class="p">]</span>
                <span class="n">channelDict</span><span class="p">[</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;capture&#39;</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">allowedSByThisJl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">GAMMACHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">)]</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span> <span class="n">ER</span><span class="p">,</span> <span class="n">GG</span> <span class="p">)</span> <span class="p">]</span>
                <span class="k">if</span> <span class="n">GF</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="n">channelDict</span><span class="p">[</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;fission&#39;</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">allowedSByThisJl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">FISSIONCHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">)]</span>     <span class="o">=</span> <span class="p">[</span> <span class="p">(</span> <span class="n">ER</span><span class="p">,</span> <span class="n">GF</span> <span class="p">)</span> <span class="p">]</span>
                <span class="k">if</span> <span class="n">GX</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="n">channelDict</span><span class="p">[</span> <span class="n">ChannelDesignator</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;competitive&#39;</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">allowedSByThisJl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">COMPETITIVECHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ER</span><span class="p">,</span> <span class="n">GX</span><span class="p">)]</span>
                <span class="k">for</span> <span class="n">SS</span> <span class="ow">in</span> <span class="n">allowedSByThisJl</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                    <span class="n">channelDict</span><span class="p">[</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;elastic&#39;</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">NEUTRONCHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">)]</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span> <span class="n">ER</span><span class="p">,</span> <span class="mf">0.0</span> <span class="p">)</span> <span class="p">]</span>
                    <span class="n">channelDict</span><span class="p">[</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;capture&#39;</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">GAMMACHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">)]</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span> <span class="n">ER</span><span class="p">,</span> <span class="mf">0.0</span> <span class="p">)</span> <span class="p">]</span>
                    <span class="k">if</span> <span class="n">GF</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="n">channelDict</span><span class="p">[</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;fission&#39;</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">FISSIONCHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">)]</span>     <span class="o">=</span> <span class="p">[</span> <span class="p">(</span> <span class="n">ER</span><span class="p">,</span> <span class="mf">0.0</span> <span class="p">)</span> <span class="p">]</span>
                    <span class="k">if</span> <span class="n">GX</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="n">channelDict</span><span class="p">[</span> <span class="n">ChannelDesignator</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;competitive&#39;</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">COMPETITIVECHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ER</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)]</span>

            <span class="c1"># Way mandated by ENDF manual:</span>
            <span class="c1">#   * Width divided between channels with valid S&#39;s based on sign of J:</span>
            <span class="c1">#       ** if J&gt;0, S is max possible value</span>
            <span class="c1">#       ** if J&lt;0, S is min possible value</span>
            <span class="c1">#   * All channels left in sum to get potential scattering correct</span>
            <span class="c1">#   * Gets poor (cs from U) to (cs from Fudge) comparison; poor (cs from U) to (cs from BB)</span>
            <span class="k">elif</span> <span class="n">multipleSScheme</span> <span class="o">==</span> <span class="s1">&#39;ENDF&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">allowedSByThisJl</span><span class="p">:</span>
                    <span class="n">allowedSByThisJl</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">allowedSByThisJl</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="n">SS</span><span class="o">=</span><span class="n">allowedSByThisJl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span> <span class="n">SS</span><span class="o">=</span><span class="n">allowedSByThisJl</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">)</span><span class="o">==</span><span class="n">J</span><span class="p">)]</span>
                    <span class="n">channelDict</span><span class="p">[</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;elastic&#39;</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">NEUTRONCHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">)]</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span> <span class="n">ER</span><span class="p">,</span> <span class="n">GN</span><span class="o">/</span><span class="n">numAllowedSByThisJl</span> <span class="p">)</span> <span class="p">]</span>
                    <span class="n">channelDict</span><span class="p">[</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;capture&#39;</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">GAMMACHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">)]</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span> <span class="n">ER</span><span class="p">,</span> <span class="n">GG</span><span class="o">/</span><span class="n">numAllowedSByThisJl</span> <span class="p">)</span> <span class="p">]</span>
                    <span class="k">if</span> <span class="n">GF</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="n">channelDict</span><span class="p">[</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;fission&#39;</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">FISSIONCHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">)]</span>     <span class="o">=</span> <span class="p">[</span> <span class="p">(</span> <span class="n">ER</span><span class="p">,</span> <span class="n">GF</span><span class="o">/</span><span class="n">numAllowedSByThisJl</span> <span class="p">)</span> <span class="p">]</span>
                    <span class="k">if</span> <span class="n">GX</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="n">channelDict</span><span class="p">[</span> <span class="n">ChannelDesignator</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;competitive&#39;</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">COMPETITIVECHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ER</span><span class="p">,</span> <span class="n">GX</span> <span class="o">/</span> <span class="n">numAllowedSByThisJl</span><span class="p">)]</span>

            <span class="c1"># Ignore problem:</span>
            <span class="c1">#   * Ignore spin of channels and the fact may be multiple valid spins</span>
            <span class="c1">#   * Gets best (cs from U) to (cs from Fudge) comparison; poor (cs from U) to (cs from BB)</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="n">channelDict</span><span class="p">[</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;elastic&#39;</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">NEUTRONCHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">)]</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span> <span class="n">ER</span><span class="p">,</span> <span class="n">GN</span> <span class="p">)</span> <span class="p">]</span>
                <span class="n">channelDict</span><span class="p">[</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;capture&#39;</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">GAMMACHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">)]</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span> <span class="n">ER</span><span class="p">,</span> <span class="n">GG</span> <span class="p">)</span> <span class="p">]</span>
                <span class="k">if</span> <span class="n">GF</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="n">channelDict</span><span class="p">[</span> <span class="n">ChannelDesignator</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;fission&#39;</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">FISSIONCHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span> <span class="p">)]</span>     <span class="o">=</span> <span class="p">[</span> <span class="p">(</span> <span class="n">ER</span><span class="p">,</span> <span class="n">GF</span> <span class="p">)</span> <span class="p">]</span>
                <span class="k">if</span> <span class="n">GX</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="n">channelDict</span><span class="p">[</span> <span class="n">ChannelDesignator</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="s1">&#39;competitive&#39;</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">gfact</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">COMPETITIVECHANNEL</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ER</span><span class="p">,</span> <span class="n">GX</span><span class="p">)]</span>
            <span class="n">channelDicts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">channelDict</span> <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">=</span> <span class="n">channelDicts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">warnOnly</span><span class="p">:</span> <span class="k">return</span> <span class="n">warnings</span></div>

<div class="viewcode-block" id="SLBWcrossSection.getScatteringMatrixU"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.SLBWcrossSection.getScatteringMatrixU">[docs]</a>    <span class="k">def</span> <span class="nf">getScatteringMatrixU</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span><span class="p">,</span> <span class="n">useTabulatedScatteringRadius</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">enableExtraCoulombPhase</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the scattering matrix</span>

<span class="sd">        Note, unlike the getScatteringMatrixU() function in other resonance classes,</span>
<span class="sd">        the fact that different resonances are entirely different reactions means that the</span>
<span class="sd">        channelDicts have to have an additional layer of sorting that corresponds to the SLBW &quot;level&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">(</span>
            <span class="p">[</span> <span class="p">(</span> <span class="n">iL</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span><span class="o">*</span><span class="p">[</span><span class="nb">complex</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)])</span> <span class="p">)</span> <span class="k">for</span> <span class="n">iL</span><span class="p">,</span><span class="n">cs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span> <span class="p">]</span> <span class="p">)</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">Ein</span><span class="p">)</span>

        <span class="c1"># For calculating phi, default is to use tabulated scattering radius:</span>
        <span class="k">if</span> <span class="n">useTabulatedScatteringRadius</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">getScatteringRadius</span><span class="p">()</span><span class="o">.</span><span class="n">isEnergyDependent</span><span class="p">():</span>
                <span class="n">rhohat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">getScatteringRadius</span><span class="p">()</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;10*fm&#39;</span><span class="p">,</span> <span class="n">Ein</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">Ein</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rhohat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">getScatteringRadius</span><span class="p">()</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;10*fm&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">Ein</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">rhohat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">Ein</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">iL</span><span class="p">,</span><span class="n">channels</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">):</span>
            <span class="n">ER</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_energies</span><span class="p">[</span><span class="n">iL</span><span class="p">]</span>
            <span class="n">ERp</span> <span class="o">=</span> <span class="n">ER</span>
            <span class="n">GamTot</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">eiphis</span> <span class="o">=</span> <span class="p">[</span> <span class="p">]</span>
            <span class="n">sqrtgams</span> <span class="o">=</span> <span class="p">[</span> <span class="p">]</span> <span class="c1"># all are real</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">reaction</span> <span class="o">==</span> <span class="s1">&#39;elastic&#39;</span><span class="p">:</span>
                    <span class="n">Gam</span> <span class="o">=</span> <span class="p">(</span> <span class="n">channels</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span> <span class="n">Ein</span> <span class="p">)</span> <span class="p">)</span> <span class="o">/</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span> <span class="nb">abs</span><span class="p">(</span> <span class="n">ER</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
                    <span class="n">ERp</span> <span class="o">+=</span> <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">shiftFactor</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span> <span class="nb">abs</span><span class="p">(</span> <span class="n">ER</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="o">-</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">shiftFactor</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span> <span class="n">Ein</span> <span class="p">)</span> <span class="p">)</span>
                        <span class="p">)</span> <span class="o">*</span> <span class="n">channels</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ER</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
                    <span class="n">eiphis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="nb">complex</span><span class="p">(</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">rhohat</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Gam</span> <span class="o">=</span> <span class="n">channels</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">eiphis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="nb">complex</span><span class="p">(</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span> <span class="p">)</span> <span class="p">)</span>
                <span class="n">sqrtgams</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">Gam</span> <span class="p">)</span> <span class="p">)</span>
                <span class="n">GamTot</span> <span class="o">+=</span> <span class="n">Gam</span>
            <span class="k">for</span> <span class="n">i1</span><span class="p">,</span> <span class="n">c1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">channels</span><span class="p">):</span>
                <span class="n">denominator</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span> <span class="n">ERp</span> <span class="o">-</span> <span class="n">Ein</span><span class="p">,</span> <span class="o">-</span><span class="n">GamTot</span><span class="o">/</span><span class="mf">2.0</span> <span class="p">)</span> <span class="c1"># c1 &amp; c2 have same l</span>
                <span class="k">for</span> <span class="n">i2</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">channels</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">c2</span><span class="o">.</span><span class="n">index</span> <span class="o">!=</span> <span class="n">c1</span><span class="o">.</span><span class="n">index</span><span class="p">:</span> <span class="k">continue</span>
                    <span class="n">U</span><span class="p">[</span><span class="n">iL</span><span class="p">][</span><span class="n">i1</span><span class="p">][</span><span class="n">i2</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">complex</span><span class="p">(</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">sqrtgams</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span><span class="o">*</span><span class="n">sqrtgams</span><span class="p">[</span><span class="n">i2</span><span class="p">]</span> <span class="p">)</span> <span class="o">/</span> <span class="n">denominator</span>
                    <span class="n">U</span><span class="p">[</span><span class="n">iL</span><span class="p">][</span><span class="n">i1</span><span class="p">][</span><span class="n">i2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">eiphis</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="o">*</span> <span class="n">eiphis</span><span class="p">[</span><span class="n">i2</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">U</span></div>

<div class="viewcode-block" id="SLBWcrossSection.getAngularDistribution"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.SLBWcrossSection.getAngularDistribution">[docs]</a>    <span class="k">def</span> <span class="nf">getAngularDistribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span> <span class="p">):</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Angular distributions cannot be safely reconstructed using Single-Level Breit-Wigner approximation&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SLBWcrossSection.getCrossSection"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.SLBWcrossSection.getCrossSection">[docs]</a>    <span class="nd">@blockwise</span>
    <span class="k">def</span> <span class="nf">getCrossSection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span>
        <span class="n">captureSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">elasticSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">fissionSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="n">rhohat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">forceUseTabulated</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>    <span class="c1"># for calculating phi, always use tabulated scattering radius</span>
        <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ls</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">]</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">rhohat</span><span class="p">)</span>
            <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span>
            <span class="n">S</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">shiftFactor</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">J</span> <span class="ow">in</span> <span class="n">L</span><span class="p">[</span><span class="s1">&#39;Js&#39;</span><span class="p">]:</span>
                <span class="n">gfactor</span> <span class="o">=</span> <span class="n">J</span><span class="p">[</span><span class="s1">&#39;gfact&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">spin</span> <span class="ow">in</span> <span class="n">J</span><span class="p">[</span><span class="s1">&#39;channelSpins&#39;</span><span class="p">]:</span>
                    <span class="k">try</span><span class="p">:</span>                    <span class="c1"># use C extension if available</span>
                        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">getBreitWignerSums</span>
                        <span class="n">capt</span><span class="p">,</span> <span class="n">elas</span><span class="p">,</span> <span class="n">fiss</span> <span class="o">=</span> <span class="n">getBreitWignerSums</span><span class="o">.</span><span class="n">getBreitWignerSums</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;energy&#39;</span><span class="p">],</span>
                                <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;captureWidth&#39;</span><span class="p">],</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">],</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;fissionWidth&#39;</span><span class="p">],</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;shiftFactor&#39;</span><span class="p">],</span>
                                <span class="n">P</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="s1">&#39;SingleLevel&#39;</span><span class="p">)</span>
                        <span class="n">captureSum</span> <span class="o">+=</span> <span class="n">gfactor</span> <span class="o">*</span> <span class="n">capt</span>
                        <span class="n">elasticSum</span> <span class="o">+=</span> <span class="n">gfactor</span> <span class="o">*</span> <span class="n">elas</span>
                        <span class="n">fissionSum</span> <span class="o">+=</span> <span class="n">gfactor</span> <span class="o">*</span> <span class="n">fiss</span>
                    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>     <span class="c1"># numpy version (memory-intensive)</span>
                        <span class="n">dE</span> <span class="o">=</span> <span class="p">(</span><span class="n">E</span><span class="o">-</span><span class="p">(</span><span class="n">spin</span><span class="p">[</span><span class="s1">&#39;energy&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">spin</span><span class="p">[</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">spin</span><span class="p">[</span><span class="s1">&#39;shiftFactor&#39;</span><span class="p">]</span><span class="o">-</span><span class="n">S</span><span class="p">)))</span>
                        <span class="n">totalWidth</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">spin</span><span class="p">[</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;captureWidth&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;fissionWidth&#39;</span><span class="p">]</span>
                        <span class="n">denominator</span> <span class="o">=</span> <span class="n">dE</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">totalWidth</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">4</span>
                        <span class="n">captureSum</span> <span class="o">+=</span> <span class="n">gfactor</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="p">(</span> <span class="n">P</span> <span class="o">*</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;captureWidth&#39;</span><span class="p">]</span> <span class="p">)</span> <span class="o">/</span> <span class="n">denominator</span> <span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">fissionSum</span> <span class="o">+=</span> <span class="n">gfactor</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="p">(</span> <span class="n">P</span> <span class="o">*</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;fissionWidth&#39;</span><span class="p">]</span> <span class="p">)</span> <span class="o">/</span> <span class="n">denominator</span> <span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">elasticSum</span> <span class="o">+=</span> <span class="n">gfactor</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="p">(</span> <span class="n">P</span><span class="o">*</span><span class="n">spin</span><span class="p">[</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span> <span class="n">P</span><span class="o">*</span><span class="n">spin</span><span class="p">[</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">]</span>
                            <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">totalWidth</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">E</span><span class="o">-</span><span class="n">spin</span><span class="p">[</span><span class="s1">&#39;energy&#39;</span><span class="p">])</span> <span class="p">)</span> <span class="p">)</span>
                            <span class="o">/</span> <span class="n">denominator</span> <span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># numpy.sum(..., axis=1) returns row vector, so also convert first term to row vector:</span>
            <span class="n">elasticSum</span> <span class="o">+=</span> <span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>

        <span class="c1"># get common factor &#39;beta&#39; as a row vector:</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">capture</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">captureSum</span>
        <span class="n">elastic</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">elasticSum</span>
        <span class="n">fission</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">fissionSum</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">removeNegatives</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">reaction</span> <span class="ow">in</span> <span class="p">(</span><span class="n">capture</span><span class="p">,</span><span class="n">elastic</span><span class="p">,</span><span class="n">fission</span><span class="p">):</span>
                <span class="n">reaction</span><span class="p">[</span> <span class="n">reaction</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">elastic</span> <span class="o">+</span> <span class="n">capture</span> <span class="o">+</span> <span class="n">fission</span>
        <span class="n">nonelastic</span> <span class="o">=</span> <span class="n">capture</span> <span class="o">+</span> <span class="n">fission</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;total&#39;</span><span class="p">:</span><span class="n">total</span><span class="p">,</span> <span class="s1">&#39;elastic&#39;</span><span class="p">:</span><span class="n">elastic</span><span class="p">,</span> <span class="s1">&#39;capture&#39;</span><span class="p">:</span><span class="n">capture</span><span class="p">,</span> <span class="s1">&#39;fission&#39;</span><span class="p">:</span><span class="n">fission</span><span class="p">,</span> <span class="s1">&#39;nonelastic&#39;</span><span class="p">:</span><span class="n">nonelastic</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="SLBWcrossSection.getScatteringLength"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.SLBWcrossSection.getScatteringLength">[docs]</a>    <span class="k">def</span> <span class="nf">getScatteringLength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute R&#39; in b^2/2, should be close to AP.</span>
<span class="sd">        The potential scattering cross section sigPot = 4 Pi (R&#39;)^2, so we compute the potential scattering cross section at E=1e-5 eV.</span>
<span class="sd">        :param kwargs:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">E</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">PQUModule</span><span class="o">.</span><span class="n">PQU</span><span class="p">(</span><span class="mf">1e-5</span><span class="p">,</span> <span class="s1">&#39;eV&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">)</span> <span class="p">])</span>
        <span class="n">sigPotL</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">isElastic</span><span class="p">:</span> <span class="k">continue</span>
                <span class="n">sigPotL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span> <span class="p">(</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="o">*</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">phiByChannel</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">E</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span>
        <span class="n">sigPot</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">sigPotL</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sigPot</span><span class="o">/</span><span class="mf">4.0</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div></div>

<span class="c1">#### Multi-level Breit-Wigner ###</span>
<div class="viewcode-block" id="MLBWcrossSection"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.MLBWcrossSection">[docs]</a><span class="k">class</span> <span class="nc">MLBWcrossSection</span><span class="p">(</span><span class="n">RRBaseClass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resonance reconstructor for Multi-level Breit-Wigner parameters.</span>
<span class="sd">    Only the elastic channel differs from SLBW.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">BreitWignerForm</span><span class="p">,</span> <span class="n">enableAngDists</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="n">BreitWignerForm</span><span class="o">.</span><span class="n">ancestor</span>
        <span class="n">RRBaseClass</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">BreitWignerForm</span><span class="p">,</span> <span class="n">parent</span><span class="o">.</span><span class="n">domainMin</span><span class="p">,</span> <span class="n">parent</span><span class="o">.</span><span class="n">domainMax</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sortLandJ</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;From </span><span class="si">%f</span><span class="s2"> to </span><span class="si">%f</span><span class="s2"> </span><span class="si">%s</span><span class="s2">, reconstructing using Multi-level Breit-Wigner&quot;</span> <span class="o">%</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">enableAngDists</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">setResonanceParametersByChannel</span><span class="p">()</span>

<div class="viewcode-block" id="MLBWcrossSection.getChannelConstantsBc"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.MLBWcrossSection.getChannelConstantsBc">[docs]</a>    <span class="k">def</span> <span class="nf">getChannelConstantsBc</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For ENDF&#39;s MLBW, should be :math:`B_c = S_\\ell(|E_\\lambda|)`</span>
<span class="sd">        where :math:`\\ell` is the channel angular momentum and :math:`\\lambda` is the resonances index for the channel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span> <span class="s2">&quot;write me&quot;</span> <span class="p">)</span></div>

<div class="viewcode-block" id="MLBWcrossSection.getScatteringMatrixU"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.MLBWcrossSection.getScatteringMatrixU">[docs]</a>    <span class="k">def</span> <span class="nf">getScatteringMatrixU</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span><span class="p">,</span> <span class="n">useTabulatedScatteringRadius</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">enableExtraCoulombPhase</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the scattering matrix.  We could have used the generic U function in the base class,</span>
<span class="sd">        but Froehner has &quot;simplifications&quot; that we took advantage of here (that and I don&#39;t know what the</span>
<span class="sd">        R matrix is exactly in the case of MLBW).</span>

<span class="sd">        :param Ein: numpy.array(type=float)</span>
<span class="sd">        :param boolean useTabulatedScatteringRadius:</span>
<span class="sd">        :param boolean enableExtraCoulombPhase:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize lists and matrices</span>
        <span class="n">sqrtGam</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ein</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nResonances</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ein</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span> <span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span> <span class="p">)</span>
        <span class="n">U</span><span class="p">[</span> <span class="p">:,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span> <span class="p">)</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">Gtots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nResonances</span> <span class="o">*</span> <span class="p">[</span> <span class="mf">0.0</span> <span class="p">]</span>
        <span class="n">ERp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_energies</span> <span class="p">)</span>
        <span class="n">eiphis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getEiPhis</span><span class="p">(</span>  <span class="n">Ein</span><span class="p">,</span> <span class="n">useTabulatedScatteringRadius</span> <span class="o">=</span> <span class="n">useTabulatedScatteringRadius</span> <span class="p">)</span>

        <span class="c1"># Precompute sqrt(Gamma) and sum up to get the total Gamma</span>
        <span class="c1"># Total Gamma may be different from what is given in the ENDF data file</span>
        <span class="c1"># Also, work out energy shifts</span>
        <span class="k">for</span> <span class="n">ic</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">reaction</span> <span class="o">==</span> <span class="s1">&#39;elastic&#39;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">iR</span><span class="p">,</span> <span class="n">G</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">ER</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_energies</span><span class="p">[</span><span class="n">iR</span><span class="p">]</span>
                    <span class="n">Gam</span> <span class="o">=</span> <span class="p">(</span> <span class="n">G</span> <span class="o">*</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span> <span class="n">Ein</span> <span class="p">)</span> <span class="p">)</span> <span class="o">/</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span> <span class="nb">abs</span><span class="p">(</span> <span class="n">ER</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
                    <span class="n">ERp</span><span class="p">[</span><span class="n">iR</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">shiftFactor</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span> <span class="nb">abs</span><span class="p">(</span> <span class="n">ER</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="o">-</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">shiftFactor</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span> <span class="n">Ein</span> <span class="p">)</span> <span class="p">)</span>
                        <span class="p">)</span> <span class="o">*</span> <span class="n">G</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ER</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
                    <span class="n">sqrtGam</span><span class="p">[</span> <span class="p">:,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">iR</span> <span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Gam</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                    <span class="n">Gtots</span><span class="p">[</span> <span class="n">iR</span> <span class="p">]</span> <span class="o">+=</span> <span class="n">Gam</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">iR</span><span class="p">,</span> <span class="n">G</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">ER</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_energies</span><span class="p">[</span><span class="n">iR</span><span class="p">]</span>
                    <span class="n">sqrtGam</span><span class="p">[</span> <span class="p">:,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">iR</span> <span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                    <span class="n">Gtots</span><span class="p">[</span> <span class="n">iR</span> <span class="p">]</span> <span class="o">+=</span> <span class="n">G</span>

        <span class="c1"># If the width in the ENDF file is bigger than the sum of parts, there is a competitive width</span>
        <span class="c1"># otherwise, the ENDF value is wrong, use the one we get from the sum of parts</span>
        <span class="k">for</span> <span class="n">iR</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">nResonances</span> <span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">Gtots</span><span class="p">[</span> <span class="n">iR</span> <span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_widths</span><span class="p">[</span> <span class="n">iR</span> <span class="p">]</span>
            <span class="n">Gtots</span><span class="p">[</span> <span class="n">iR</span> <span class="p">][</span> <span class="n">mask</span> <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_widths</span><span class="p">[</span> <span class="n">iR</span> <span class="p">]</span>

        <span class="c1"># Compute the denominator</span>
        <span class="n">DEN</span> <span class="o">=</span> <span class="n">ERp</span> <span class="o">-</span> <span class="n">Ein</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Gtots</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>

        <span class="c1"># Compute U itself.</span>
        <span class="k">for</span> <span class="n">i1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span> <span class="p">):</span>
            <span class="k">for</span> <span class="n">i2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">i1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span> <span class="p">):</span>
                <span class="n">U</span><span class="p">[:,</span><span class="n">i1</span><span class="p">,</span><span class="n">i2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">sqrtGam</span><span class="p">[:,</span><span class="n">i1</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">sqrtGam</span><span class="p">[:,</span><span class="n">i2</span><span class="p">,:]</span> <span class="o">/</span> <span class="n">DEN</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span> <span class="p">)</span>
                <span class="n">U</span><span class="p">[:,</span><span class="n">i1</span><span class="p">,</span><span class="n">i2</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="n">eiphis</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="o">*</span> <span class="n">eiphis</span><span class="p">[</span><span class="n">i2</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="n">U</span><span class="p">[:,</span><span class="n">i2</span><span class="p">,</span><span class="n">i1</span><span class="p">]</span> <span class="o">=</span> <span class="n">U</span><span class="p">[:,</span><span class="n">i1</span><span class="p">,</span><span class="n">i2</span><span class="p">]</span>     <span class="c1"># symmetrize</span>
        <span class="k">return</span> <span class="n">U</span></div>

<div class="viewcode-block" id="MLBWcrossSection.getCrossSection"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.MLBWcrossSection.getCrossSection">[docs]</a>    <span class="nd">@blockwise</span>
    <span class="k">def</span> <span class="nf">getCrossSection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span>
        <span class="n">captureSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">elasticSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">fissionSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="n">rhohat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">forceUseTabulated</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>    <span class="c1"># for phi</span>
        <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ls</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">]</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">rhohat</span><span class="p">)</span>
            <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span>
            <span class="n">S</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">shiftFactor</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">J</span> <span class="ow">in</span> <span class="n">L</span><span class="p">[</span><span class="s1">&#39;Js&#39;</span><span class="p">]:</span>
                <span class="n">gfactor</span> <span class="o">=</span> <span class="n">J</span><span class="p">[</span><span class="s1">&#39;gfact&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">spin</span> <span class="ow">in</span> <span class="n">J</span><span class="p">[</span><span class="s1">&#39;channelSpins&#39;</span><span class="p">]:</span>
                    <span class="k">try</span><span class="p">:</span>                    <span class="c1"># use C extension if available</span>
                        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">getBreitWignerSums</span>
                        <span class="n">capt</span><span class="p">,</span> <span class="n">elas</span><span class="p">,</span> <span class="n">fiss</span> <span class="o">=</span> <span class="n">getBreitWignerSums</span><span class="o">.</span><span class="n">getBreitWignerSums</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;energy&#39;</span><span class="p">],</span>
                                <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;captureWidth&#39;</span><span class="p">],</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">],</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;fissionWidth&#39;</span><span class="p">],</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;shiftFactor&#39;</span><span class="p">],</span>
                                <span class="n">P</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="s1">&#39;MultiLevel&#39;</span><span class="p">)</span>
                        <span class="n">captureSum</span> <span class="o">+=</span> <span class="n">gfactor</span> <span class="o">*</span> <span class="n">capt</span>
                        <span class="n">elasticSum</span> <span class="o">+=</span> <span class="n">gfactor</span> <span class="o">*</span> <span class="n">elas</span>
                        <span class="n">fissionSum</span> <span class="o">+=</span> <span class="n">gfactor</span> <span class="o">*</span> <span class="n">fiss</span>
                    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>     <span class="c1"># numpy version (memory-intensive)</span>
                        <span class="n">dE</span> <span class="o">=</span> <span class="p">(</span><span class="n">E</span><span class="o">-</span><span class="p">(</span><span class="n">spin</span><span class="p">[</span><span class="s1">&#39;energy&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">spin</span><span class="p">[</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">spin</span><span class="p">[</span><span class="s1">&#39;shiftFactor&#39;</span><span class="p">]</span><span class="o">-</span><span class="n">S</span><span class="p">)))</span>
                        <span class="n">totalWidth</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">spin</span><span class="p">[</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;captureWidth&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;fissionWidth&#39;</span><span class="p">]</span>
                        <span class="n">denominator</span> <span class="o">=</span> <span class="n">dE</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">totalWidth</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">4</span>
                        <span class="n">commonFactor</span> <span class="o">=</span> <span class="n">P</span> <span class="o">*</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;neutronWidth&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">denominator</span>
                        <span class="n">captureSum</span> <span class="o">+=</span> <span class="n">gfactor</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">commonFactor</span> <span class="o">*</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;captureWidth&#39;</span><span class="p">]</span> <span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">fissionSum</span> <span class="o">+=</span> <span class="n">gfactor</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">commonFactor</span> <span class="o">*</span> <span class="n">spin</span><span class="p">[</span><span class="s1">&#39;fissionWidth&#39;</span><span class="p">]</span> <span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                        <span class="c1"># simple elastic method, Eq D.19 - D.21 in ENDF 102. This has numerical issues, however:</span>
                        <span class="c1"># U_nn = numpy.exp(-2*1j*phi[:,0]) * (1 + numpy.sum( 1j*P*spin[&#39;neutronWidth&#39;] /</span>
                        <span class="c1">#     (spin[&#39;energy&#39;]-E-1j*totalWidth/2) , axis=1))</span>
                        <span class="c1"># elasticSum += gfactor * abs( (1-U_nn)**2 )</span>

                        <span class="c1"># Instead of the above, use the following from RECENT:</span>
                        <span class="n">elasticTerm1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">totalWidth</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">commonFactor</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span> <span class="p">)</span>
                        <span class="n">elasticTerm2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">dE</span> <span class="o">*</span> <span class="n">commonFactor</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span> <span class="p">)</span>
                        <span class="n">sin2ps</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">sinps2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
                        <span class="n">elasticSum</span> <span class="o">+=</span> <span class="n">gfactor</span> <span class="o">*</span> <span class="p">((</span><span class="n">sinps2</span><span class="o">-</span><span class="n">elasticTerm1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">sin2ps</span><span class="o">+</span><span class="n">elasticTerm2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="kc">True</span><span class="p">:</span> <span class="c1">#addMissingGfactor:</span>
                <span class="n">elasticSum</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">missingGfactor</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>

        <span class="c1"># get common factor &#39;beta&#39; as a row vector:</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">capture</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">captureSum</span>
        <span class="n">elastic</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">elasticSum</span>
        <span class="n">fission</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">fissionSum</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">removeNegatives</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">reaction</span> <span class="ow">in</span> <span class="p">(</span><span class="n">capture</span><span class="p">,</span><span class="n">elastic</span><span class="p">,</span><span class="n">fission</span><span class="p">):</span>
                <span class="n">reaction</span><span class="p">[</span> <span class="n">reaction</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">elastic</span> <span class="o">+</span> <span class="n">capture</span> <span class="o">+</span> <span class="n">fission</span>
        <span class="n">nonelastic</span> <span class="o">=</span> <span class="n">capture</span> <span class="o">+</span> <span class="n">fission</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;total&#39;</span><span class="p">:</span><span class="n">total</span><span class="p">,</span> <span class="s1">&#39;elastic&#39;</span><span class="p">:</span><span class="n">elastic</span><span class="p">,</span> <span class="s1">&#39;capture&#39;</span><span class="p">:</span><span class="n">capture</span><span class="p">,</span> <span class="s1">&#39;fission&#39;</span><span class="p">:</span><span class="n">fission</span><span class="p">,</span> <span class="s1">&#39;nonelastic&#39;</span><span class="p">:</span><span class="n">nonelastic</span><span class="p">}</span></div></div>


<span class="c1">###### Reich_Moore and R-Matrix Limited ######</span>

<span class="c1"># some helper functions:</span>

<div class="viewcode-block" id="getR_S"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.getR_S">[docs]</a><span class="k">def</span> <span class="nf">getR_S</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">Eres</span><span class="p">,</span> <span class="n">captureWidth</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="n">penetrabilities</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Both versions of Reich_Moore formalisms (LRF=3 and 7) rely on building the complex matrix &#39;R&#39;.</span>
<span class="sd">    Here we break it up into the real component R and the imaginary component S,</span>
<span class="sd">    which represent symmetric and anti-symmetric scattering respectively</span>

<span class="sd">    matrix elements R[i,j] and S[i,j] =</span>

<span class="sd">    (summed over resonances) partialWidth[i]*partialWidth[j] * coefficient/(dE**2+captureWidth**2),</span>

<span class="sd">    for the ith/jth open channel. For S, the coefficient is &#39;dE&#39;, for R &#39;captureWidth&#39;</span>
<span class="sd">    and partialWidth[i] = widths[i] * penetrabilities[i]</span>

<span class="sd">        ( widths[i] is a row vector of resonance widths, and penetrabilities[i] is a column vector</span>
<span class="sd">        of the penetrability for each incident energy )</span>

<span class="sd">    After computing R and S, invert using invertMatrices to find RI and SI such that (I+R+jS)*(I+RI+jSI) = I</span>
<span class="sd">    where I is the identity matrix, and j = sqrt(-1)</span>

<span class="sd">    Incident energy dependence appears in both in E and the penetrabilities</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">NE</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>         <span class="c1"># number of energies</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">)</span>   <span class="c1"># dimension of matrix at each energy</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># use wrapped c version if available:</span>
        <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">getScatteringMatrices</span>
        <span class="c1"># convert any constant width/penetrability data to array w/correct dimensions:</span>
        <span class="n">nRes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Eres</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">[</span><span class="n">i1</span><span class="p">])</span> <span class="o">!=</span> <span class="n">nRes</span><span class="p">:</span>
                <span class="n">widths</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">nRes</span><span class="p">))</span> <span class="o">*</span> <span class="n">widths</span><span class="p">[</span><span class="n">i1</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">penetrabilities</span><span class="p">[</span><span class="n">i1</span><span class="p">])</span> <span class="o">!=</span> <span class="n">NE</span><span class="p">:</span>
                <span class="n">penetrabilities</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">NE</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">penetrabilities</span><span class="p">[</span><span class="n">i1</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">R</span><span class="p">,</span> <span class="n">S</span> <span class="o">=</span> <span class="n">getScatteringMatrices</span><span class="o">.</span><span class="n">getScatteringMatrices</span><span class="p">(</span> <span class="n">E</span><span class="p">,</span> <span class="n">Eres</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">captureWidth</span><span class="p">,</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">widths</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">penetrabilities</span><span class="p">)</span> <span class="p">)</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="c1"># can&#39;t import c version, so use numpy (memory-intensive)</span>
        <span class="c1"># define some common factors.</span>
        <span class="c1"># These are all 2d arrays with len(E) rows, len(Eres) columns:</span>
        <span class="n">dE</span> <span class="o">=</span> <span class="n">Eres</span> <span class="o">-</span> <span class="n">E</span>
        <span class="n">DEN</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">dE</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">captureWidth</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">captOverDEN</span> <span class="o">=</span> <span class="n">captureWidth</span><span class="o">*</span><span class="n">DEN</span>
        <span class="n">dEoverDEN</span> <span class="o">=</span> <span class="n">dE</span><span class="o">*</span><span class="n">DEN</span>
        <span class="k">del</span> <span class="n">dE</span><span class="p">,</span> <span class="n">DEN</span>

        <span class="n">R</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NE</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">dim</span><span class="p">))</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NE</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">dim</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">dim</span><span class="p">):</span>
                <span class="n">width_ij</span> <span class="o">=</span> <span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">widths</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">p_ij</span> <span class="o">=</span> <span class="n">penetrabilities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">penetrabilities</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">R</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_ij</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">width_ij</span> <span class="o">*</span> <span class="n">captOverDEN</span> <span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">S</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_ij</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">width_ij</span> <span class="o">*</span> <span class="n">dEoverDEN</span> <span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1"># symmetrize:</span>
                <span class="n">R</span><span class="p">[:,</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
                <span class="n">S</span><span class="p">[:,</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">captOverDEN</span><span class="p">,</span> <span class="n">dEoverDEN</span>

    <span class="k">return</span> <span class="n">R</span><span class="p">,</span><span class="n">S</span></div>


<div class="viewcode-block" id="invertMatrices"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.invertMatrices">[docs]</a><span class="k">def</span> <span class="nf">invertMatrices</span><span class="p">(</span> <span class="n">R</span><span class="p">,</span> <span class="n">S</span> <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    find RI and SI such that (I+R+jS)*(I+RI+jSI) = I,</span>
<span class="sd">    where I is the identity matrix, and j = sqrt(-1)</span>

<span class="sd">    for more info, see comments for subroutine FROBNS3 in recent.f</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">R</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">NE</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">dim</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">if</span> <span class="n">dim</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="c1"># only have neutron width (and &#39;eliminated&#39; capture width).</span>
        <span class="c1"># Can obtain quicker solution by manually inverting:</span>
        <span class="n">DET</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">S</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">SI</span> <span class="o">=</span> <span class="o">-</span><span class="n">S</span><span class="o">/</span><span class="n">DET</span>
        <span class="n">RI</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">R</span><span class="o">*</span><span class="p">(</span><span class="n">R</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">DET</span>
        <span class="k">return</span> <span class="n">RI</span><span class="p">,</span><span class="n">SI</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># have competition and/or fission, must invert matrices:</span>
        <span class="k">def</span> <span class="nf">dotproduct</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="c1"># helper function: dotproduct(A,B,C) == numpy.dot(A, numpy.dot(B,C))</span>
            <span class="kn">import</span> <span class="nn">functools</span>
            <span class="k">def</span> <span class="nf">quickdot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
                <span class="c1"># take dot product of two Nx(MxM) arrays (containing MxM matrices):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="p">)</span>
                <span class="n">dim</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
                        <span class="n">result</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">a</span><span class="p">[:,</span><span class="n">i</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[:,:,</span><span class="n">j</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span> <span class="p">)</span>
                <span class="k">return</span> <span class="n">result</span>
            <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span> <span class="n">quickdot</span><span class="p">,</span> <span class="n">args</span> <span class="p">)</span>

        <span class="k">def</span> <span class="nf">vectorInv</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
            <span class="c1"># invert all MxM matrices in Nx(MxM) array</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dim</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">arrinv</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">det</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">det</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">det</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">det</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">det</span>
                <span class="k">return</span> <span class="n">arrinv</span>
            <span class="k">elif</span> <span class="n">dim</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                <span class="n">arrinv</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">det</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
                    <span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                    <span class="o">+</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="p">)</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>
                <span class="n">arrinv</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">det</span>
                <span class="k">return</span> <span class="n">arrinv</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span> <span class="p">)</span>
                <span class="n">NE</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NE</span><span class="p">):</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">return</span> <span class="n">result</span>

        <span class="n">identity</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="n">NE</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="n">identity</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">invRplusI</span> <span class="o">=</span> <span class="n">vectorInv</span><span class="p">(</span> <span class="n">R</span> <span class="o">+</span> <span class="n">identity</span> <span class="p">)</span>
        <span class="n">SRS</span> <span class="o">=</span> <span class="n">dotproduct</span><span class="p">(</span> <span class="n">S</span><span class="p">,</span> <span class="n">invRplusI</span><span class="p">,</span> <span class="n">S</span> <span class="p">)</span>
        <span class="n">RI</span> <span class="o">=</span> <span class="n">dotproduct</span><span class="p">(</span> <span class="o">-</span><span class="n">vectorInv</span><span class="p">(</span> <span class="n">R</span><span class="o">+</span><span class="n">identity</span> <span class="o">+</span> <span class="n">SRS</span> <span class="p">),</span> <span class="n">R</span><span class="o">+</span><span class="n">SRS</span> <span class="p">)</span>
        <span class="n">SI</span> <span class="o">=</span> <span class="n">dotproduct</span><span class="p">(</span> <span class="o">-</span><span class="n">invRplusI</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">RI</span><span class="o">+</span><span class="n">identity</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">RI</span><span class="p">,</span> <span class="n">SI</span></div>


<span class="c1">#### R-Matrix Limited ####</span>
<div class="viewcode-block" id="RMatrixLimitedcrossSection"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection">[docs]</a><span class="k">class</span> <span class="nc">RMatrixLimitedcrossSection</span><span class="p">(</span><span class="n">RRBaseClass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    extended Reich_Moore (LRF=7 in ENDF)</span>
<span class="sd">    Here, resonances are sorted primarily by J: within each &#39;spin group&#39;, total J is conserved</span>
<span class="sd">    One or more competitive channels may be used in this case.</span>
<span class="sd">    Also, each resonance may have contributions from multiple l-waves</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">RMatrixForm</span><span class="p">,</span> <span class="n">enableAngDists</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="n">RMatrixForm</span><span class="o">.</span><span class="n">ancestor</span>
        <span class="n">RRBaseClass</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">RMatrixForm</span><span class="p">,</span> <span class="n">parent</span><span class="o">.</span><span class="n">domainMin</span><span class="p">,</span> <span class="n">parent</span><span class="o">.</span><span class="n">domainMax</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;From </span><span class="si">%f</span><span class="s2"> to </span><span class="si">%f</span><span class="s2"> </span><span class="si">%s</span><span class="s2">, reconstructing using RMatrix (approximation </span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">approximation</span><span class="p">))</span>

        <span class="c1"># for RML, need to know what residual nuclei are produced by each channel:</span>
        <span class="n">thresholds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">rreac</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceReactions</span><span class="p">:</span>
            <span class="n">reaction</span> <span class="o">=</span> <span class="n">rreac</span><span class="o">.</span><span class="n">link</span><span class="o">.</span><span class="n">link</span>
            <span class="c1"># elastic, capture or competitive?</span>
            <span class="k">if</span> <span class="n">reaction</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">reactionSuite</span><span class="o">.</span><span class="n">getReaction</span><span class="p">(</span><span class="s1">&#39;capture&#39;</span><span class="p">):</span> <span class="n">rreac</span><span class="o">.</span><span class="n">tag</span> <span class="o">=</span> <span class="s1">&#39;capture&#39;</span>
            <span class="k">elif</span> <span class="n">reaction</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">reactionSuite</span><span class="o">.</span><span class="n">getReaction</span><span class="p">(</span><span class="s1">&#39;elastic&#39;</span><span class="p">):</span> <span class="n">rreac</span><span class="o">.</span><span class="n">tag</span> <span class="o">=</span> <span class="s1">&#39;elastic&#39;</span>
            <span class="k">elif</span> <span class="s1">&#39;fission&#39;</span> <span class="ow">in</span> <span class="n">rreac</span><span class="o">.</span><span class="n">label</span><span class="p">:</span> <span class="n">rreac</span><span class="o">.</span><span class="n">tag</span> <span class="o">=</span> <span class="n">rreac</span><span class="o">.</span><span class="n">label</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">rreac</span><span class="o">.</span><span class="n">tag</span> <span class="o">=</span> <span class="s1">&#39;competitive&#39;</span>

            <span class="k">if</span> <span class="n">rreac</span><span class="o">.</span><span class="n">Q</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">Q</span> <span class="o">=</span> <span class="n">rreac</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">getConstantAs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">Q</span> <span class="o">=</span> <span class="n">reaction</span><span class="o">.</span><span class="n">getQ</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">,</span> <span class="n">final</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s1">&#39;fission&#39;</span> <span class="ow">in</span> <span class="n">rreac</span><span class="o">.</span><span class="n">label</span><span class="p">:</span>
                        <span class="c1"># fission may have energy-dependent Q-value. Use minimum Q to compute Xi</span>
                        <span class="n">Qform</span> <span class="o">=</span> <span class="n">reaction</span><span class="o">.</span><span class="n">outputChannel</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">evaluated</span>
                        <span class="n">Q</span> <span class="o">=</span> <span class="n">PQUModule</span><span class="o">.</span><span class="n">PQU</span><span class="p">(</span><span class="n">Qform</span><span class="o">.</span><span class="n">rangeMin</span><span class="p">,</span> <span class="n">Qform</span><span class="o">.</span><span class="n">rangeUnit</span><span class="p">)</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">ex</span>
            <span class="c1"># adjust Q value for residual in excited state:</span>
            <span class="k">for</span> <span class="n">particle</span> <span class="ow">in</span> <span class="n">reaction</span><span class="o">.</span><span class="n">outputChannel</span><span class="o">.</span><span class="n">products</span><span class="p">:</span>
                <span class="k">if</span><span class="p">(</span> <span class="nb">hasattr</span><span class="p">(</span> <span class="n">particle</span><span class="p">,</span> <span class="s1">&#39;getLevelAsFloat&#39;</span> <span class="p">)</span> <span class="p">)</span> <span class="p">:</span> <span class="n">Q</span> <span class="o">-=</span> <span class="n">particle</span><span class="o">.</span><span class="n">getLevelAsFloat</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span> <span class="p">)</span>
            <span class="c1"># Xi = reaction threshold in the lab frame.</span>
            <span class="n">targetToProjectileMassRatio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetMass_amu</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">projectileMass_amu</span>
            <span class="n">Xi</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span> <span class="p">(</span><span class="n">targetToProjectileMassRatio</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">targetToProjectileMassRatio</span> <span class="p">)</span> <span class="o">*</span> <span class="n">Q</span>
            <span class="n">particles</span> <span class="o">=</span> <span class="n">reaction</span><span class="o">.</span><span class="n">outputChannel</span><span class="o">.</span><span class="n">products</span>
            <span class="n">rreac</span><span class="o">.</span><span class="n">reactionInfo</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;Xi&#39;</span><span class="p">:</span><span class="n">Xi</span><span class="p">,</span> <span class="s1">&#39;particles&#39;</span><span class="p">:</span> <span class="n">particles</span> <span class="p">}</span>
            <span class="k">if</span> <span class="n">Xi</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">thresholds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Xi</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">rreac</span><span class="o">.</span><span class="n">boundaryConditionValue</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Reconstruction with numeric boundary condition&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">sg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">spinGroups</span><span class="p">:</span>
            <span class="n">sg</span><span class="o">.</span><span class="n">energy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">sg</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">)</span> <span class="p">)</span>

            <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">sg</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
                <span class="n">resonanceReaction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceReactions</span><span class="p">[</span> <span class="n">channel</span><span class="o">.</span><span class="n">resonanceReaction</span> <span class="p">]</span>
                <span class="n">column</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span> <span class="n">channel</span><span class="o">.</span><span class="n">columnIndex</span> <span class="p">]</span>
                <span class="n">column</span><span class="o">.</span><span class="n">tag</span> <span class="o">=</span> <span class="n">resonanceReaction</span><span class="o">.</span><span class="n">tag</span>
                <span class="k">if</span> <span class="n">channel</span><span class="o">.</span><span class="n">externalRMatrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Reconstruction with external R-Matrix still TBD&quot;</span><span class="p">)</span>

        <span class="c1"># for energy grid generation:</span>
        <span class="n">energies</span><span class="p">,</span> <span class="n">totalWidths</span> <span class="o">=</span> <span class="p">[],[]</span>
        <span class="k">for</span> <span class="n">sg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">spinGroups</span><span class="p">:</span>
            <span class="n">energies</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="n">sg</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">)</span> <span class="p">)</span>
            <span class="n">widths</span> <span class="o">=</span> <span class="p">[</span><span class="n">sg</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span> <span class="n">col</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span> <span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span>
                    <span class="n">sg</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;energy&#39;</span><span class="p">]</span>
            <span class="n">totalWidths</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">widths</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">zipped</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">energies</span><span class="p">,</span><span class="n">totalWidths</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_energies</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_widths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">zipped</span><span class="p">)</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_thresholds</span> <span class="o">=</span> <span class="n">thresholds</span>

        <span class="k">if</span> <span class="n">enableAngDists</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setResonanceParametersByChannel</span><span class="p">()</span>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.penetrationFactorByChannel"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.penetrationFactorByChannel">[docs]</a>    <span class="k">def</span> <span class="nf">penetrationFactorByChannel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">Ein</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">channelClass</span> <span class="ow">in</span> <span class="p">[</span><span class="n">FISSIONCHANNEL</span><span class="p">,</span> <span class="n">GAMMACHANNEL</span><span class="p">]:</span> <span class="k">return</span> <span class="mf">1.0</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">channelClass</span> <span class="o">==</span> <span class="n">CPCHANNEL</span><span class="p">:</span>
            <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">particlePairs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">reactionInfo</span><span class="p">[</span><span class="s1">&#39;particles&#39;</span><span class="p">]</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">(</span><span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">getCoulombWavefunctions</span><span class="o">.</span><span class="n">coulombPenetrationFactor</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span><span class="n">rho</span><span class="p">,</span><span class="n">eta</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">rho</span><span class="p">)</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.phiByChannel"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.phiByChannel">[docs]</a>    <span class="k">def</span> <span class="nf">phiByChannel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">Ein</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">channelClass</span> <span class="ow">in</span> <span class="p">[</span><span class="n">FISSIONCHANNEL</span><span class="p">,</span> <span class="n">GAMMACHANNEL</span><span class="p">]:</span> <span class="k">return</span> <span class="mf">0.0</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rhohat</span><span class="p">(</span><span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">channelClass</span> <span class="o">==</span> <span class="n">CPCHANNEL</span><span class="p">:</span>
            <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">particlePairs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">reactionInfo</span><span class="p">[</span><span class="s1">&#39;particles&#39;</span><span class="p">]</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">(</span><span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">getCoulombWavefunctions</span><span class="o">.</span><span class="n">coulombPhi</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span><span class="n">rho</span><span class="p">,</span><span class="n">eta</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">Ein</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="p">)</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.shiftFactorByChannel"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.shiftFactorByChannel">[docs]</a>    <span class="k">def</span> <span class="nf">shiftFactorByChannel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">Ein</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">channelClass</span> <span class="ow">in</span> <span class="p">[</span><span class="n">FISSIONCHANNEL</span><span class="p">,</span> <span class="n">GAMMACHANNEL</span><span class="p">]:</span> <span class="k">return</span> <span class="mf">0.0</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">channelClass</span> <span class="o">==</span> <span class="n">CPCHANNEL</span><span class="p">:</span>
            <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">particlePairs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">reactionInfo</span><span class="p">[</span><span class="s1">&#39;particles&#39;</span><span class="p">]</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">(</span><span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">getCoulombWavefunctions</span><span class="o">.</span><span class="n">coulombShiftFactor</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span><span class="n">rho</span><span class="p">,</span><span class="n">eta</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shiftFactor</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">rho</span><span class="p">)</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.isElastic"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.isElastic">[docs]</a>    <span class="k">def</span> <span class="nf">isElastic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reactionDesignator</span><span class="p">):</span>
        <span class="n">rs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">rootAncestor</span>
        <span class="k">return</span> <span class="n">rs</span><span class="o">.</span><span class="n">getReaction</span><span class="p">(</span><span class="n">reactionDesignator</span><span class="p">)</span> <span class="o">==</span> <span class="n">rs</span><span class="o">.</span><span class="n">getReaction</span><span class="p">(</span><span class="s1">&#39;elastic&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.getLMax"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.getLMax">[docs]</a>    <span class="k">def</span> <span class="nf">getLMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxLmax</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        LMax is determined by the behavior of the Blatt-Biedenharn Zbar coefficients.  Inside each one, there is</span>
<span class="sd">        a Racah coefficient and a Clebsh-Gordon coefficient.  The CG coefficient looks like this::</span>

<span class="sd">                ( l1 l2  L )</span>
<span class="sd">                (  0  0  0 )</span>

<span class="sd">        So, this means two things.  First, the CG coeff (and hence Zbar) will be zero if l1+l2+L=odd.</span>
<span class="sd">        Second, the maximum value of L will be l1max+l2max.  Hence, Lmax=2*lmax.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span> <span class="nb">max</span><span class="p">(</span> <span class="p">[</span> <span class="mi">2</span><span class="o">*</span><span class="n">c</span><span class="o">.</span><span class="n">l</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="p">]</span> <span class="p">),</span> <span class="n">maxLmax</span> <span class="p">)</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.setResonanceParametersByChannel"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.setResonanceParametersByChannel">[docs]</a>    <span class="k">def</span> <span class="nf">setResonanceParametersByChannel</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">multipleSScheme</span><span class="o">=</span><span class="s1">&#39;ENDF&#39;</span><span class="p">,</span> <span class="n">useReichMooreApproximation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">Ein</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">warnOnly</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reorganize member data into channels</span>
<span class="sd">        :param multipleSScheme:  ignored, kept so has same signature as overridden function</span>
<span class="sd">        :param useReichMooreApproximation:  ignored, kept so has same signature as overridden function</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nResonances</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span> <span class="p">[</span> <span class="nb">len</span><span class="p">(</span> <span class="n">sg</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span> <span class="p">)</span> <span class="k">for</span> <span class="n">sg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">spinGroups</span> <span class="p">]</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">JMax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="p">[</span><span class="n">sg</span><span class="o">.</span><span class="n">spin</span> <span class="k">for</span> <span class="n">sg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">spinGroups</span><span class="p">]</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channelConstantsBc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">particlePairs</span><span class="o">=</span><span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scatteringRadiiTrue</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scatteringRadiiEffective</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># FIXME: overrides should not be necessary anymore, ResonanceReaction / Channel classes now have logic</span>
        <span class="c1"># for looking up scatteringRadius / hardSphereRadius using ancestry</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overrides</span><span class="o">=</span><span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">allowedSs</span> <span class="o">=</span> <span class="n">getAllowedTotalSpins</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">projectileSpin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetSpin</span><span class="p">,</span> <span class="n">useFactor2Trick</span><span class="o">=</span><span class="kc">False</span> <span class="p">)</span>
        <span class="n">warnings</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># The unified table of resonance parameter data</span>
        <span class="n">channelDict</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">addOrUpdateDict</span><span class="p">(</span><span class="n">theDict</span><span class="p">,</span> <span class="n">theKey</span><span class="p">,</span> <span class="n">theValue</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">theKey</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">theDict</span><span class="p">:</span>
                <span class="n">theDict</span><span class="p">[</span><span class="n">theKey</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="n">theValue</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">theDict</span><span class="p">[</span><span class="n">theKey</span><span class="p">][</span><span class="n">theValue</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">theValue</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Pack the channels</span>
        <span class="n">channelIndex</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">sg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">spinGroups</span><span class="p">:</span>
            <span class="n">ERs</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span> <span class="n">sg</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span> <span class="p">)</span>
            <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">sg</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
                <span class="n">pp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceReactions</span><span class="p">[</span> <span class="n">channel</span><span class="o">.</span><span class="n">resonanceReaction</span> <span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">eliminated</span> <span class="ow">or</span> <span class="n">pp</span><span class="o">.</span><span class="n">isFission</span><span class="p">()):</span>

                    <span class="n">Ia</span><span class="p">,</span> <span class="n">Ib</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getParticleSpins</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
                    <span class="n">Pia</span><span class="p">,</span> <span class="n">Pib</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getParticleParities</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>

                    <span class="c1"># Check validity of channel spin</span>
                    <span class="k">if</span> <span class="n">channel</span><span class="o">.</span><span class="n">channelSpin</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">getAllowedTotalSpins</span><span class="p">(</span> <span class="n">Ia</span><span class="p">,</span> <span class="n">Ib</span><span class="p">,</span> <span class="n">useFactor2Trick</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
                        <span class="k">if</span> <span class="n">warnOnly</span><span class="p">:</span>
                            <span class="kn">from</span> <span class="nn">fudge</span> <span class="kn">import</span> <span class="n">warning</span>
                            <span class="n">warnings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">warning</span><span class="o">.</span><span class="n">InvalidSpinCombination</span><span class="p">(</span> <span class="n">Ia</span><span class="p">,</span> <span class="n">Ib</span><span class="p">,</span> <span class="n">channel</span><span class="o">.</span><span class="n">channelSpin</span><span class="p">,</span> <span class="n">channel</span><span class="o">.</span><span class="n">label</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s1">&#39;Invalid spin combination: cannot couple Ia = </span><span class="si">%s</span><span class="s1"> and Ib = </span><span class="si">%s</span><span class="s1"> up to S = </span><span class="si">%s</span><span class="s1"> for channel &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span>
                                    <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">Ia</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">Ib</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">channelSpin</span><span class="p">),</span> <span class="n">channel</span><span class="o">.</span><span class="n">label</span><span class="p">))</span>
                    <span class="c1"># Check the validity of total angular momenta</span>
                    <span class="k">if</span> <span class="n">sg</span><span class="o">.</span><span class="n">spin</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">getAllowedTotalSpins</span><span class="p">(</span> <span class="n">channel</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="n">channel</span><span class="o">.</span><span class="n">channelSpin</span><span class="p">,</span> <span class="n">useFactor2Trick</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
                        <span class="k">if</span> <span class="n">warnOnly</span><span class="p">:</span>
                            <span class="kn">from</span> <span class="nn">fudge</span> <span class="kn">import</span> <span class="n">warning</span>
                            <span class="n">warnings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">warning</span><span class="o">.</span><span class="n">InvalidAngularMomentaCombination</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="n">channel</span><span class="o">.</span><span class="n">channelSpin</span><span class="p">,</span> <span class="n">sg</span><span class="o">.</span><span class="n">spin</span><span class="p">,</span> <span class="n">channel</span><span class="o">.</span><span class="n">label</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s1">&#39;Invalid spin combination: cannot couple L = </span><span class="si">%s</span><span class="s1"> and S = </span><span class="si">%s</span><span class="s1"> up to J = </span><span class="si">%s</span><span class="s1"> for channel &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span>
                                    <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">L</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">channelSpin</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">spin</span><span class="p">),</span> <span class="n">channel</span><span class="o">.</span><span class="n">label</span> <span class="p">)</span> <span class="p">)</span>
                    <span class="c1"># Check the validity of the channel parity</span>
                    <span class="k">if</span> <span class="n">Pia</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Pib</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="c1">#print(Pia,Pib)</span>
                        <span class="n">expectedPi</span><span class="o">=</span><span class="n">Pia</span><span class="o">*</span><span class="n">Pib</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">channel</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">expectedPi</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">parity</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">warnOnly</span><span class="p">:</span>
                                <span class="kn">from</span> <span class="nn">fudge</span> <span class="kn">import</span> <span class="n">warning</span>
                                <span class="n">warnings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="n">warning</span><span class="o">.</span><span class="n">InvalidParity</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="n">channel</span><span class="o">.</span><span class="n">channelSpin</span><span class="p">,</span> <span class="n">sg</span><span class="o">.</span><span class="n">spin</span><span class="p">,</span> <span class="n">sg</span><span class="o">.</span><span class="n">parity</span><span class="p">,</span> <span class="n">channel</span><span class="o">.</span><span class="n">label</span><span class="p">))</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                    <span class="s1">&#39;Invalid parity: cannot couple L = </span><span class="si">%s</span><span class="s1"> and S = </span><span class="si">%s</span><span class="s1"> up to J = </span><span class="si">%s</span><span class="s1"> for channel &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span>
                                    <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">L</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">channelSpin</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">spin</span><span class="p">),</span> <span class="n">channel</span><span class="o">.</span><span class="n">label</span><span class="p">))</span>
                    <span class="n">gfact</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">spin</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">Ia</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">Ib</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">gfact</span> <span class="o">=</span> <span class="mf">1.0</span>

                <span class="c1"># Construct the channel designator</span>
                <span class="n">particles</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">reactionInfo</span><span class="p">[</span><span class="s1">&#39;particles&#39;</span><span class="p">]))</span>
                <span class="n">ps0</span> <span class="o">=</span> <span class="n">particles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ps1</span> <span class="o">=</span> <span class="n">particles</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">particles</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="s1">&#39;photon&#39;</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ps0</span><span class="p">,</span><span class="n">ps1</span><span class="p">]:</span>  <span class="n">channelClass</span> <span class="o">=</span> <span class="n">GAMMACHANNEL</span>
                <span class="k">elif</span> <span class="s1">&#39;gamma&#39;</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ps0</span><span class="p">,</span><span class="n">ps1</span><span class="p">]:</span> <span class="n">channelClass</span> <span class="o">=</span> <span class="n">GAMMACHANNEL</span>
                <span class="k">elif</span> <span class="s1">&#39;n&#39;</span>  <span class="ow">in</span> <span class="p">[</span><span class="n">ps0</span><span class="p">,</span><span class="n">ps1</span><span class="p">]:</span>    <span class="n">channelClass</span> <span class="o">=</span> <span class="n">NEUTRONCHANNEL</span>
                <span class="k">elif</span> <span class="n">pp</span><span class="o">.</span><span class="n">isFission</span><span class="p">():</span>       <span class="n">channelClass</span> <span class="o">=</span> <span class="n">FISSIONCHANNEL</span>
                <span class="k">else</span><span class="p">:</span>                      <span class="n">channelClass</span> <span class="o">=</span> <span class="n">CPCHANNEL</span>
                <span class="k">if</span> <span class="n">ps1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">channelClass</span> <span class="o">==</span> <span class="n">FISSIONCHANNEL</span>
                <span class="n">c</span><span class="o">=</span><span class="n">ChannelDesignator</span><span class="p">(</span>
                    <span class="n">index</span><span class="o">=</span><span class="n">channelIndex</span><span class="p">,</span>
                    <span class="n">reaction</span><span class="o">=</span><span class="n">pp</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
                    <span class="n">l</span><span class="o">=</span><span class="n">channel</span><span class="o">.</span><span class="n">L</span><span class="p">,</span>
                    <span class="n">s</span><span class="o">=</span><span class="n">channel</span><span class="o">.</span><span class="n">channelSpin</span><span class="p">,</span>
                    <span class="n">J</span><span class="o">=</span><span class="n">sg</span><span class="o">.</span><span class="n">spin</span><span class="p">,</span>
                    <span class="n">gfact</span><span class="o">=</span><span class="n">gfact</span><span class="p">,</span>
                    <span class="n">particleA</span><span class="o">=</span><span class="n">ps0</span><span class="p">,</span>
                    <span class="n">particleB</span><span class="o">=</span><span class="n">ps1</span><span class="p">,</span>
                    <span class="n">Xi</span><span class="o">=</span><span class="n">pp</span><span class="o">.</span><span class="n">reactionInfo</span><span class="p">[</span><span class="s1">&#39;Xi&#39;</span><span class="p">],</span>
                    <span class="n">isElastic</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">isElastic</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">label</span><span class="p">),</span>
                    <span class="n">channelClass</span><span class="o">=</span><span class="n">channelClass</span><span class="p">,</span>
                    <span class="n">useRelativistic</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">relativisticKinematics</span><span class="p">,</span>
                    <span class="n">eliminated</span><span class="o">=</span><span class="n">pp</span><span class="o">.</span><span class="n">eliminated</span> <span class="p">)</span>
                <span class="n">channelIndex</span><span class="o">+=</span><span class="mi">1</span>

                <span class="c1"># Don&#39;t put closed channels onto lists</span>
                <span class="k">if</span> <span class="n">Ein</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">is_open</span><span class="p">(</span><span class="n">Ein</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">is_open</span><span class="p">(</span><span class="n">Ein</span><span class="p">)):</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;WARNING: Rethink your grid!  Your grid straddles a threshold at </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> for channel </span><span class="si">%s</span><span class="s2">, l=</span><span class="si">%i</span><span class="s2">, s=</span><span class="si">%i</span><span class="s2">, J=</span><span class="si">%i</span><span class="s2">.&quot;</span>
                                <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">reaction</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">J</span><span class="p">))</span>
                    <span class="k">continue</span>

                <span class="c1"># Save the particle pair, helps finding them later</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">particlePairs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="n">pp</span>

                <span class="c1"># Log the channels</span>
                <span class="n">addOrUpdateDict</span><span class="p">(</span><span class="n">channelDict</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># This catches potential scattering only channels</span>
                <span class="k">if</span> <span class="n">channel</span><span class="o">.</span><span class="n">scatteringRadius</span> <span class="ow">or</span> <span class="n">channel</span><span class="o">.</span><span class="n">hardSphereRadius</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">overrides</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">overrides</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="c1"># Now do the actual resonance packing</span>
                <span class="k">for</span> <span class="n">iR</span><span class="p">,</span> <span class="n">width</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="p">[:,</span><span class="n">channel</span><span class="o">.</span><span class="n">columnIndex</span><span class="p">]):</span>
                    <span class="n">addOrUpdateDict</span><span class="p">(</span><span class="n">channelDict</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_energies</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ERs</span><span class="p">[</span><span class="n">iR</span><span class="p">]),</span> <span class="n">width</span><span class="p">))</span>

        <span class="c1"># Set up the channel-&gt;resonance mappings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span> <span class="o">=</span> <span class="n">channelDict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>  <span class="c1"># just the kept ones</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eliminatedChannels</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">eliminated</span><span class="p">:</span>    <span class="bp">self</span><span class="o">.</span><span class="n">eliminatedChannels</span><span class="p">[</span> <span class="n">c</span> <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span><span class="p">[</span> <span class="n">c</span> <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>               <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span> <span class="n">c</span> <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allChannels</span><span class="p">[</span> <span class="n">c</span> <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">identityMatrix</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span> <span class="p">)</span>

        <span class="k">if</span> <span class="n">warnOnly</span><span class="p">:</span> <span class="k">return</span> <span class="n">warnings</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.resetResonanceParametersByChannel"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.resetResonanceParametersByChannel">[docs]</a>    <span class="k">def</span> <span class="nf">resetResonanceParametersByChannel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multipleSScheme</span><span class="o">=</span><span class="s1">&#39;ENDF&#39;</span><span class="p">,</span> <span class="n">useReichMooreApproximation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">Ein</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">setResonanceParametersByChannel</span><span class="p">(</span> <span class="n">multipleSScheme</span><span class="o">=</span><span class="n">multipleSScheme</span><span class="p">,</span> <span class="n">useReichMooreApproximation</span><span class="o">=</span><span class="n">useReichMooreApproximation</span><span class="p">,</span> <span class="n">Ein</span><span class="o">=</span><span class="n">Ein</span> <span class="p">)</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.getChannelConstantsBc"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.getChannelConstantsBc">[docs]</a>    <span class="k">def</span> <span class="nf">getChannelConstantsBc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For ENDF&#39;s Reich-Moore, should be :math:`B_c = -\\ell`</span>
<span class="sd">        where :math:`\\ell` is the channel angular momentum, but the ENDF manual says nothing about it.</span>

<span class="sd">        There is a per-channel parameter BCH that we will interpret as :math:`B_c`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Bc</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="n">pp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">particlePairs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span><span class="s1">&#39;boundaryCondition&#39;</span><span class="p">):</span>  <span class="c1">#FIXME: this variable disappeared!</span>
                <span class="n">Bc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">boundaryCondition</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Bc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Bc</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.getAPByChannel"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.getAPByChannel">[docs]</a>    <span class="k">def</span> <span class="nf">getAPByChannel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">trueOrEffective</span><span class="o">=</span><span class="s1">&#39;true&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">trueOrEffective</span><span class="o">==</span><span class="s1">&#39;true&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChannelScatteringRadiiTrue</span><span class="p">()[</span><span class="n">c</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">trueOrEffective</span><span class="o">==</span><span class="s1">&#39;effective&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChannelScatteringRadiiEffective</span><span class="p">()[</span><span class="n">c</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s2">&quot;trueOrEffective must be &#39;true&#39; or &#39;effective&#39;&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.getChannelScatteringRadiiTrue"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.getChannelScatteringRadiiTrue">[docs]</a>    <span class="k">def</span> <span class="nf">getChannelScatteringRadiiTrue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">APT</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">calculateChannelRadius</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="mf">0.123</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetMass_amu</span><span class="o">**</span><span class="p">(</span> <span class="mf">1.</span> <span class="o">/</span> <span class="mf">3.</span> <span class="p">)</span> <span class="o">+</span> <span class="mf">0.08</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">overrides</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">overrides</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">scatteringRadius</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">overrides</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">scatteringRadius</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;10*fm&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">particlePairs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">getScatteringRadius</span><span class="p">()</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;10*fm&#39;</span><span class="p">)</span>
            <span class="n">APT</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
        <span class="k">return</span> <span class="n">APT</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.getChannelScatteringRadiiEffective"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.getChannelScatteringRadiiEffective">[docs]</a>    <span class="k">def</span> <span class="nf">getChannelScatteringRadiiEffective</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">APE</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">overrides</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">overrides</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">hardSphereRadius</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">overrides</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">hardSphereRadius</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;10*fm&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">particlePairs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">getHardSphereRadius</span><span class="p">()</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;10*fm&#39;</span><span class="p">)</span>
            <span class="n">APE</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
        <span class="k">return</span> <span class="n">APE</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.rho"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.rho">[docs]</a>    <span class="k">def</span> <span class="nf">rho</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute :math:`\\rho_c(E) = a_c * k_c(E)`, using the true scattering radius.</span>
<span class="sd">        ENDF uses it for calculating shift and penetrabilities.</span>

<span class="sd">        :param Ein: incident energy in the lab frame (shifted by a threshold, if appropriate)</span>
<span class="sd">        :param c: the channel designator</span>
<span class="sd">        :return: the value of rho (dimensionless)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scatteringRadiiTrue</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">scatteringRadiiTrue</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChannelScatteringRadiiTrue</span><span class="p">()</span>
        <span class="n">pA</span><span class="p">,</span><span class="n">pB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">particlePairs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">reactionInfo</span><span class="p">[</span><span class="s1">&#39;particles&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_competitive</span><span class="p">(</span><span class="n">Ein</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scatteringRadiiTrue</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="c1"># dimensionless</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.rhohat"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.rhohat">[docs]</a>    <span class="k">def</span> <span class="nf">rhohat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute :math:`\\hat{\\rho}_c(E) = a_c * k_c(E)`, using the effective scattering radius</span>
<span class="sd">        ENDF uses it for calculating the phase (but in truth, there should be no effective scattering radius).</span>
<span class="sd">        (Caleb uses self.k below, but I think it should be self.k_competitive for the sake of consistency)</span>

<span class="sd">        :param Ein: incident energy in the lab frame (shifted by a threshold, if appropriate)</span>
<span class="sd">        :param c: the channel designator</span>
<span class="sd">        :return: the value of rho (dimensionless)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scatteringRadiiEffective</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">scatteringRadiiEffective</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChannelScatteringRadiiEffective</span><span class="p">()</span>
        <span class="n">pA</span><span class="p">,</span><span class="n">pB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">particlePairs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">reactionInfo</span><span class="p">[</span><span class="s1">&#39;particles&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_competitive</span><span class="p">(</span><span class="n">Ein</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scatteringRadiiEffective</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="c1"># dimensionless</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.omega"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.omega">[docs]</a>    <span class="k">def</span> <span class="nf">omega</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">L</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">L</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">eta</span><span class="p">)</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.getL0Matrix"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.getL0Matrix">[docs]</a>    <span class="k">def</span> <span class="nf">getL0Matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the :math:`L^0` matrix of Froehner, :math:`{\\bf L^0}_{cc&#39;} = \\delta_{cc&#39;} (L_c-B_c)`</span>
<span class="sd">        where :math:`L_c = S_c + i P_c`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s1">&#39;channelConstantsBc&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">channelConstantsBc</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channelConstantsBc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChannelConstantsBc</span><span class="p">()</span>
        <span class="n">L0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Ein</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span> <span class="p">)</span>

        <span class="k">for</span> <span class="n">ic</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">channelClass</span> <span class="ow">in</span> <span class="p">[</span><span class="n">FISSIONCHANNEL</span><span class="p">,</span> <span class="n">GAMMACHANNEL</span><span class="p">]:</span>
                <span class="n">shift</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">penet</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="k">elif</span> <span class="n">c</span><span class="o">.</span><span class="n">channelClass</span> <span class="o">==</span> <span class="n">CPCHANNEL</span><span class="p">:</span>
                <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">particlePairs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">reactionInfo</span><span class="p">[</span><span class="s1">&#39;particles&#39;</span><span class="p">]</span>
                <span class="n">eta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">(</span><span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">)</span>
                <span class="n">shift</span> <span class="o">=</span> <span class="n">getCoulombWavefunctions</span><span class="o">.</span><span class="n">coulombShiftFactor</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span><span class="n">rho</span><span class="p">,</span><span class="n">eta</span><span class="p">)</span>
                <span class="n">penet</span> <span class="o">=</span> <span class="n">getCoulombWavefunctions</span><span class="o">.</span><span class="n">coulombPenetrationFactor</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span><span class="n">rho</span><span class="p">,</span><span class="n">eta</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                <span class="n">penet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">rho</span><span class="p">)</span>
                <span class="n">shift</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shiftFactor</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">rho</span><span class="p">)</span>

            <span class="c1"># ENDF appears to set Bc = Sc most of the time.  When that&#39;s not the case,</span>
            <span class="c1"># Bc is set to something non zero, so in that case, compute L0 correctly</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channelConstantsBc</span><span class="p">[</span> <span class="n">ic</span> <span class="p">]</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">L0</span><span class="p">[:,</span><span class="n">ic</span><span class="p">,</span><span class="n">ic</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">shift</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">penet</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">channelConstantsBc</span><span class="p">[</span> <span class="n">ic</span> <span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">L0</span><span class="p">[:,</span><span class="n">ic</span><span class="p">,</span><span class="n">ic</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">penet</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">L0</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.getRMatrix"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.getRMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">getRMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The R matrix in the Reich-Moore approximation is</span>
<span class="sd">        :math:`R_{cc&#39;}=\\sum_\\lambda{\\frac{\\gamma_{\\lambda c}\\gamma_{\\lambda c&#39;}}{E_\\lambda - E - i\\Gamma_{\\lambda\\gamma}/2}}`</span>

<span class="sd">        :param Ein:</span>
<span class="sd">        :type Ein: numpy.array(type=float)</span>
<span class="sd">        :return:</span>
<span class="sd">        :rtype:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Ein</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span> <span class="p">)</span>

        <span class="c1"># Loop through all resonances</span>
        <span class="k">for</span> <span class="n">iR</span><span class="p">,</span> <span class="n">ER</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_energies</span> <span class="p">):</span>

            <span class="c1"># Extract the gamma width for the first gamma channel that has this resonance</span>
            <span class="n">gamWidth</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">cg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">eliminatedChannels</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">iR</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">eliminatedChannels</span><span class="p">[</span> <span class="n">cg</span> <span class="p">]:</span>
                    <span class="n">gamWidth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eliminatedChannels</span><span class="p">[</span> <span class="n">cg</span> <span class="p">][</span> <span class="n">iR</span> <span class="p">]</span>
                    <span class="k">if</span> <span class="n">gamWidth</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="k">break</span>

            <span class="c1"># Precompute the reduced widths</span>
            <span class="n">redWidth</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ic</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">iR</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">iR</span><span class="p">]</span>
                    <span class="n">shiftedER</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">abs</span><span class="p">(</span><span class="n">ER</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">)])</span>
                    <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">shiftedER</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">channelClass</span> <span class="o">==</span> <span class="n">NEUTRONCHANNEL</span><span class="p">:</span>
                        <span class="n">pen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">rho</span> <span class="p">)</span>
                    <span class="k">elif</span> <span class="n">c</span><span class="o">.</span><span class="n">channelClass</span> <span class="o">==</span> <span class="n">CPCHANNEL</span><span class="p">:</span>
                        <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">particlePairs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">reactionInfo</span><span class="p">[</span><span class="s1">&#39;particles&#39;</span><span class="p">]</span>
                        <span class="n">eta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">(</span><span class="n">shiftedER</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">)</span>
                        <span class="n">pen</span> <span class="o">=</span> <span class="n">getCoulombWavefunctions</span><span class="o">.</span><span class="n">coulombPenetrationFactor</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">eta</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">pen</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">VERBOSE</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span> <span class="n">iR</span><span class="p">,</span> <span class="n">ER</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">width</span> <span class="p">)</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;pen=</span><span class="si">%s</span><span class="s1"> for channel </span><span class="si">%s</span><span class="s1"> and resonance #</span><span class="si">%i</span><span class="s1">, but L0[</span><span class="si">%i</span><span class="s1">,</span><span class="si">%i</span><span class="s1">]=</span><span class="si">%s</span><span class="s1"> &#39;</span><span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">pen</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">),</span><span class="n">iR</span><span class="p">,</span><span class="n">ic</span><span class="p">,</span><span class="n">ic</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getL0Matrix</span><span class="p">(</span><span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">)[:,</span><span class="n">ic</span><span class="p">,</span><span class="n">ic</span><span class="p">])))</span>
                    <span class="k">else</span><span class="p">:</span> <span class="n">pen</span> <span class="o">=</span> <span class="mf">1.0</span>
                    <span class="k">if</span> <span class="n">pen</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                        <span class="n">redWidth</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="o">/</span><span class="n">pen</span><span class="p">)),</span> <span class="n">width</span> <span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">VERBOSE</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span> <span class="n">iR</span><span class="p">,</span> <span class="n">ER</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">width</span> <span class="p">)</span>
                        <span class="n">redWidth</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="mf">0.0</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>   <span class="n">redWidth</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="mf">0.0</span> <span class="p">)</span>

            <span class="c1"># Loop through all channels to accumulate the R Matrix elements</span>
            <span class="k">for</span> <span class="n">ic1</span><span class="p">,</span> <span class="n">c1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">iR</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span> <span class="n">c1</span> <span class="p">]:</span> <span class="k">continue</span>
                <span class="k">for</span> <span class="n">ic2</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="p">):</span>
                    <span class="k">if</span> <span class="n">ic2</span> <span class="o">&gt;</span> <span class="n">ic1</span><span class="p">:</span> <span class="k">break</span>     <span class="c1"># matrix is symmetric</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">iR</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span> <span class="n">c2</span> <span class="p">]:</span> <span class="k">continue</span>
                    <span class="n">dR</span> <span class="o">=</span> <span class="p">(</span><span class="n">redWidth</span><span class="p">[</span> <span class="n">ic1</span> <span class="p">]</span> <span class="o">*</span> <span class="n">redWidth</span><span class="p">[</span> <span class="n">ic2</span> <span class="p">]</span> <span class="o">/</span> <span class="p">(</span> <span class="n">ER</span><span class="o">-</span><span class="n">Ein</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">gamWidth</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="p">))</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dR</span><span class="p">)</span> <span class="p">):</span>
                        <span class="k">if</span> <span class="n">VERBOSE</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span> <span class="n">redWidth</span> <span class="p">)</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;nan in R-matrix for channels </span><span class="si">%s</span><span class="s1"> and </span><span class="si">%s</span><span class="s1"> &#39;</span><span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">c1</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span><span class="n">c2</span><span class="p">)))</span>
                    <span class="n">R</span><span class="p">[:,</span> <span class="n">ic1</span><span class="p">,</span> <span class="n">ic2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dR</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">ic1</span> <span class="o">!=</span> <span class="n">ic2</span><span class="p">:</span>
                        <span class="n">R</span><span class="p">[:,</span> <span class="n">ic2</span><span class="p">,</span> <span class="n">ic1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dR</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">R</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.getScatteringMatrixT"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.getScatteringMatrixT">[docs]</a>    <span class="k">def</span> <span class="nf">getScatteringMatrixT</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span><span class="p">,</span> <span class="n">useTabulatedScatteringRadius</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">enableExtraCoulombPhase</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param Ein:</span>
<span class="sd">        :type Ein: numpy.array(type=float)</span>
<span class="sd">        :param useTabulatedScatteringRadius:</span>
<span class="sd">        :type useTabulatedScatteringRadius: bool</span>
<span class="sd">        :param enableExtraCoulombPhase:</span>
<span class="sd">        :type enableExtraCoulombPhase: bool</span>
<span class="sd">        :return:</span>
<span class="sd">        :rtype:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure all channels are open at all requested energies</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">is_open</span><span class="p">(</span><span class="n">Ein</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;One or more channels are not open on all energies in requested energy grid&quot;</span><span class="p">)</span>

        <span class="n">T</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ein</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span> <span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span> <span class="p">)</span>
        <span class="n">U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getScatteringMatrixU</span><span class="p">(</span> <span class="n">Ein</span><span class="p">,</span>
                                       <span class="n">useTabulatedScatteringRadius</span><span class="o">=</span><span class="n">useTabulatedScatteringRadius</span><span class="p">,</span>
                                       <span class="n">enableExtraCoulombPhase</span><span class="o">=</span><span class="n">enableExtraCoulombPhase</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">ic1</span><span class="p">,</span> <span class="n">c1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="p">):</span>
            <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">particlePairs</span><span class="p">[</span><span class="n">c1</span><span class="p">]</span><span class="o">.</span><span class="n">reactionInfo</span><span class="p">[</span><span class="s1">&#39;particles&#39;</span><span class="p">]</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">(</span><span class="n">Ein</span><span class="o">-</span><span class="n">c1</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">)</span>
            <span class="n">wc</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span><span class="n">c1</span><span class="o">.</span><span class="n">l</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ic2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">nChannels</span> <span class="p">):</span>
                <span class="k">if</span> <span class="n">enableExtraCoulombPhase</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">ic1</span><span class="o">==</span><span class="n">ic2</span><span class="p">:</span> <span class="n">eTwoIWcDeltacc</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="n">j</span><span class="o">*</span><span class="n">wc</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>        <span class="n">eTwoIWcDeltacc</span><span class="o">=</span><span class="mf">0.0</span><span class="n">j</span>
                    <span class="n">T</span><span class="p">[:,</span> <span class="n">ic1</span><span class="p">,</span> <span class="n">ic2</span><span class="p">]</span> <span class="o">=</span> <span class="n">eTwoIWcDeltacc</span>  <span class="o">-</span> <span class="n">U</span><span class="p">[:,</span> <span class="n">ic1</span><span class="p">,</span> <span class="n">ic2</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">T</span><span class="p">[:,</span> <span class="n">ic1</span><span class="p">,</span> <span class="n">ic2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">ic1</span><span class="o">==</span><span class="n">ic2</span><span class="p">)</span> <span class="o">-</span> <span class="n">U</span><span class="p">[:,</span> <span class="n">ic1</span><span class="p">,</span> <span class="n">ic2</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">T</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.getEiPhis"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.getEiPhis">[docs]</a>    <span class="k">def</span> <span class="nf">getEiPhis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Ein</span><span class="p">,</span> <span class="n">useTabulatedScatteringRadius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">enableExtraCoulombPhase</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The phase factor for the collision matrix, :math:`\\Omega_c=e^{\\omega_c-\\varphi_c}`</span>

<span class="sd">        :param Ein:</span>
<span class="sd">        :type Ein: numpy.array(type=float)</span>
<span class="sd">        :param useTabulatedScatteringRadius:</span>
<span class="sd">        :type useTabulatedScatteringRadius: bool</span>
<span class="sd">        :param enableExtraCoulombPhase:</span>
<span class="sd">        :type enableExtraCoulombPhase: bool</span>
<span class="sd">        :return:</span>
<span class="sd">        :rtype:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Precompute phase factor</span>
        <span class="n">eiphis</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ic</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">channelClass</span> <span class="ow">in</span> <span class="p">[</span><span class="n">FISSIONCHANNEL</span><span class="p">,</span> <span class="n">GAMMACHANNEL</span><span class="p">]:</span>
                <span class="n">eiphis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span> <span class="n">Ein</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span> <span class="p">)</span> <span class="p">)</span>
            <span class="k">elif</span> <span class="n">c</span><span class="o">.</span><span class="n">channelClass</span> <span class="o">==</span> <span class="n">CPCHANNEL</span><span class="p">:</span>
                <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rhohat</span><span class="p">(</span><span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">particlePairs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">reactionInfo</span><span class="p">[</span><span class="s1">&#39;particles&#39;</span><span class="p">]</span>
                <span class="n">eta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">(</span><span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">)</span>
                <span class="n">phic</span> <span class="o">=</span> <span class="n">getCoulombWavefunctions</span><span class="o">.</span><span class="n">coulombPhi</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">eta</span> <span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">phic</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span> <span class="s1">&#39;phi is NaN for channel </span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1"> &#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">),</span><span class="nb">str</span><span class="p">(</span> <span class="nb">list</span><span class="p">(</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Ein</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span><span class="n">phic</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
                <span class="k">if</span> <span class="n">enableExtraCoulombPhase</span><span class="p">:</span>
                    <span class="n">wc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span><span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                    <span class="n">eiphis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">wc</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phic</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="p">)</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">eiphis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phic</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="p">)</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rhohat</span><span class="p">(</span><span class="n">Ein</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                <span class="n">phic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">rho</span> <span class="p">)</span>
                <span class="n">eiphis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phic</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">eiphis</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.k_competitive"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.k_competitive">[docs]</a>    <span class="k">def</span> <span class="nf">k_competitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Ex</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate k for any 2-body output channel.</span>

<span class="sd">        Note that if pA and pB are target and neutron, this reduces to self.k(E) as defined above</span>
<span class="sd">        in the ResonanceReconstructionBaseClass</span>

<span class="sd">        :param Ex: incident energy - Xi (Xi is the lab frame reaction threshold)</span>
<span class="sd">        :param pA: particle A</span>
<span class="sd">        :param pB: particle B</span>
<span class="sd">        :return: k in b**-1/2</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">particleA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">PoPs</span><span class="p">[</span><span class="n">pA</span><span class="o">.</span><span class="n">pid</span><span class="p">]</span>
        <span class="n">pA_mass</span> <span class="o">=</span> <span class="n">particleA</span><span class="o">.</span><span class="n">getMass</span><span class="p">(</span> <span class="s1">&#39;amu&#39;</span> <span class="p">)</span>
        <span class="n">particleB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">PoPs</span><span class="p">[</span><span class="n">pB</span><span class="o">.</span><span class="n">pid</span><span class="p">]</span>
        <span class="n">pB_mass</span> <span class="o">=</span> <span class="n">particleB</span><span class="o">.</span><span class="n">getMass</span><span class="p">(</span> <span class="s1">&#39;amu&#39;</span> <span class="p">)</span>
        <span class="n">targ_mass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetMass_amu</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">kConstant1</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">pA_mass</span> <span class="o">*</span> <span class="n">pB_mass</span> <span class="o">/</span> <span class="p">(</span><span class="n">pB_mass</span> <span class="o">+</span> <span class="n">pA_mass</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">neutronMass_amu</span> <span class="o">*</span>
                <span class="n">targ_mass</span> <span class="o">/</span> <span class="p">(</span><span class="n">targ_mass</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">projectileMass_amu</span><span class="p">)</span> <span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Ex</span><span class="p">))</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.eta"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.eta">[docs]</a>    <span class="k">def</span> <span class="nf">eta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Ex</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        eta, the  Sommerfeld parameter, given by :math:`\\eta = Z_A Z_B m_{red} \\alpha / ( \\hbar c k )`</span>

<span class="sd">        for competitive channels with 2 charged particles, parameter eta is used to find penetrability.</span>
<span class="sd">        eta is given in eq D.79 of ENDF manual and $e^2$ is the fine structure constant $\alpha$ and</span>
<span class="sd">        $m_{red}$ is the reduced mass.  eta is dimensionless.</span>

<span class="sd">        :param Ex: The incident energy</span>
<span class="sd">        :param pA: particle A</span>
<span class="sd">        :param pB: particle B</span>
<span class="sd">        :return:   the Sommerfeld parameter [dimensionless]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">particleA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">PoPs</span><span class="p">[</span><span class="n">pA</span><span class="o">.</span><span class="n">pid</span><span class="p">]</span>
        <span class="n">pA_z</span> <span class="o">=</span> <span class="n">chemicalElementMiscPoPsModule</span><span class="o">.</span><span class="n">ZAInfo</span><span class="p">(</span> <span class="n">particleA</span> <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">particleB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">PoPs</span><span class="p">[</span><span class="n">pB</span><span class="o">.</span><span class="n">pid</span><span class="p">]</span>
        <span class="n">pB_z</span> <span class="o">=</span> <span class="n">chemicalElementMiscPoPsModule</span><span class="o">.</span><span class="n">ZAInfo</span><span class="p">(</span> <span class="n">particleB</span> <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">pA_z</span> <span class="o">*</span> <span class="n">pB_z</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">Ex</span><span class="p">)</span>

        <span class="n">pA_mass</span> <span class="o">=</span> <span class="n">particleA</span><span class="o">.</span><span class="n">getMass</span><span class="p">(</span> <span class="s1">&#39;amu&#39;</span> <span class="p">)</span>
        <span class="n">pB_mass</span> <span class="o">=</span> <span class="n">particleB</span><span class="o">.</span><span class="n">getMass</span><span class="p">(</span> <span class="s1">&#39;amu&#39;</span> <span class="p">)</span>
        <span class="n">mn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projectileMass_amu</span>
        <span class="n">eSq_over_hbarSq</span> <span class="o">=</span> <span class="mf">3.4746085579272e-1</span>    <span class="c1"># ?, should be b**-1/2</span>
        <span class="n">k_comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_competitive</span><span class="p">(</span><span class="n">Ex</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">)</span> <span class="c1"># in b**-1/2</span>
        <span class="n">eta</span> <span class="o">=</span> <span class="p">(</span><span class="n">eSq_over_hbarSq</span> <span class="o">*</span> <span class="n">pA_z</span> <span class="o">*</span> <span class="n">pB_z</span> <span class="o">*</span> <span class="p">(</span><span class="n">pA_mass</span><span class="o">/</span><span class="n">mn</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pB_mass</span><span class="o">/</span><span class="p">(</span><span class="n">pB_mass</span><span class="o">+</span><span class="n">pA_mass</span><span class="p">))</span> <span class="o">/</span> <span class="n">k_comp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">eta</span></div>

<div class="viewcode-block" id="RMatrixLimitedcrossSection.getCrossSection"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.RMatrixLimitedcrossSection.getCrossSection">[docs]</a>    <span class="nd">@blockwise</span>
    <span class="k">def</span> <span class="nf">getCrossSection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return reconstructed cross sections at incident energy E</span>
<span class="sd">        :param E: incident energy (unit = self.energyUnit).  May be scalar or vector</span>
<span class="sd">        :return: dictionary with cross sections for each reaction.</span>
<span class="sd">            Cross sections are either scalar or vector, depending on type of parameter &#39;E&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elasticSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">absorbtionSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">fissionSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nCompetitive</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="p">[</span><span class="n">ch</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceReactions</span> <span class="k">if</span> <span class="n">ch</span><span class="o">.</span><span class="n">tag</span><span class="o">==</span><span class="s1">&#39;competitive&#39;</span><span class="p">]</span> <span class="p">)</span>
        <span class="n">competitiveSum</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,]</span> <span class="o">*</span> <span class="n">nCompetitive</span>

        <span class="n">eliminatedReaction</span> <span class="o">=</span> <span class="p">[</span><span class="n">rr</span> <span class="k">for</span> <span class="n">rr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceReactions</span> <span class="k">if</span> <span class="n">rr</span><span class="o">.</span><span class="n">eliminated</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">approximation</span> <span class="ow">is</span> <span class="n">resolvedModule</span><span class="o">.</span><span class="n">RMatrix</span><span class="o">.</span><span class="n">Approximation</span><span class="o">.</span><span class="n">ReichMoore</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">eliminatedReaction</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only 1 reaction can be eliminated in Reich-Moore approximation!&quot;</span><span class="p">)</span>
        <span class="n">haveEliminated</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># only set to true if at least one non-zero width is present</span>

        <span class="k">for</span> <span class="n">sg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">spinGroups</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">spin</span>
            <span class="n">gfact</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mf">1.0</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">projectileSpin</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">targetSpin</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

            <span class="n">widths</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">penetrabilities</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">phis</span> <span class="o">=</span> <span class="p">[]</span>    <span class="c1"># phi is l-dependant</span>
            <span class="n">Xis</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">thresholdIndices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">chanIds</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">eliminatedWidth</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="n">sg</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">nRows</span> <span class="p">)</span>

            <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="n">sg</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
                <span class="n">resonanceReaction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceReactions</span><span class="p">[</span> <span class="n">chan</span><span class="o">.</span><span class="n">resonanceReaction</span> <span class="p">]</span>
                <span class="n">chanWidths</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">sg</span><span class="o">.</span><span class="n">resonanceParameters</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">getColumn</span><span class="p">(</span><span class="n">chan</span><span class="o">.</span><span class="n">columnIndex</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">)</span> <span class="p">)</span>

                <span class="k">if</span> <span class="n">resonanceReaction</span><span class="o">.</span><span class="n">eliminated</span><span class="p">:</span>
                    <span class="n">eliminatedWidth</span> <span class="o">+=</span> <span class="n">chanWidths</span> <span class="o">/</span> <span class="mi">2</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">eliminatedWidth</span><span class="p">):</span> <span class="n">haveEliminated</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="n">resonanceReaction</span><span class="o">.</span><span class="n">isFission</span><span class="p">():</span>
                    <span class="c1"># penetrability treated as 1 everywhere</span>
                    <span class="n">reducedWidths</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="nb">abs</span><span class="p">(</span><span class="n">chanWidths</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">)</span>
                    <span class="n">reducedWidths</span><span class="p">[</span> <span class="n">chanWidths</span><span class="o">&lt;</span><span class="mi">0</span> <span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">widths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">reducedWidths</span> <span class="p">)</span>
                    <span class="n">penetrabilities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]])</span> <span class="p">)</span>
                    <span class="n">chanIds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">chan</span><span class="o">.</span><span class="n">resonanceReaction</span> <span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">l</span> <span class="o">=</span> <span class="n">chan</span><span class="o">.</span><span class="n">L</span>
                    <span class="n">pA</span><span class="p">,</span><span class="n">pB</span> <span class="o">=</span> <span class="n">resonanceReaction</span><span class="o">.</span><span class="n">reactionInfo</span><span class="p">[</span><span class="s1">&#39;particles&#39;</span><span class="p">]</span>
                    <span class="n">Xi</span> <span class="o">=</span> <span class="n">resonanceReaction</span><span class="o">.</span><span class="n">reactionInfo</span><span class="p">[</span><span class="s1">&#39;Xi&#39;</span><span class="p">]</span>
                    <span class="n">Xis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">Xi</span> <span class="p">)</span>
                    <span class="n">chanIds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">chan</span><span class="o">.</span><span class="n">resonanceReaction</span> <span class="p">)</span>

                    <span class="k">if</span> <span class="n">Xi</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># find index of first incident energy above threshold:</span>
                        <span class="kn">import</span> <span class="nn">bisect</span>
                        <span class="n">thresholdIndex</span> <span class="o">=</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect</span><span class="p">(</span> <span class="n">E</span><span class="p">,</span> <span class="n">Xi</span> <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">thresholdIndex</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">thresholdIndices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">thresholdIndex</span> <span class="p">)</span>

                    <span class="c1"># channel radius:</span>
                    <span class="k">def</span> <span class="nf">rho</span><span class="p">(</span> <span class="n">Ex</span> <span class="p">):</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">calculateChannelRadius</span><span class="p">:</span>
                            <span class="n">a</span> <span class="o">=</span> <span class="mf">0.123</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetMass_amu</span><span class="o">**</span><span class="p">(</span> <span class="mf">1.</span> <span class="o">/</span> <span class="mf">3.</span> <span class="p">)</span> <span class="o">+</span> <span class="mf">0.08</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">a</span> <span class="o">=</span> <span class="n">chan</span><span class="o">.</span><span class="n">getScatteringRadius</span><span class="p">()</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;10*fm&#39;</span><span class="p">)</span>
                        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_competitive</span><span class="p">(</span><span class="n">Ex</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span>

                    <span class="c1"># rhohat, for calculating phase shift phi:</span>
                    <span class="n">rhohat</span> <span class="o">=</span> <span class="n">chan</span><span class="o">.</span><span class="n">getHardSphereRadius</span><span class="p">()</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;10*fm&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
                    <span class="n">phinow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">rhohat</span><span class="p">)</span>
                    <span class="n">phinow</span><span class="p">[</span> <span class="n">phinow</span><span class="o">/</span><span class="n">rhohat</span> <span class="o">&lt;</span> <span class="mf">1e-6</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># see subroutine &#39;facphi&#39; in RECENT</span>
                    <span class="n">phis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">phinow</span> <span class="p">)</span>

                    <span class="c1"># penetrability:</span>
                    <span class="n">Ex1</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">energy</span><span class="o">-</span><span class="n">Xi</span><span class="p">)</span>         <span class="c1"># evaluated at resonances</span>
                    <span class="n">Ex2</span> <span class="o">=</span> <span class="n">E</span><span class="o">-</span><span class="n">Xi</span><span class="p">;</span> <span class="n">Ex2</span><span class="p">[</span><span class="n">Ex2</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>      <span class="c1"># evaluated at each incident energy</span>
                    <span class="n">eta1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">(</span><span class="n">Ex1</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">resonanceReaction</span><span class="o">.</span><span class="n">eliminated</span> <span class="ow">or</span> <span class="n">resonanceReaction</span><span class="o">.</span><span class="n">isFission</span><span class="p">():</span>
                        <span class="n">penetrabilityAtResonances</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span> <span class="n">Ex1</span> <span class="p">)</span>
                        <span class="n">penetrabilityAtEin</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span> <span class="n">Ex2</span> <span class="p">)</span>
                    <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">eta1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="c1"># output channel has two charged particles, need Coulomb penetrability:</span>
                        <span class="n">penetrabilityAtResonances</span> <span class="o">=</span> <span class="n">getCoulombWavefunctions</span><span class="o">.</span><span class="n">coulombPenetrationFactor</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">rho</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Ex1</span><span class="p">)),</span> <span class="n">eta1</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">thresholdIndex</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># threshold reaction</span>
                            <span class="n">eta2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span> <span class="n">Ex2</span> <span class="p">)</span>
                            <span class="n">eta2</span><span class="p">[</span> <span class="n">thresholdIndex</span><span class="p">:</span> <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">(</span> <span class="n">Ex2</span><span class="p">[</span> <span class="n">thresholdIndex</span><span class="p">:</span> <span class="p">],</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span> <span class="p">)</span>

                            <span class="n">penetrabilityAtEin</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span> <span class="n">Ex2</span> <span class="p">)</span>
                            <span class="n">penetrabilityAtEin</span><span class="p">[</span> <span class="n">thresholdIndex</span><span class="p">:</span> <span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                                    <span class="n">getCoulombWavefunctions</span><span class="o">.</span><span class="n">coulombPenetrationFactor</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">rho</span><span class="p">(</span><span class="n">Ex2</span><span class="p">[</span> <span class="n">thresholdIndex</span><span class="p">:</span> <span class="p">]),</span>
                                    <span class="n">eta2</span><span class="p">[</span> <span class="n">thresholdIndex</span><span class="p">:</span> <span class="p">]</span> <span class="p">)</span> <span class="p">)</span>

                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">eta2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">(</span><span class="n">Ex2</span><span class="p">,</span> <span class="n">pA</span><span class="p">,</span> <span class="n">pB</span><span class="p">)</span>
                            <span class="n">penetrabilityAtEin</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">getCoulombWavefunctions</span><span class="o">.</span><span class="n">coulombPenetrationFactor</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">rho</span><span class="p">(</span><span class="n">Ex2</span><span class="p">),</span> <span class="n">eta2</span><span class="p">)</span> <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># no Coulomb contribution:</span>
                        <span class="n">penetrabilityAtResonances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">rho</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Ex1</span><span class="p">)))</span>
                        <span class="n">penetrabilityAtEin</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">rho</span><span class="p">(</span><span class="n">Ex2</span><span class="p">))</span> <span class="p">)</span>

                    <span class="n">reducedWidths</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="nb">abs</span><span class="p">(</span><span class="n">chanWidths</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">penetrabilityAtResonances</span><span class="p">)</span> <span class="p">)</span>
                    <span class="n">reducedWidths</span><span class="p">[</span> <span class="n">chanWidths</span><span class="o">&lt;</span><span class="mi">0</span> <span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">widths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">reducedWidths</span> <span class="p">)</span>
                    <span class="n">penetrabilities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">penetrabilityAtEin</span> <span class="p">)</span>

            <span class="c1"># are there any threshold reactions (negative Q-values)?</span>
            <span class="c1"># If so, we must break up the calculation above/below each threshold</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span> <span class="n">thresholdIndices</span> <span class="p">):</span>
                <span class="k">if</span> <span class="n">thresholdIndices</span> <span class="o">!=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">thresholdIndices</span><span class="p">):</span>
                    <span class="c1"># sort by increasing threshold</span>
                    <span class="p">(</span><span class="n">thresholdIndices</span><span class="p">,</span> <span class="n">chanIds</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="n">penetrabilities</span><span class="p">)</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="nb">zip</span><span class="p">(</span> <span class="o">*</span><span class="nb">sorted</span><span class="p">(</span>
                        <span class="nb">zip</span><span class="p">(</span><span class="n">thresholdIndices</span><span class="p">,</span><span class="n">chanIds</span><span class="p">,</span><span class="n">widths</span><span class="p">,</span><span class="n">penetrabilities</span><span class="p">),</span>
                        <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tmp</span><span class="p">:</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># sort only by threshold index (not by id or width)</span>
                    <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
                <span class="k">assert</span> <span class="n">thresholdIndices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
                <span class="n">thresholdIndices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">thresholdIndices</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)]</span>

                <span class="n">RI</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">)))</span>
                <span class="n">SI</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="n">RI</span><span class="o">.</span><span class="n">shape</span> <span class="p">)</span>

                <span class="n">threshSet</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">thresholdIndices</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">threshSet</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">low</span> <span class="o">=</span> <span class="n">threshSet</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span>
                    <span class="n">high</span> <span class="o">=</span> <span class="n">threshSet</span><span class="p">[</span><span class="n">i1</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">nOpen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="p">[</span><span class="n">th</span> <span class="k">for</span> <span class="n">th</span> <span class="ow">in</span> <span class="n">thresholdIndices</span> <span class="k">if</span> <span class="n">th</span><span class="o">-</span><span class="n">low</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
                    <span class="n">RI_now</span><span class="p">,</span> <span class="n">SI_now</span> <span class="o">=</span> <span class="n">invertMatrices</span><span class="p">(</span>
                            <span class="o">*</span><span class="n">getR_S</span><span class="p">(</span> <span class="n">E</span><span class="p">[</span><span class="n">low</span><span class="p">:</span><span class="n">high</span><span class="p">],</span> <span class="n">sg</span><span class="o">.</span><span class="n">energy</span><span class="p">,</span> <span class="n">eliminatedWidth</span><span class="p">,</span>
                            <span class="n">widths</span><span class="p">[:</span><span class="n">nOpen</span><span class="p">],</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">low</span><span class="p">:</span><span class="n">high</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">penetrabilities</span><span class="p">[:</span><span class="n">nOpen</span><span class="p">]]</span> <span class="p">)</span>
                            <span class="p">)</span>
                    <span class="k">if</span> <span class="n">nOpen</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>  <span class="c1"># numpy insists on same number of dimensions for copy:</span>
                        <span class="n">RI_now</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">SI_now</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">RI_now</span><span class="p">),</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

                    <span class="n">RI</span><span class="p">[</span><span class="n">low</span><span class="p">:</span><span class="n">high</span><span class="p">,</span> <span class="p">:</span><span class="n">nOpen</span><span class="p">,</span> <span class="p">:</span><span class="n">nOpen</span><span class="p">]</span> <span class="o">=</span> <span class="n">RI_now</span>
                    <span class="n">SI</span><span class="p">[</span><span class="n">low</span><span class="p">:</span><span class="n">high</span><span class="p">,</span> <span class="p">:</span><span class="n">nOpen</span><span class="p">,</span> <span class="p">:</span><span class="n">nOpen</span><span class="p">]</span> <span class="o">=</span> <span class="n">SI_now</span>

            <span class="k">else</span><span class="p">:</span>   <span class="c1"># no threshold reactions</span>
                <span class="n">RI</span><span class="p">,</span><span class="n">SI</span> <span class="o">=</span> <span class="n">invertMatrices</span><span class="p">(</span>
                        <span class="o">*</span><span class="n">getR_S</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">sg</span><span class="o">.</span><span class="n">energy</span><span class="p">,</span> <span class="n">eliminatedWidth</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="n">penetrabilities</span><span class="p">)</span>
                        <span class="p">)</span>

            <span class="c1"># reconstruct:</span>
            <span class="n">chanIds</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">chanIds</span> <span class="p">)</span>
            <span class="n">elasID</span> <span class="o">=</span> <span class="p">[</span><span class="n">tmp</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">tmp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceReactions</span> <span class="k">if</span> <span class="n">tmp</span><span class="o">.</span><span class="n">tag</span><span class="o">==</span><span class="s1">&#39;elastic&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">competitiveIDs</span> <span class="o">=</span> <span class="p">[</span><span class="n">tmp</span><span class="o">.</span><span class="n">link</span><span class="o">.</span><span class="n">link</span><span class="o">.</span><span class="n">label</span>
                              <span class="k">for</span> <span class="n">tmp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceReactions</span> <span class="k">if</span> <span class="n">tmp</span><span class="o">.</span><span class="n">tag</span><span class="o">==</span><span class="s1">&#39;competitive&#39;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">chan</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceReactions</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">chan</span><span class="o">.</span><span class="n">eliminated</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="c1"># which matrix elements correspond to this channel?</span>
                <span class="n">thisChanIds</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="n">chanIds</span><span class="o">==</span><span class="n">chan</span><span class="o">.</span><span class="n">label</span> <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">thisChanIds</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">id1</span><span class="p">,</span> <span class="n">id2</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">thisChanIds</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">thisChanIds</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">thisChanIds</span><span class="p">)</span> <span class="o">==</span> <span class="n">id2</span><span class="o">-</span><span class="n">id1</span>
                <span class="k">if</span> <span class="n">chan</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s1">&#39;elastic&#39;</span><span class="p">:</span>
                    <span class="n">elas</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">absorb</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="c1"># diagonal component</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">id1</span><span class="p">,</span><span class="n">id2</span><span class="p">):</span>
                        <span class="n">phi</span> <span class="o">=</span> <span class="n">phis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># convert to row vector</span>
                        <span class="n">sinsqr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
                        <span class="n">sincos</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
                        <span class="n">elas</span> <span class="o">+=</span> <span class="p">(</span> <span class="n">sinsqr</span> <span class="o">*</span> <span class="p">(</span><span class="n">sinsqr</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">RI</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="n">sincos</span> <span class="o">*</span> <span class="p">(</span><span class="n">sincos</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">SI</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">])</span> <span class="p">)</span>
                        <span class="n">absorb</span> <span class="o">+=</span> <span class="o">-</span><span class="n">RI</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>
                    <span class="c1"># add cross-terms:</span>
                    <span class="n">elas</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">RI</span><span class="p">[:,</span><span class="n">id1</span><span class="p">:</span><span class="n">id2</span><span class="p">,</span><span class="n">id1</span><span class="p">:</span><span class="n">id2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">SI</span><span class="p">[:,</span><span class="n">id1</span><span class="p">:</span><span class="n">id2</span><span class="p">,</span><span class="n">id1</span><span class="p">:</span><span class="n">id2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">absorb</span> <span class="o">-=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">RI</span><span class="p">[:,</span><span class="n">id1</span><span class="p">:</span><span class="n">id2</span><span class="p">,</span><span class="n">id1</span><span class="p">:</span><span class="n">id2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">SI</span><span class="p">[:,</span><span class="n">id1</span><span class="p">:</span><span class="n">id2</span><span class="p">,</span><span class="n">id1</span><span class="p">:</span><span class="n">id2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">elasticSum</span> <span class="o">+=</span> <span class="n">gfact</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">elas</span>
                    <span class="n">absorbtionSum</span> <span class="o">+=</span> <span class="n">gfact</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">absorb</span>

                <span class="k">else</span><span class="p">:</span> <span class="c1"># competitive or fission:</span>
                    <span class="c1"># sum of cross-terms between this channel and elastic:</span>
                    <span class="n">elasticIds</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="n">chanIds</span><span class="o">==</span><span class="n">elasID</span> <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elasticIds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">el1</span><span class="p">,</span> <span class="n">el2</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">elasticIds</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">elasticIds</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
                    <span class="n">comp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">SI</span><span class="p">[:,</span><span class="n">id1</span><span class="p">:</span><span class="n">id2</span><span class="p">,</span><span class="n">el1</span><span class="p">:</span><span class="n">el2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">RI</span><span class="p">[:,</span><span class="n">id1</span><span class="p">:</span><span class="n">id2</span><span class="p">,</span><span class="n">el1</span><span class="p">:</span><span class="n">el2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">chan</span><span class="o">.</span><span class="n">isFission</span><span class="p">():</span>
                        <span class="n">fissionSum</span> <span class="o">+=</span> <span class="n">gfact</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">comp</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># may have more than one competitive: add to correct channel</span>
                        <span class="n">competitiveSum</span><span class="p">[</span> <span class="n">competitiveIDs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">chan</span><span class="o">.</span><span class="n">link</span><span class="o">.</span><span class="n">link</span><span class="o">.</span><span class="n">label</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">gfact</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">comp</span>

        <span class="c1"># get common factor &#39;beta&#39; as a row vector:</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">elastic</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">elasticSum</span>
        <span class="n">competitive</span> <span class="o">=</span> <span class="p">[</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">comp</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">competitiveSum</span> <span class="p">]</span>
        <span class="n">fission</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">fissionSum</span>
        <span class="k">if</span> <span class="n">haveEliminated</span><span class="p">:</span>
            <span class="n">absorbtion</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">absorbtionSum</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">absorbtion</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">competitive</span><span class="p">)</span> <span class="o">+</span> <span class="n">fission</span> <span class="c1"># more numerically stable in absence of eliminated channel</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">elastic</span> <span class="o">+</span> <span class="n">absorbtion</span>

        <span class="n">retDict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;total&#39;</span><span class="p">:</span><span class="n">total</span><span class="p">,</span> <span class="s1">&#39;elastic&#39;</span><span class="p">:</span><span class="n">elastic</span><span class="p">,</span> <span class="s1">&#39;fission&#39;</span><span class="p">:</span><span class="n">fission</span><span class="p">,</span> <span class="s1">&#39;nonelastic&#39;</span><span class="p">:</span><span class="n">absorbtion</span><span class="p">}</span>
        <span class="n">competitiveNames</span> <span class="o">=</span> <span class="p">[</span><span class="n">ch</span><span class="o">.</span><span class="n">link</span><span class="o">.</span><span class="n">link</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">RR</span><span class="o">.</span><span class="n">resonanceReactions</span> <span class="k">if</span> <span class="n">ch</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s1">&#39;competitive&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">competitiveNames</span><span class="p">,</span><span class="n">competitive</span><span class="p">):</span>
            <span class="n">retDict</span><span class="p">[</span> <span class="n">key</span> <span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">if</span> <span class="n">haveEliminated</span><span class="p">:</span>
            <span class="n">retDict</span><span class="p">[</span><span class="n">eliminatedReaction</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">absorbtion</span> <span class="o">-</span> <span class="n">fission</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">competitive</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">retDict</span></div></div>


<span class="c1">##### unresolved resonance region. Only one formalism here: #####</span>
<div class="viewcode-block" id="URRcrossSection"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.URRcrossSection">[docs]</a><span class="k">class</span> <span class="nc">URRcrossSection</span><span class="p">(</span><span class="n">ResonanceReconstructionBaseClass</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">URRform</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the URR management class</span>

<span class="sd">        :param URRform: The tabulatedWidths class to be reconstructed</span>
<span class="sd">        :param verbose: duh, verbosity flag</span>
<span class="sd">        :param kw: Python dict of keywords, currently none defined</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ResonanceReconstructionBaseClass</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">URRform</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>

        <span class="c1"># energy boundaries for this region:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">URR</span> <span class="o">=</span> <span class="n">URRform</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="n">URRform</span><span class="o">.</span><span class="n">ancestor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">domainMin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">domainMax</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Unresolved from </span><span class="si">%f</span><span class="s2"> to </span><span class="si">%f</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">energyUnit</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">levelSpacings</span><span class="o">=</span><span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">averageWidths</span><span class="o">=</span><span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">DOFs</span><span class="o">=</span><span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">egrid</span><span class="o">=</span><span class="kc">None</span>

<div class="viewcode-block" id="URRcrossSection.getWidthsAndSpacings"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.URRcrossSection.getWidthsAndSpacings">[docs]</a>    <span class="k">def</span> <span class="nf">getWidthsAndSpacings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        URR tables give us the average resonance parameters, the average resonance spacing</span>
<span class="sd">        and the number of degrees of freedom, assuming that the widths are distributed by a chi^2</span>
<span class="sd">        probability density function with the given number of degrees of freedom.</span>

<span class="sd">        This function sets several member data as dicts (indexed by L &amp; J) of data and interpolable functions::</span>

<span class="sd">            - levelSpacings::</span>

<span class="sd">                ..math::</span>
<span class="sd">                    D_{L,J}(E)</span>

<span class="sd">            - averageWidths, assigned simple labels like &#39;elastic&#39; and &#39;capture&#39; for convenience::</span>

<span class="sd">                ..math::</span>
<span class="sd">                    \\Gamma_{L,J,c}</span>

<span class="sd">              there is a wrinkle here. The elastic &#39;width&#39; is, according to the ENDF manual, a &quot;reduced width&quot; GN0.</span>
<span class="sd">              This is misleading since basic science literature (and Froehner in JEFF-18) defines the reduced width</span>
<span class="sd">              as::</span>

<span class="sd">                ..math::</span>
<span class="sd">                    \\Gamma_{L,J,n} = 2 P_L \\gamma_{L,J,c}^2</span>

<span class="sd">              However, ENDF&#39;s reduced neutron width is wildly different (see Eq. (D.99) in ENDF-102)::</span>

<span class="sd">                ..math::</span>
<span class="sd">                    \\Gamma{L,J,n} = \\Gamma_{L,J,n}^0 \\sqrt{E} P_L/\\rho</span>

<span class="sd">            - DOFs: degrees of freedom with same labels as averageWidths</span>

<span class="sd">            - reactionLabels: which reactions correspond to &#39;elastic&#39;, &#39;capture&#39; and &#39;fission&#39;</span>

<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">levelSpacings</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>  <span class="c1"># FIXME why OrderedDict? Does order matter?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">averageWidths</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">DOFs</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reactionLabels</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>

        <span class="n">reactionFinder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">URR</span><span class="o">.</span><span class="n">findAttributeInAncestry</span><span class="p">(</span><span class="s1">&#39;getReaction&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">reaction</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">URR</span><span class="o">.</span><span class="n">resonanceReactions</span><span class="p">:</span>
            <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">simpleLabel</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;elastic&#39;</span><span class="p">,</span><span class="s1">&#39;capture&#39;</span><span class="p">,</span><span class="s1">&#39;fission&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">reaction</span><span class="o">.</span><span class="n">link</span><span class="o">.</span><span class="n">link</span> <span class="ow">is</span> <span class="n">reactionFinder</span><span class="p">(</span><span class="n">simpleLabel</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">reactionLabels</span><span class="p">[</span><span class="n">reaction</span><span class="o">.</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">simpleLabel</span>
                    <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Reaction &#39;</span><span class="si">%s</span><span class="s2">&#39; not yet supported in unresolved region&quot;</span> <span class="o">%</span> <span class="n">reaction</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">URR</span><span class="o">.</span><span class="n">Ls</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">L</span>
            <span class="k">for</span> <span class="n">J</span> <span class="ow">in</span> <span class="n">L</span><span class="o">.</span><span class="n">Js</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">J</span><span class="o">.</span><span class="n">J</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">levelSpacings</span><span class="p">[(</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span><span class="o">=</span><span class="n">J</span><span class="o">.</span><span class="n">levelSpacing</span><span class="o">.</span><span class="n">data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">averageWidths</span><span class="p">[(</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span><span class="o">=</span><span class="p">{}</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">DOFs</span><span class="p">[(</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span><span class="o">=</span><span class="p">{}</span>

                <span class="c1"># Set the widths</span>
                <span class="k">for</span> <span class="n">wid</span> <span class="ow">in</span> <span class="n">J</span><span class="o">.</span><span class="n">widths</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">wid</span><span class="o">.</span><span class="n">resonanceReaction</span> <span class="o">==</span> <span class="s1">&#39;competitive&#39;</span><span class="p">:</span>
                        <span class="n">simpleLabel</span> <span class="o">=</span> <span class="n">wid</span><span class="o">.</span><span class="n">resonanceReaction</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">simpleLabel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reactionLabels</span><span class="p">[</span> <span class="n">wid</span><span class="o">.</span><span class="n">resonanceReaction</span> <span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">averageWidths</span><span class="p">[(</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">)][</span><span class="n">simpleLabel</span><span class="p">]</span> <span class="o">=</span> <span class="n">wid</span><span class="o">.</span><span class="n">data</span>  <span class="c1"># FIXME: average neutron width is funky ENDF &quot;reduced width&quot;, we should fix it!</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">DOFs</span><span class="p">[(</span><span class="n">l</span><span class="p">,</span> <span class="n">j</span><span class="p">)][</span><span class="n">simpleLabel</span><span class="p">]</span> <span class="o">=</span> <span class="n">wid</span><span class="o">.</span><span class="n">degreesOfFreedom</span></div>

<div class="viewcode-block" id="URRcrossSection.rho"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.URRcrossSection.rho">[docs]</a>    <span class="k">def</span> <span class="nf">rho</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The dimensionless parameter rho::</span>

<span class="sd">            ..math::</span>
<span class="sd">                \\rho = k(E) a</span>

<span class="sd">        We always calculate channel radius for unresolved region according to the ENDF manual</span>

<span class="sd">        :param E: the incident neutron energy</span>
<span class="sd">        :return: rho</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mf">0.123</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetMass_amu</span><span class="o">**</span><span class="p">(</span> <span class="mf">1.</span> <span class="o">/</span> <span class="mf">3.</span> <span class="p">)</span> <span class="o">+</span> <span class="mf">0.08</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span></div>

<div class="viewcode-block" id="URRcrossSection.getFluctuationIntegrals"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.URRcrossSection.getFluctuationIntegrals">[docs]</a>    <span class="k">def</span> <span class="nf">getFluctuationIntegrals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="n">DOF</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        From subroutine GNRL3 in RECENT. If possible, this will be replaced</span>
<span class="sd">        with more basic approach (rather than using lookup table)... not finding</span>
<span class="sd">        appropriate equations right now</span>

<span class="sd">        Comments from GNRL3 sourcecode::</span>

<span class="sd">              Calculate unresolved resonance fluctuation function</span>
<span class="sd">              (original coding from AVERAGE4 by Mulki Bhat)</span>
<span class="sd">              (new weighting scheme from MC^2-II)</span>

<span class="sd">              This routine has been modified to calculate elastic, capture</span>
<span class="sd">              and fission fluctuation functions all during one call (as</span>
<span class="sd">              opposed to the original version which calculated each reaction</span>
<span class="sd">              separately).</span>

<span class="sd">              GNX, GGX, GFX and GXX are the widths for elastic, capture,</span>
<span class="sd">              fission and competition. MUN, MUF and MUX are the number of</span>
<span class="sd">              degrees of freedom for elastic, fission and competition (infinite</span>
<span class="sd">              number of degrees assumed for capture). RN, RC and RF are the</span>
<span class="sd">              calculated fluctuation integrals for elastic, capture and fission</span>

<span class="sd">              The number of degrees of freedom for each distribution (elastic,</span>
<span class="sd">              fission or competition) may be 1 to 4. If the number of degrees</span>
<span class="sd">              of freedom for any distribution is less than 1 or more than 4</span>
<span class="sd">              it will be treated as an infinite number of degrees of freedom</span>
<span class="sd">              (which infers that the widths are not distributed, but are rather</span>
<span class="sd">              all equal to the average value). This last case is simulated by</span>
<span class="sd">              defining an additional 10 point quadrature in which the weight</span>
<span class="sd">              for one point is 1.0 and the weight for all other points is zero.</span>
<span class="sd">              for the one point of weight 1.0 the average width will be used.</span>

<span class="sd">              :type E: Incident energy, may be scalar or numpy array</span>
<span class="sd">              :type widths: dictionary of numpy arrays,</span>
<span class="sd">                containing average widths for each channel (for a specific L/J combination)</span>
<span class="sd">              :type DOF: dictionary of degrees of freedom for specific L/J</span>

<span class="sd">              :returns tuple(numpy.array) with fluctuation integrals for elastic, capture and fission</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">XX</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">3.0013465e-03</span><span class="p">,</span><span class="mf">1.3219203e-02</span><span class="p">,</span><span class="mf">1.0004488e-03</span><span class="p">,</span><span class="mf">1.3219203e-02</span><span class="p">,</span><span class="mf">1.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">7.8592886e-02</span><span class="p">,</span><span class="mf">7.2349624e-02</span><span class="p">,</span><span class="mf">2.6197629e-02</span><span class="p">,</span><span class="mf">7.2349624e-02</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">4.3282415e-01</span><span class="p">,</span><span class="mf">1.9089473e-01</span><span class="p">,</span><span class="mf">1.4427472e-01</span><span class="p">,</span><span class="mf">1.9089473e-01</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">1.3345267e+00</span><span class="p">,</span><span class="mf">3.9528842e-01</span><span class="p">,</span><span class="mf">4.4484223e-01</span><span class="p">,</span><span class="mf">3.9528842e-01</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">3.0481846e+00</span><span class="p">,</span><span class="mf">7.4083443e-01</span><span class="p">,</span><span class="mf">1.0160615e+00</span><span class="p">,</span><span class="mf">7.4083443e-01</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">5.8263198e+00</span><span class="p">,</span><span class="mf">1.3498293e+00</span><span class="p">,</span><span class="mf">1.9421066e+00</span><span class="p">,</span><span class="mf">1.3498293e+00</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">9.9452656e+00</span><span class="p">,</span><span class="mf">2.5297983e+00</span><span class="p">,</span><span class="mf">3.3150885e+00</span><span class="p">,</span><span class="mf">2.5297983e+00</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">1.5782128e+01</span><span class="p">,</span><span class="mf">5.2384894e+00</span><span class="p">,</span><span class="mf">5.2607092e+00</span><span class="p">,</span><span class="mf">5.2384894e+00</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">2.3996824e+01</span><span class="p">,</span><span class="mf">1.3821772e+01</span><span class="p">,</span><span class="mf">7.9989414e+00</span><span class="p">,</span><span class="mf">1.3821772e+01</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">3.6216208e+01</span><span class="p">,</span><span class="mf">7.5647525e+01</span><span class="p">,</span><span class="mf">1.2072069e+01</span><span class="p">,</span><span class="mf">7.5647525e+01</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],]</span>
        <span class="n">WW</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">1.1120413e-01</span><span class="p">,</span><span class="mf">3.3773418e-02</span><span class="p">,</span><span class="mf">3.3376214e-04</span><span class="p">,</span><span class="mf">1.7623788e-03</span><span class="p">,</span><span class="mf">1.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">2.3546798e-01</span><span class="p">,</span><span class="mf">7.9932171e-02</span><span class="p">,</span><span class="mf">1.8506108e-02</span><span class="p">,</span><span class="mf">2.1517749e-02</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">2.8440987e-01</span><span class="p">,</span><span class="mf">1.2835937e-01</span><span class="p">,</span><span class="mf">1.2309946e-01</span><span class="p">,</span><span class="mf">8.0979849e-02</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">2.2419127e-01</span><span class="p">,</span><span class="mf">1.7652616e-01</span><span class="p">,</span><span class="mf">2.9918923e-01</span><span class="p">,</span><span class="mf">1.8797998e-01</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">1.0967668e-01</span><span class="p">,</span><span class="mf">2.1347043e-01</span><span class="p">,</span><span class="mf">3.3431475e-01</span><span class="p">,</span><span class="mf">3.0156335e-01</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">3.0493789e-02</span><span class="p">,</span><span class="mf">2.1154965e-01</span><span class="p">,</span><span class="mf">1.7766657e-01</span><span class="p">,</span><span class="mf">2.9616091e-01</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">4.2930874e-03</span><span class="p">,</span><span class="mf">1.3365186e-01</span><span class="p">,</span><span class="mf">4.2695894e-02</span><span class="p">,</span><span class="mf">1.0775649e-01</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">2.5827047e-04</span><span class="p">,</span><span class="mf">2.2630659e-02</span><span class="p">,</span><span class="mf">4.0760575e-03</span><span class="p">,</span><span class="mf">2.5171914e-03</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">4.9031965e-06</span><span class="p">,</span><span class="mf">1.6313638e-05</span><span class="p">,</span><span class="mf">1.1766115e-04</span><span class="p">,</span><span class="mf">8.9630388e-10</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">1.4079206e-08</span><span class="p">,</span><span class="mf">0.0000000e+00</span><span class="p">,</span><span class="mf">5.0989546e-07</span><span class="p">,</span><span class="mf">0.0000000e+00</span><span class="p">,</span><span class="mf">0.0e+0</span><span class="p">],]</span>

        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">widths</span><span class="p">[</span><span class="s1">&#39;capture&#39;</span><span class="p">]</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">widths</span><span class="p">[</span><span class="s1">&#39;elastic&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">RE</span><span class="p">,</span><span class="n">RC</span><span class="p">,</span><span class="n">RF</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># We may store non-integer DOF, but we just end up converting to int:</span>
        <span class="n">MUN</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">DOF</span><span class="p">[</span><span class="s1">&#39;elastic&#39;</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">MUN</span><span class="o">&lt;</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">MUN</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">:</span> <span class="n">MUN</span><span class="o">=</span><span class="mi">5</span>
        <span class="n">MUF</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">DOF</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fission&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">MUF</span><span class="o">&lt;</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">MUF</span><span class="o">&gt;</span><span class="mi">5</span><span class="p">:</span> <span class="n">MUF</span><span class="o">=</span><span class="mi">5</span>
        <span class="n">MUX</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span> <span class="n">DOF</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;competitive&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">MUX</span><span class="o">&lt;</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">MUX</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">:</span> <span class="n">MUX</span><span class="o">=</span><span class="mi">5</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
            <span class="n">xj</span> <span class="o">=</span> <span class="n">XX</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">MUN</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">wj</span> <span class="o">=</span> <span class="n">WW</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">MUN</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">widths</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fission&#39;</span><span class="p">,[]))</span> <span class="ow">and</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">widths</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;competitive&#39;</span><span class="p">,[])):</span>
                <span class="n">effj</span> <span class="o">=</span> <span class="n">widths</span><span class="p">[</span><span class="s1">&#39;elastic&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">xj</span><span class="o">+</span><span class="n">widths</span><span class="p">[</span><span class="s1">&#39;capture&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
                    <span class="n">xk</span> <span class="o">=</span> <span class="n">XX</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">MUF</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">wk</span> <span class="o">=</span> <span class="n">WW</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">MUF</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">effjk</span> <span class="o">=</span> <span class="n">effj</span><span class="o">+</span><span class="n">widths</span><span class="p">[</span><span class="s1">&#39;fission&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">xk</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
                        <span class="n">xi</span> <span class="o">=</span> <span class="n">XX</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">MUX</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">wi</span> <span class="o">=</span> <span class="n">WW</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">MUX</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">factor</span> <span class="o">=</span> <span class="n">wi</span><span class="o">*</span><span class="n">wk</span><span class="o">*</span><span class="n">wj</span><span class="o">*</span><span class="n">xj</span><span class="o">/</span><span class="p">(</span><span class="n">effjk</span><span class="o">+</span><span class="n">widths</span><span class="p">[</span><span class="s1">&#39;competitive&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">xi</span><span class="p">)</span>
                        <span class="n">RE</span> <span class="o">+=</span> <span class="n">xj</span><span class="o">*</span><span class="n">factor</span>
                        <span class="n">RC</span> <span class="o">+=</span> <span class="n">factor</span>
                        <span class="n">RF</span> <span class="o">+=</span> <span class="n">xk</span><span class="o">*</span><span class="n">factor</span>
            <span class="k">elif</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">widths</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fission&#39;</span><span class="p">,[])):</span>
                <span class="n">effj</span> <span class="o">=</span> <span class="n">widths</span><span class="p">[</span><span class="s1">&#39;elastic&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">xj</span><span class="o">+</span><span class="n">widths</span><span class="p">[</span><span class="s1">&#39;capture&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
                    <span class="n">xk</span> <span class="o">=</span> <span class="n">XX</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">MUF</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">wk</span> <span class="o">=</span> <span class="n">WW</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">MUF</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">factor</span> <span class="o">=</span> <span class="n">wk</span><span class="o">*</span><span class="n">wj</span><span class="o">*</span><span class="n">xj</span><span class="o">/</span><span class="p">(</span><span class="n">effj</span><span class="o">+</span><span class="n">widths</span><span class="p">[</span><span class="s1">&#39;fission&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">xk</span><span class="p">)</span>
                    <span class="n">RE</span> <span class="o">+=</span> <span class="n">xj</span><span class="o">*</span><span class="n">factor</span>
                    <span class="n">RC</span> <span class="o">+=</span> <span class="n">factor</span>
                    <span class="n">RF</span> <span class="o">+=</span> <span class="n">xk</span><span class="o">*</span><span class="n">factor</span>
            <span class="k">elif</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">widths</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;competitive&#39;</span><span class="p">,[])):</span>
                <span class="n">effj</span> <span class="o">=</span> <span class="n">widths</span><span class="p">[</span><span class="s1">&#39;elastic&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">xj</span> <span class="o">+</span> <span class="n">widths</span><span class="p">[</span><span class="s1">&#39;capture&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
                    <span class="n">xk</span> <span class="o">=</span> <span class="n">XX</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">MUX</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">wk</span> <span class="o">=</span> <span class="n">WW</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">MUX</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">factor</span> <span class="o">=</span> <span class="n">wk</span><span class="o">*</span><span class="n">wj</span><span class="o">*</span><span class="n">xj</span><span class="o">/</span><span class="p">(</span><span class="n">effj</span><span class="o">+</span><span class="n">widths</span><span class="p">[</span><span class="s1">&#39;competitive&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">xk</span><span class="p">)</span>
                    <span class="n">RE</span> <span class="o">+=</span> <span class="n">xj</span><span class="o">*</span><span class="n">factor</span>
                    <span class="n">RC</span> <span class="o">+=</span> <span class="n">factor</span>
            <span class="k">else</span><span class="p">:</span>   <span class="c1"># only elastic and capture widths:</span>
                <span class="n">factor</span> <span class="o">=</span> <span class="n">wj</span> <span class="o">*</span> <span class="n">xj</span> <span class="o">/</span> <span class="p">(</span> <span class="n">widths</span><span class="p">[</span><span class="s1">&#39;elastic&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">xj</span> <span class="o">+</span> <span class="n">widths</span><span class="p">[</span><span class="s1">&#39;capture&#39;</span><span class="p">]</span> <span class="p">)</span>
                <span class="n">RE</span> <span class="o">+=</span> <span class="n">xj</span><span class="o">*</span><span class="n">factor</span>
                <span class="n">RC</span> <span class="o">+=</span> <span class="n">factor</span>
        <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="p">(</span><span class="n">RE</span><span class="p">,</span><span class="n">RC</span><span class="p">,</span><span class="n">RF</span><span class="p">):</span>
            <span class="n">arr</span><span class="p">[</span> <span class="n">widths</span><span class="p">[</span><span class="s1">&#39;elastic&#39;</span><span class="p">]</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">RE</span><span class="p">,</span><span class="n">RC</span><span class="p">,</span><span class="n">RF</span></div>

<div class="viewcode-block" id="URRcrossSection.generateEnergyGrid"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.URRcrossSection.generateEnergyGrid">[docs]</a>    <span class="k">def</span> <span class="nf">generateEnergyGrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interpolateWidths</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the energy grid for reconstructing unresolved resonances. Usually this is just the energy grid</span>
<span class="sd">        chosen by the evaluator for storing energy-dependent widths.</span>

<span class="sd">        ENDF has been revised (with VIII) to interpolate on widths rather than reconstructed cross sections.</span>
<span class="sd">        For discussion see Red&#39;s rant in D.E. Cullen &quot;A Short History of ENDF/B Unresolved Resonance Parameters&quot;,</span>
<span class="sd">        LLNL Report LLNL-TR-461199, ENDF Report ENDF-369 (2010)).</span>

<span class="sd">        :param interpolateWidths: if True, interpolate the average widths</span>
<span class="sd">        :return: a tuple containing the grid and the interpolate flag</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">egrid</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">URR</span><span class="o">.</span><span class="n">Ls</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">J</span> <span class="ow">in</span> <span class="n">L</span><span class="o">.</span><span class="n">Js</span><span class="p">:</span>
                <span class="n">egrid</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="n">J</span><span class="o">.</span><span class="n">levelSpacing</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">domainGrid</span> <span class="p">)</span>  <span class="c1"># FIXME what about units?</span>
                <span class="k">for</span> <span class="n">width</span> <span class="ow">in</span> <span class="n">J</span><span class="o">.</span><span class="n">widths</span><span class="p">:</span>
                    <span class="n">egrid</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="n">width</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">domainGrid</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">egrid</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span> <span class="ow">or</span> <span class="nb">max</span><span class="p">(</span><span class="n">egrid</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unresolved region parameters don&#39;t span stated energy range:&quot;</span> <span class="o">+</span>
                    <span class="s2">&quot; (</span><span class="si">%e</span><span class="s2"> - </span><span class="si">%e</span><span class="s2">) vs (</span><span class="si">%e</span><span class="s2"> - </span><span class="si">%e</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">egrid</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">egrid</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span><span class="p">)</span> <span class="p">)</span>
        <span class="n">egrid</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span><span class="p">]</span> <span class="p">)</span>
        <span class="n">egrid</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">egrid</span><span class="p">)</span>
        <span class="n">lidx</span> <span class="o">=</span> <span class="n">egrid</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lowerBound</span><span class="p">)</span>
        <span class="n">uidx</span> <span class="o">=</span> <span class="n">egrid</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">upperBound</span><span class="p">)</span>
        <span class="n">egrid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">egrid</span><span class="p">[</span><span class="n">lidx</span><span class="p">:</span><span class="n">uidx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>

        <span class="c1"># Fill in any large gaps in original egrid:</span>
        <span class="n">energyGridGaps</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span> <span class="n">egrid</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">/</span> <span class="n">egrid</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">energyGridGaps</span> <span class="p">):</span>
            <span class="n">e_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span> <span class="n">egrid</span> <span class="p">)</span>
            <span class="n">fixGrid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.25</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.7</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">,</span> <span class="mf">7.2</span><span class="p">,</span> <span class="mf">8.5</span><span class="p">]</span> <span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">energyGridGaps</span><span class="p">:</span>
                <span class="n">lowend</span><span class="p">,</span> <span class="n">highend</span> <span class="o">=</span> <span class="n">egrid</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">egrid</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">lowPow</span><span class="p">,</span> <span class="n">highPow</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">lowend</span><span class="p">))),</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">highend</span><span class="p">)))</span>
                <span class="n">lowend</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mf">1e-12</span>                      <span class="c1"># Kludge to handle cases where 3.9999999999999996e-05 should be 4e-5.</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">lowPow</span><span class="p">,</span> <span class="n">highPow</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">):</span>
                    <span class="n">points_to_add</span> <span class="o">=</span> <span class="p">[</span><span class="n">point</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="mi">10</span><span class="o">**</span><span class="n">i</span> <span class="o">*</span> <span class="n">fixGrid</span> <span class="k">if</span> <span class="n">lowend</span> <span class="o">&lt;</span> <span class="n">point</span> <span class="o">&lt;</span> <span class="n">highend</span><span class="p">]</span>
                    <span class="n">e_set</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="n">points_to_add</span> <span class="p">)</span>
            <span class="n">interpolateWidths</span><span class="o">=</span><span class="kc">True</span>
            <span class="n">egrid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="nb">sorted</span><span class="p">(</span> <span class="n">e_set</span> <span class="p">)</span> <span class="p">)</span>

        <span class="k">return</span> <span class="n">egrid</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">interpolateWidths</span></div>

<div class="viewcode-block" id="URRcrossSection.getCrossSection"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.URRcrossSection.getCrossSection">[docs]</a>    <span class="nd">@blockwise</span>
    <span class="k">def</span> <span class="nf">getCrossSection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return unresolved region reconstructed cross sections at incident energy E</span>
<span class="sd">        :param E: incident energy (unit = self.energyUnit).  May be scalar or vector</span>
<span class="sd">        :return: dictionary with cross sections for each reaction.</span>
<span class="sd">            Cross sections are either scalar or vector, depending on type of parameter &#39;E&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;averageWidths&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># do some pre-sorting for convenience</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getWidthsAndSpacings</span><span class="p">()</span>

        <span class="c1"># Integrate to get the average cross section, the ENDF way.  Assumes resonances are SLBW ones (ugh)</span>
        <span class="n">captureSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">elasticSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">fissionSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="n">rhohat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">URR</span><span class="o">.</span><span class="n">getScatteringRadius</span><span class="p">()</span><span class="o">.</span><span class="n">getValueAs</span><span class="p">(</span><span class="s1">&#39;10*fm&#39;</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">URR</span><span class="o">.</span><span class="n">Ls</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">L</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">rhohat</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">J</span> <span class="ow">in</span> <span class="n">L</span><span class="o">.</span><span class="n">Js</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">J</span><span class="o">.</span><span class="n">J</span>
                <span class="n">gfactor</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">projectileSpin</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">targetSpin</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

                <span class="n">VL</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DOFs</span><span class="p">[(</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">)][</span><span class="s1">&#39;elastic&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">rho</span><span class="p">)</span> <span class="o">/</span> <span class="n">rho</span>
                <span class="c1"># Save all the widths in a new widths container to simplify coding in the fluctuating integral widget</span>
                <span class="n">widths</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">averageWidths</span><span class="p">[(</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">)]:</span>
                    <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">averageWidths</span><span class="p">[(</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">)][</span><span class="n">label</span><span class="p">]</span>
                    <span class="n">widths</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span><span class="n">function</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span> <span class="k">for</span> <span class="n">energy</span> <span class="ow">in</span> <span class="n">E</span><span class="p">]</span>
                                                 <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># convert to column vector</span>

                <span class="n">widths</span><span class="p">[</span><span class="s1">&#39;elastic&#39;</span><span class="p">]</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">energyFactor</span> <span class="o">*</span> <span class="n">VL</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>   <span class="c1"># convert reduced width to &#39;regular&#39; width</span>

                <span class="n">RE</span><span class="p">,</span><span class="n">RC</span><span class="p">,</span><span class="n">RF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFluctuationIntegrals</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">DOFs</span><span class="p">[(</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">)])</span>

                <span class="c1"># common factor for all reactions:</span>
                <span class="n">levelSpacing</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">levelSpacings</span><span class="p">[(</span><span class="n">l</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span> <span class="k">for</span> <span class="n">energy</span> <span class="ow">in</span> <span class="n">E</span><span class="p">]</span>
                                             <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">comfac</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">gfactor</span> <span class="o">*</span> <span class="n">widths</span><span class="p">[</span><span class="s1">&#39;elastic&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">levelSpacing</span>

                <span class="n">elasticSum</span> <span class="o">+=</span> <span class="p">(</span> <span class="p">(</span><span class="n">RE</span> <span class="o">*</span> <span class="n">widths</span><span class="p">[</span><span class="s1">&#39;elastic&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">comfac</span> <span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">captureSum</span> <span class="o">+=</span> <span class="p">(</span> <span class="n">RC</span> <span class="o">*</span> <span class="n">widths</span><span class="p">[</span><span class="s1">&#39;capture&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">comfac</span> <span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="s1">&#39;fission&#39;</span> <span class="ow">in</span> <span class="n">widths</span><span class="p">:</span>
                    <span class="n">fissionSum</span> <span class="o">+=</span> <span class="p">(</span> <span class="n">RF</span> <span class="o">*</span> <span class="n">widths</span><span class="p">[</span><span class="s1">&#39;fission&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">comfac</span> <span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>


            <span class="n">elasticSum</span> <span class="o">+=</span> <span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>

        <span class="c1"># common factor &#39;beta&#39; as row vector:</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">E</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">capture</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">captureSum</span>
        <span class="n">elastic</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">elasticSum</span>
        <span class="n">fission</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">fissionSum</span>
        <span class="k">for</span> <span class="n">reaction</span> <span class="ow">in</span> <span class="p">(</span><span class="n">capture</span><span class="p">,</span><span class="n">elastic</span><span class="p">,</span><span class="n">fission</span><span class="p">):</span>
            <span class="n">reaction</span><span class="p">[</span> <span class="n">reaction</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">elastic</span> <span class="o">+</span> <span class="n">capture</span> <span class="o">+</span> <span class="n">fission</span>
        <span class="n">nonelastic</span> <span class="o">=</span> <span class="n">capture</span> <span class="o">+</span> <span class="n">fission</span>

        <span class="n">xscs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;total&#39;</span><span class="p">:</span><span class="n">total</span><span class="p">,</span> <span class="s1">&#39;elastic&#39;</span><span class="p">:</span><span class="n">elastic</span><span class="p">,</span> <span class="s1">&#39;capture&#39;</span><span class="p">:</span><span class="n">capture</span><span class="p">,</span> <span class="s1">&#39;fission&#39;</span><span class="p">:</span><span class="n">fission</span><span class="p">,</span> <span class="s1">&#39;nonelastic&#39;</span><span class="p">:</span><span class="n">nonelastic</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">xscs</span></div>

<div class="viewcode-block" id="URRcrossSection.getTransmissionCoefficients"><a class="viewcode-back" href="../../../../fudge/fudge.processing.resonances.html#fudge.processing.resonances.reconstructResonances.URRcrossSection.getTransmissionCoefficients">[docs]</a>    <span class="k">def</span> <span class="nf">getTransmissionCoefficients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">skipFission</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;weakCoupling&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the effective transmission coefficient in the resolved resonance regime.</span>
<span class="sd">        The method argument controls the schemes to do this.</span>

<span class="sd">        In each case, define the variable tau as::</span>

<span class="sd">            ..math::</span>
<span class="sd">                \\tau_c = \\pi\\overline{\\Gamma}_c/D</span>

<span class="sd">        These are the options:</span>

<span class="sd">            * `method==&#39;weakCoupling&#39;`:  This is the traditional weak coupling limit::</span>

<span class="sd">                ..math::</span>
<span class="sd">                    T_c=2\\tau_c</span>

<span class="sd">            * `method==&#39;1stOrder&#39;`: This is the same as the weak coupling limit.</span>

<span class="sd">            * `method==&#39;2ndOrder&#39;`: This is the 2nd order correction to the weak coupling limit::</span>

<span class="sd">                ..math::</span>
<span class="sd">                    T_c=2\\tau_c(1-\\tau_c)</span>

<span class="sd">            * `method==&#39;sumRule&#39;`: Use Moldauer&#39;s sum rule to extract the transmission coefficients directly from</span>
<span class="sd">              the RRR tables P.A. Moldauer Phys. Rev. Lett. 19, 1047-1048 (1967).  The equation is::</span>

<span class="sd">                ..math::</span>
<span class="sd">                    T_c=2\\tau_c\\left[\\sqrt{1+\\tau_c^2}-\\tau_c\\right]</span>

<span class="sd">            * `method==&#39;opticalModel&#39;`: Use Moldauer&#39;s &#39;optical model&#39; transmission coefficient::</span>

<span class="sd">                ..math::</span>
<span class="sd">                    T_c=1-\\exp{(-2\\tau_c)}</span>

<span class="sd">            * `method`==`SPRT`: Use the</span>

<span class="sd">                ..math::</span>
<span class="sd">                    T_c=\\frac{2\\tau_c}{ (1 + \\tau_c/2)^2 + (P_c R^\\inf_c)^2 }</span>

<span class="sd">        :param skipFission: flag to skip fission, what else?</span>
<span class="sd">        :param method: method to compute the transmission coefficient</span>
<span class="sd">        :return: a dictionary of results, sorted by channel.  Tc entries are all PQU&#39;s or None if it cannot be computed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">allowedMethods</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;weakCoupling&quot;</span><span class="p">,</span> <span class="s1">&#39;1stOrder&#39;</span><span class="p">,</span> <span class="s1">&#39;2ndOrder&#39;</span><span class="p">,</span> <span class="s1">&#39;sumRule&#39;</span><span class="p">,</span> <span class="s1">&#39;opticalModel&#39;</span><span class="p">,</span> <span class="s1">&#39;SPRT&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allowedMethods</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Transmission coefficient calculation method must be one of &#39;</span><span class="o">+</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">allowedMethods</span><span class="p">))</span>
        <span class="c1"># Initialize the reduced width factors for the elastic channel</span>
        <span class="n">redWidthFactor</span><span class="o">=</span><span class="p">{}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">averageWidths</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">getWidthsAndSpacings</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">lj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">averageWidths</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">redWidthFactor</span><span class="p">:</span>
                <span class="n">redWidthFactor</span><span class="p">[</span><span class="n">lj</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">=</span><span class="n">XYs1dModule</span><span class="o">.</span><span class="n">XYs1d</span><span class="o">.</span><span class="n">createFromFunction</span><span class="p">(</span>
                    <span class="n">XYs1dModule</span><span class="o">.</span><span class="n">XYs1d</span><span class="o">.</span><span class="n">defaultAxes</span><span class="p">(</span>
                        <span class="n">labelsUnits</span><span class="o">=</span><span class="p">{</span>
                            <span class="n">XYs1dModule</span><span class="o">.</span><span class="n">yAxisIndex</span> <span class="p">:</span> <span class="p">(</span> <span class="s1">&#39;gamma&#39;</span> <span class="p">,</span> <span class="s1">&#39;&#39;</span> <span class="p">),</span>
                            <span class="n">XYs1dModule</span><span class="o">.</span><span class="n">xAxisIndex</span> <span class="p">:</span> <span class="p">(</span> <span class="s1">&#39;Ex&#39;</span><span class="p">,</span> <span class="s1">&#39;eV&#39;</span> <span class="p">)</span> <span class="p">}),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">averageWidths</span><span class="p">[</span><span class="n">lj</span><span class="p">][</span><span class="s1">&#39;elastic&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">domain</span><span class="p">(),</span>
                    <span class="k">lambda</span> <span class="n">E</span><span class="p">,</span><span class="n">nope</span><span class="p">:</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">penetrationFactor</span><span class="p">(</span> <span class="n">lj</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">(</span><span class="n">E</span><span class="p">),</span>
                    <span class="p">{},</span>
                    <span class="mf">1e-6</span><span class="p">,</span>
                    <span class="mi">100</span><span class="p">)</span>

        <span class="c1"># Now compute the Tc&#39;s</span>
        <span class="n">Tc</span><span class="o">=</span><span class="p">{}</span>
        <span class="n">channelClass</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;capture&#39;</span><span class="p">:</span><span class="n">GAMMACHANNEL</span><span class="p">,</span> <span class="s1">&#39;elastic&#39;</span><span class="p">:</span><span class="n">NEUTRONCHANNEL</span><span class="p">,</span> <span class="s1">&#39;fission&#39;</span><span class="p">:</span><span class="n">FISSIONCHANNEL</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">rxn</span> <span class="ow">in</span> <span class="n">channelClass</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">lj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">averageWidths</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">rxn</span><span class="o">==</span><span class="s1">&#39;elastic&#39;</span><span class="p">:</span>
                    <span class="n">tau</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">redWidthFactor</span><span class="p">[</span><span class="n">lj</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">averageWidths</span><span class="p">[</span><span class="n">lj</span><span class="p">][</span><span class="n">rxn</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">levelSpacings</span><span class="p">[</span><span class="n">lj</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">rxn</span><span class="o">==</span><span class="s1">&#39;fission&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">skipFission</span><span class="p">:</span> <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">rxn</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">averageWidths</span><span class="p">[</span><span class="n">lj</span><span class="p">]:</span> <span class="k">continue</span>
                    <span class="n">tau</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">averageWidths</span><span class="p">[</span><span class="n">lj</span><span class="p">][</span><span class="n">rxn</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">levelSpacings</span><span class="p">[</span><span class="n">lj</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tau</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">averageWidths</span><span class="p">[</span><span class="n">lj</span><span class="p">][</span><span class="n">rxn</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">levelSpacings</span><span class="p">[</span><span class="n">lj</span><span class="p">]</span>
                <span class="n">c</span><span class="o">=</span><span class="n">ChannelDesignator</span><span class="p">(</span><span class="n">lj</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lj</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">rxn</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">Tc</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">lj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">lj</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">gfact</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">particleA</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">particleB</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">isElastic</span><span class="o">=</span><span class="p">(</span><span class="n">rxn</span><span class="o">==</span><span class="s1">&#39;elastic&#39;</span><span class="p">),</span>
                                    <span class="n">channelClass</span><span class="o">=</span><span class="n">channelClass</span><span class="p">[</span><span class="n">rxn</span><span class="p">],</span> <span class="n">useRelativistic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">eliminated</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;weakCoupling&quot;</span><span class="p">,</span> <span class="s1">&#39;1stOrder&#39;</span><span class="p">]:</span>
                    <span class="n">Tc</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">tau</span>
                <span class="k">elif</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;2ndOrder&#39;</span><span class="p">:</span>
                    <span class="n">Tc</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">tau</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">tau</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">method</span><span class="o">==</span><span class="s2">&quot;opticalModel&quot;</span><span class="p">:</span>
                    <span class="n">Tc</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">tau</span><span class="o">.</span><span class="n">applyFunction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">par</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">tau</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="kc">None</span><span class="p">)</span> <span class="c1">#FIXME: &quot;tau.evaluate(x)&quot; should only be &quot;x&quot;, but applyFunction() is broken as is exp()</span>
                <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;sumRule&#39;</span><span class="p">:</span>
                    <span class="n">Tc</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">tau</span><span class="o">.</span><span class="n">applyFunction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">par</span><span class="p">:</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">tau</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">tau</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">tau</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">-</span> <span class="n">tau</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1">#method==&quot;SPRT&quot;</span>
                    <span class="n">Tc</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">tau</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="n">tau</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="n">tau</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>

                <span class="c1"># Fix axis label, still says &quot;Gamma&quot;</span>
                <span class="n">Tc</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;Tc(rxn=</span><span class="si">%s</span><span class="s1">, L=</span><span class="si">%i</span><span class="s1">, J=</span><span class="si">%s</span><span class="s1">)&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">reaction</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">J</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">Tc</span></div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../../index.html">
              <img class="logo" src="../../../../_static/gnd.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">Fudge and GNDS 6.1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">fudge.processing.resonances.reconstructResonances</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2012, B.Beck, D. Brown, C. Mattoon, N. Patel, N. Summers.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.0.2.
    </div>
  </body>
</html>